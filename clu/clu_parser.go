// Code generated from clu.g4 by ANTLR 4.7.2. DO NOT EDIT.

package clu // clu
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 95, 778,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 3, 2, 7, 2, 102, 10, 2, 12, 2, 14, 2, 105, 11, 2, 3, 2, 3, 2,
	3, 2, 5, 2, 110, 10, 2, 3, 3, 3, 3, 3, 3, 3, 3, 5, 3, 116, 10, 3, 3, 3,
	3, 3, 5, 3, 120, 10, 3, 3, 3, 5, 3, 123, 10, 3, 3, 3, 5, 3, 126, 10, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 3, 4, 3, 4, 3, 4, 5, 4, 136, 10, 4, 3, 4,
	3, 4, 5, 4, 140, 10, 4, 3, 4, 5, 4, 143, 10, 4, 3, 4, 5, 4, 146, 10, 4,
	3, 4, 3, 4, 3, 4, 3, 4, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 156, 10, 5, 3, 5,
	3, 5, 3, 5, 5, 5, 161, 10, 5, 3, 5, 3, 5, 3, 5, 3, 5, 3, 6, 3, 6, 3, 6,
	7, 6, 170, 10, 6, 12, 6, 14, 6, 173, 11, 6, 3, 7, 3, 7, 3, 7, 3, 7, 5,
	7, 179, 10, 7, 3, 8, 3, 8, 5, 8, 183, 10, 8, 3, 8, 3, 8, 3, 9, 3, 9, 3,
	9, 7, 9, 190, 10, 9, 12, 9, 14, 9, 193, 11, 9, 3, 10, 3, 10, 3, 10, 3,
	10, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12,
	3, 13, 3, 13, 3, 13, 3, 13, 3, 13, 7, 13, 214, 10, 13, 12, 13, 14, 13,
	217, 11, 13, 3, 13, 3, 13, 3, 14, 3, 14, 5, 14, 223, 10, 14, 3, 15, 3,
	15, 3, 15, 7, 15, 228, 10, 15, 12, 15, 14, 15, 231, 11, 15, 3, 16, 3, 16,
	3, 16, 3, 16, 7, 16, 237, 10, 16, 12, 16, 14, 16, 240, 11, 16, 3, 17, 3,
	17, 3, 17, 3, 17, 3, 17, 5, 17, 247, 10, 17, 3, 18, 3, 18, 3, 18, 3, 18,
	3, 18, 7, 18, 254, 10, 18, 12, 18, 14, 18, 257, 11, 18, 7, 18, 259, 10,
	18, 12, 18, 14, 18, 262, 11, 18, 3, 18, 5, 18, 265, 10, 18, 3, 19, 3, 19,
	3, 19, 7, 19, 270, 10, 19, 12, 19, 14, 19, 273, 11, 19, 3, 20, 3, 20, 3,
	20, 3, 20, 3, 21, 3, 21, 3, 21, 7, 21, 282, 10, 21, 12, 21, 14, 21, 285,
	11, 21, 3, 22, 3, 22, 3, 22, 5, 22, 290, 10, 22, 3, 22, 3, 22, 3, 23, 3,
	23, 3, 23, 7, 23, 297, 10, 23, 12, 23, 14, 23, 300, 11, 23, 3, 24, 3, 24,
	5, 24, 304, 10, 24, 3, 25, 7, 25, 307, 10, 25, 12, 25, 14, 25, 310, 11,
	25, 3, 25, 7, 25, 313, 10, 25, 12, 25, 14, 25, 316, 11, 25, 3, 25, 7, 25,
	319, 10, 25, 12, 25, 14, 25, 322, 11, 25, 3, 26, 7, 26, 325, 10, 26, 12,
	26, 14, 26, 328, 11, 26, 3, 26, 3, 26, 3, 26, 3, 26, 7, 26, 334, 10, 26,
	12, 26, 14, 26, 337, 11, 26, 3, 26, 7, 26, 340, 10, 26, 12, 26, 14, 26,
	343, 11, 26, 3, 26, 3, 26, 7, 26, 347, 10, 26, 12, 26, 14, 26, 350, 11,
	26, 3, 27, 3, 27, 5, 27, 354, 10, 27, 3, 28, 3, 28, 3, 28, 3, 28, 5, 28,
	360, 10, 28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3,
	29, 3, 29, 3, 29, 3, 29, 5, 29, 374, 10, 29, 3, 30, 3, 30, 3, 30, 3, 30,
	3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 3, 30, 5, 30, 388, 10,
	30, 5, 30, 390, 10, 30, 3, 30, 3, 30, 5, 30, 394, 10, 30, 3, 30, 3, 30,
	5, 30, 398, 10, 30, 3, 30, 5, 30, 401, 10, 30, 3, 30, 5, 30, 404, 10, 30,
	3, 30, 3, 30, 5, 30, 408, 10, 30, 5, 30, 410, 10, 30, 3, 31, 3, 31, 3,
	31, 7, 31, 415, 10, 31, 12, 31, 14, 31, 418, 11, 31, 3, 32, 3, 32, 3, 32,
	3, 32, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3,
	33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 440, 10, 33, 3, 33,
	3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3,
	33, 3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 458, 10, 33, 3, 33, 3, 33, 3, 33,
	3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3,
	33, 3, 33, 7, 33, 475, 10, 33, 12, 33, 14, 33, 478, 11, 33, 3, 33, 3, 33,
	5, 33, 482, 10, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3, 33, 7, 33, 489, 10,
	33, 12, 33, 14, 33, 492, 11, 33, 3, 33, 3, 33, 3, 33, 5, 33, 497, 10, 33,
	3, 33, 3, 33, 3, 33, 3, 33, 5, 33, 503, 10, 33, 3, 33, 3, 33, 3, 33, 5,
	33, 508, 10, 33, 3, 33, 3, 33, 3, 33, 5, 33, 513, 10, 33, 3, 33, 3, 33,
	3, 33, 3, 33, 3, 33, 5, 33, 520, 10, 33, 3, 33, 3, 33, 3, 33, 3, 33, 3,
	33, 7, 33, 527, 10, 33, 12, 33, 14, 33, 530, 11, 33, 3, 33, 5, 33, 533,
	10, 33, 3, 33, 5, 33, 536, 10, 33, 7, 33, 538, 10, 33, 12, 33, 14, 33,
	541, 11, 33, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 3, 34, 5,
	34, 551, 10, 34, 3, 34, 3, 34, 3, 34, 3, 35, 3, 35, 3, 35, 3, 35, 3, 35,
	3, 35, 5, 35, 562, 10, 35, 5, 35, 564, 10, 35, 3, 35, 3, 35, 3, 35, 3,
	36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 3, 36, 5, 36, 576, 10, 36, 3, 36,
	3, 36, 3, 36, 3, 37, 7, 37, 582, 10, 37, 12, 37, 14, 37, 585, 11, 37, 3,
	37, 7, 37, 588, 10, 37, 12, 37, 14, 37, 591, 11, 37, 3, 38, 3, 38, 3, 38,
	7, 38, 596, 10, 38, 12, 38, 14, 38, 599, 11, 38, 3, 39, 3, 39, 3, 39, 3,
	39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 611, 10, 39, 3, 39,
	3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3,
	39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39,
	3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3,
	39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39,
	3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3,
	39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 7, 39,
	676, 10, 39, 12, 39, 14, 39, 679, 11, 39, 3, 40, 3, 40, 3, 40, 3, 40, 3,
	40, 3, 40, 3, 40, 3, 40, 3, 40, 5, 40, 690, 10, 40, 3, 40, 3, 40, 3, 40,
	3, 40, 3, 40, 3, 40, 3, 40, 5, 40, 699, 10, 40, 3, 40, 3, 40, 5, 40, 703,
	10, 40, 3, 40, 3, 40, 5, 40, 707, 10, 40, 3, 40, 3, 40, 5, 40, 711, 10,
	40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 5, 40, 718, 10, 40, 3, 40, 3, 40,
	3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 3, 40, 7, 40, 730, 10,
	40, 12, 40, 14, 40, 733, 11, 40, 3, 41, 3, 41, 3, 41, 3, 41, 3, 41, 3,
	42, 3, 42, 3, 42, 7, 42, 743, 10, 42, 12, 42, 14, 42, 746, 11, 42, 3, 43,
	3, 43, 3, 43, 3, 43, 3, 44, 3, 44, 3, 44, 7, 44, 755, 10, 44, 12, 44, 14,
	44, 758, 11, 44, 3, 45, 3, 45, 3, 46, 3, 46, 3, 46, 7, 46, 765, 10, 46,
	12, 46, 14, 46, 768, 11, 46, 3, 47, 3, 47, 3, 48, 3, 48, 3, 49, 3, 49,
	3, 50, 3, 50, 3, 50, 2, 5, 64, 76, 78, 51, 2, 4, 6, 8, 10, 12, 14, 16,
	18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52,
	54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88,
	90, 92, 94, 96, 98, 2, 6, 3, 2, 36, 39, 3, 2, 40, 41, 3, 2, 52, 53, 3,
	2, 88, 89, 2, 869, 2, 103, 3, 2, 2, 2, 4, 111, 3, 2, 2, 2, 6, 131, 3, 2,
	2, 2, 8, 151, 3, 2, 2, 2, 10, 166, 3, 2, 2, 2, 12, 174, 3, 2, 2, 2, 14,
	180, 3, 2, 2, 2, 16, 186, 3, 2, 2, 2, 18, 194, 3, 2, 2, 2, 20, 198, 3,
	2, 2, 2, 22, 203, 3, 2, 2, 2, 24, 208, 3, 2, 2, 2, 26, 220, 3, 2, 2, 2,
	28, 224, 3, 2, 2, 2, 30, 232, 3, 2, 2, 2, 32, 241, 3, 2, 2, 2, 34, 264,
	3, 2, 2, 2, 36, 266, 3, 2, 2, 2, 38, 274, 3, 2, 2, 2, 40, 278, 3, 2, 2,
	2, 42, 286, 3, 2, 2, 2, 44, 293, 3, 2, 2, 2, 46, 303, 3, 2, 2, 2, 48, 308,
	3, 2, 2, 2, 50, 326, 3, 2, 2, 2, 52, 353, 3, 2, 2, 2, 54, 355, 3, 2, 2,
	2, 56, 361, 3, 2, 2, 2, 58, 409, 3, 2, 2, 2, 60, 411, 3, 2, 2, 2, 62, 419,
	3, 2, 2, 2, 64, 519, 3, 2, 2, 2, 66, 542, 3, 2, 2, 2, 68, 555, 3, 2, 2,
	2, 70, 568, 3, 2, 2, 2, 72, 583, 3, 2, 2, 2, 74, 592, 3, 2, 2, 2, 76, 610,
	3, 2, 2, 2, 78, 717, 3, 2, 2, 2, 80, 734, 3, 2, 2, 2, 82, 739, 3, 2, 2,
	2, 84, 747, 3, 2, 2, 2, 86, 751, 3, 2, 2, 2, 88, 759, 3, 2, 2, 2, 90, 761,
	3, 2, 2, 2, 92, 769, 3, 2, 2, 2, 94, 771, 3, 2, 2, 2, 96, 773, 3, 2, 2,
	2, 98, 775, 3, 2, 2, 2, 100, 102, 5, 54, 28, 2, 101, 100, 3, 2, 2, 2, 102,
	105, 3, 2, 2, 2, 103, 101, 3, 2, 2, 2, 103, 104, 3, 2, 2, 2, 104, 109,
	3, 2, 2, 2, 105, 103, 3, 2, 2, 2, 106, 110, 5, 4, 3, 2, 107, 110, 5, 6,
	4, 2, 108, 110, 5, 8, 5, 2, 109, 106, 3, 2, 2, 2, 109, 107, 3, 2, 2, 2,
	109, 108, 3, 2, 2, 2, 110, 3, 3, 2, 2, 2, 111, 112, 5, 88, 45, 2, 112,
	113, 7, 3, 2, 2, 113, 115, 7, 4, 2, 2, 114, 116, 5, 10, 6, 2, 115, 114,
	3, 2, 2, 2, 115, 116, 3, 2, 2, 2, 116, 117, 3, 2, 2, 2, 117, 119, 5, 14,
	8, 2, 118, 120, 5, 20, 11, 2, 119, 118, 3, 2, 2, 2, 119, 120, 3, 2, 2,
	2, 120, 122, 3, 2, 2, 2, 121, 123, 5, 24, 13, 2, 122, 121, 3, 2, 2, 2,
	122, 123, 3, 2, 2, 2, 123, 125, 3, 2, 2, 2, 124, 126, 5, 30, 16, 2, 125,
	124, 3, 2, 2, 2, 125, 126, 3, 2, 2, 2, 126, 127, 3, 2, 2, 2, 127, 128,
	5, 48, 25, 2, 128, 129, 7, 5, 2, 2, 129, 130, 5, 88, 45, 2, 130, 5, 3,
	2, 2, 2, 131, 132, 5, 88, 45, 2, 132, 133, 7, 3, 2, 2, 133, 135, 7, 6,
	2, 2, 134, 136, 5, 10, 6, 2, 135, 134, 3, 2, 2, 2, 135, 136, 3, 2, 2, 2,
	136, 137, 3, 2, 2, 2, 137, 139, 5, 14, 8, 2, 138, 140, 5, 22, 12, 2, 139,
	138, 3, 2, 2, 2, 139, 140, 3, 2, 2, 2, 140, 142, 3, 2, 2, 2, 141, 143,
	5, 24, 13, 2, 142, 141, 3, 2, 2, 2, 142, 143, 3, 2, 2, 2, 143, 145, 3,
	2, 2, 2, 144, 146, 5, 30, 16, 2, 145, 144, 3, 2, 2, 2, 145, 146, 3, 2,
	2, 2, 146, 147, 3, 2, 2, 2, 147, 148, 5, 48, 25, 2, 148, 149, 7, 5, 2,
	2, 149, 150, 5, 88, 45, 2, 150, 7, 3, 2, 2, 2, 151, 152, 5, 88, 45, 2,
	152, 153, 7, 3, 2, 2, 153, 155, 7, 7, 2, 2, 154, 156, 5, 10, 6, 2, 155,
	154, 3, 2, 2, 2, 155, 156, 3, 2, 2, 2, 156, 157, 3, 2, 2, 2, 157, 158,
	7, 8, 2, 2, 158, 160, 5, 86, 44, 2, 159, 161, 5, 30, 16, 2, 160, 159, 3,
	2, 2, 2, 160, 161, 3, 2, 2, 2, 161, 162, 3, 2, 2, 2, 162, 163, 5, 50, 26,
	2, 163, 164, 7, 5, 2, 2, 164, 165, 5, 88, 45, 2, 165, 9, 3, 2, 2, 2, 166,
	171, 5, 12, 7, 2, 167, 168, 7, 9, 2, 2, 168, 170, 5, 12, 7, 2, 169, 167,
	3, 2, 2, 2, 170, 173, 3, 2, 2, 2, 171, 169, 3, 2, 2, 2, 171, 172, 3, 2,
	2, 2, 172, 11, 3, 2, 2, 2, 173, 171, 3, 2, 2, 2, 174, 175, 5, 86, 44, 2,
	175, 178, 7, 10, 2, 2, 176, 179, 7, 11, 2, 2, 177, 179, 5, 58, 30, 2, 178,
	176, 3, 2, 2, 2, 178, 177, 3, 2, 2, 2, 179, 13, 3, 2, 2, 2, 180, 182, 7,
	12, 2, 2, 181, 183, 5, 16, 9, 2, 182, 181, 3, 2, 2, 2, 182, 183, 3, 2,
	2, 2, 183, 184, 3, 2, 2, 2, 184, 185, 7, 13, 2, 2, 185, 15, 3, 2, 2, 2,
	186, 191, 5, 18, 10, 2, 187, 188, 7, 9, 2, 2, 188, 190, 5, 18, 10, 2, 189,
	187, 3, 2, 2, 2, 190, 193, 3, 2, 2, 2, 191, 189, 3, 2, 2, 2, 191, 192,
	3, 2, 2, 2, 192, 17, 3, 2, 2, 2, 193, 191, 3, 2, 2, 2, 194, 195, 5, 86,
	44, 2, 195, 196, 7, 10, 2, 2, 196, 197, 5, 58, 30, 2, 197, 19, 3, 2, 2,
	2, 198, 199, 7, 14, 2, 2, 199, 200, 7, 12, 2, 2, 200, 201, 5, 28, 15, 2,
	201, 202, 7, 13, 2, 2, 202, 21, 3, 2, 2, 2, 203, 204, 7, 15, 2, 2, 204,
	205, 7, 12, 2, 2, 205, 206, 5, 28, 15, 2, 206, 207, 7, 13, 2, 2, 207, 23,
	3, 2, 2, 2, 208, 209, 7, 16, 2, 2, 209, 210, 7, 12, 2, 2, 210, 215, 5,
	26, 14, 2, 211, 212, 7, 9, 2, 2, 212, 214, 5, 26, 14, 2, 213, 211, 3, 2,
	2, 2, 214, 217, 3, 2, 2, 2, 215, 213, 3, 2, 2, 2, 215, 216, 3, 2, 2, 2,
	216, 218, 3, 2, 2, 2, 217, 215, 3, 2, 2, 2, 218, 219, 7, 13, 2, 2, 219,
	25, 3, 2, 2, 2, 220, 222, 5, 92, 47, 2, 221, 223, 5, 28, 15, 2, 222, 221,
	3, 2, 2, 2, 222, 223, 3, 2, 2, 2, 223, 27, 3, 2, 2, 2, 224, 229, 5, 58,
	30, 2, 225, 226, 7, 9, 2, 2, 226, 228, 5, 58, 30, 2, 227, 225, 3, 2, 2,
	2, 228, 231, 3, 2, 2, 2, 229, 227, 3, 2, 2, 2, 229, 230, 3, 2, 2, 2, 230,
	29, 3, 2, 2, 2, 231, 229, 3, 2, 2, 2, 232, 233, 7, 17, 2, 2, 233, 238,
	5, 32, 17, 2, 234, 235, 7, 9, 2, 2, 235, 237, 5, 32, 17, 2, 236, 234, 3,
	2, 2, 2, 237, 240, 3, 2, 2, 2, 238, 236, 3, 2, 2, 2, 238, 239, 3, 2, 2,
	2, 239, 31, 3, 2, 2, 2, 240, 238, 3, 2, 2, 2, 241, 246, 5, 88, 45, 2, 242,
	243, 7, 18, 2, 2, 243, 247, 5, 36, 19, 2, 244, 245, 7, 19, 2, 2, 245, 247,
	5, 34, 18, 2, 246, 242, 3, 2, 2, 2, 246, 244, 3, 2, 2, 2, 247, 33, 3, 2,
	2, 2, 248, 259, 5, 88, 45, 2, 249, 250, 5, 88, 45, 2, 250, 251, 7, 18,
	2, 2, 251, 255, 5, 36, 19, 2, 252, 254, 5, 54, 28, 2, 253, 252, 3, 2, 2,
	2, 254, 257, 3, 2, 2, 2, 255, 253, 3, 2, 2, 2, 255, 256, 3, 2, 2, 2, 256,
	259, 3, 2, 2, 2, 257, 255, 3, 2, 2, 2, 258, 248, 3, 2, 2, 2, 258, 249,
	3, 2, 2, 2, 259, 262, 3, 2, 2, 2, 260, 258, 3, 2, 2, 2, 260, 261, 3, 2,
	2, 2, 261, 265, 3, 2, 2, 2, 262, 260, 3, 2, 2, 2, 263, 265, 5, 88, 45,
	2, 264, 260, 3, 2, 2, 2, 264, 263, 3, 2, 2, 2, 265, 35, 3, 2, 2, 2, 266,
	271, 5, 38, 20, 2, 267, 268, 7, 9, 2, 2, 268, 270, 5, 38, 20, 2, 269, 267,
	3, 2, 2, 2, 270, 273, 3, 2, 2, 2, 271, 269, 3, 2, 2, 2, 271, 272, 3, 2,
	2, 2, 272, 37, 3, 2, 2, 2, 273, 271, 3, 2, 2, 2, 274, 275, 5, 40, 21, 2,
	275, 276, 7, 10, 2, 2, 276, 277, 5, 58, 30, 2, 277, 39, 3, 2, 2, 2, 278,
	283, 5, 42, 22, 2, 279, 280, 7, 9, 2, 2, 280, 282, 5, 42, 22, 2, 281, 279,
	3, 2, 2, 2, 282, 285, 3, 2, 2, 2, 283, 281, 3, 2, 2, 2, 283, 284, 3, 2,
	2, 2, 284, 41, 3, 2, 2, 2, 285, 283, 3, 2, 2, 2, 286, 287, 5, 92, 47, 2,
	287, 289, 7, 20, 2, 2, 288, 290, 5, 44, 23, 2, 289, 288, 3, 2, 2, 2, 289,
	290, 3, 2, 2, 2, 290, 291, 3, 2, 2, 2, 291, 292, 7, 21, 2, 2, 292, 43,
	3, 2, 2, 2, 293, 298, 5, 46, 24, 2, 294, 295, 7, 9, 2, 2, 295, 297, 5,
	46, 24, 2, 296, 294, 3, 2, 2, 2, 297, 300, 3, 2, 2, 2, 298, 296, 3, 2,
	2, 2, 298, 299, 3, 2, 2, 2, 299, 45, 3, 2, 2, 2, 300, 298, 3, 2, 2, 2,
	301, 304, 5, 76, 39, 2, 302, 304, 5, 58, 30, 2, 303, 301, 3, 2, 2, 2, 303,
	302, 3, 2, 2, 2, 304, 47, 3, 2, 2, 2, 305, 307, 5, 54, 28, 2, 306, 305,
	3, 2, 2, 2, 307, 310, 3, 2, 2, 2, 308, 306, 3, 2, 2, 2, 308, 309, 3, 2,
	2, 2, 309, 314, 3, 2, 2, 2, 310, 308, 3, 2, 2, 2, 311, 313, 5, 56, 29,
	2, 312, 311, 3, 2, 2, 2, 313, 316, 3, 2, 2, 2, 314, 312, 3, 2, 2, 2, 314,
	315, 3, 2, 2, 2, 315, 320, 3, 2, 2, 2, 316, 314, 3, 2, 2, 2, 317, 319,
	5, 64, 33, 2, 318, 317, 3, 2, 2, 2, 319, 322, 3, 2, 2, 2, 320, 318, 3,
	2, 2, 2, 320, 321, 3, 2, 2, 2, 321, 49, 3, 2, 2, 2, 322, 320, 3, 2, 2,
	2, 323, 325, 5, 54, 28, 2, 324, 323, 3, 2, 2, 2, 325, 328, 3, 2, 2, 2,
	326, 324, 3, 2, 2, 2, 326, 327, 3, 2, 2, 2, 327, 329, 3, 2, 2, 2, 328,
	326, 3, 2, 2, 2, 329, 330, 7, 22, 2, 2, 330, 331, 7, 3, 2, 2, 331, 335,
	5, 58, 30, 2, 332, 334, 5, 54, 28, 2, 333, 332, 3, 2, 2, 2, 334, 337, 3,
	2, 2, 2, 335, 333, 3, 2, 2, 2, 335, 336, 3, 2, 2, 2, 336, 341, 3, 2, 2,
	2, 337, 335, 3, 2, 2, 2, 338, 340, 5, 56, 29, 2, 339, 338, 3, 2, 2, 2,
	340, 343, 3, 2, 2, 2, 341, 339, 3, 2, 2, 2, 341, 342, 3, 2, 2, 2, 342,
	344, 3, 2, 2, 2, 343, 341, 3, 2, 2, 2, 344, 348, 7, 23, 2, 2, 345, 347,
	5, 52, 27, 2, 346, 345, 3, 2, 2, 2, 347, 350, 3, 2, 2, 2, 348, 346, 3,
	2, 2, 2, 348, 349, 3, 2, 2, 2, 349, 51, 3, 2, 2, 2, 350, 348, 3, 2, 2,
	2, 351, 354, 5, 4, 3, 2, 352, 354, 5, 6, 4, 2, 353, 351, 3, 2, 2, 2, 353,
	352, 3, 2, 2, 2, 354, 53, 3, 2, 2, 2, 355, 356, 5, 88, 45, 2, 356, 359,
	7, 3, 2, 2, 357, 360, 5, 46, 24, 2, 358, 360, 5, 34, 18, 2, 359, 357, 3,
	2, 2, 2, 359, 358, 3, 2, 2, 2, 360, 55, 3, 2, 2, 2, 361, 373, 7, 24, 2,
	2, 362, 374, 5, 18, 10, 2, 363, 364, 5, 88, 45, 2, 364, 365, 7, 10, 2,
	2, 365, 366, 5, 58, 30, 2, 366, 367, 7, 25, 2, 2, 367, 368, 5, 76, 39,
	2, 368, 374, 3, 2, 2, 2, 369, 370, 5, 16, 9, 2, 370, 371, 7, 25, 2, 2,
	371, 372, 5, 80, 41, 2, 372, 374, 3, 2, 2, 2, 373, 362, 3, 2, 2, 2, 373,
	363, 3, 2, 2, 2, 373, 369, 3, 2, 2, 2, 374, 57, 3, 2, 2, 2, 375, 410, 7,
	26, 2, 2, 376, 410, 7, 27, 2, 2, 377, 410, 7, 28, 2, 2, 378, 410, 7, 29,
	2, 2, 379, 410, 7, 30, 2, 2, 380, 410, 7, 31, 2, 2, 381, 410, 7, 32, 2,
	2, 382, 410, 7, 22, 2, 2, 383, 410, 7, 33, 2, 2, 384, 390, 7, 34, 2, 2,
	385, 387, 7, 35, 2, 2, 386, 388, 5, 58, 30, 2, 387, 386, 3, 2, 2, 2, 387,
	388, 3, 2, 2, 2, 388, 390, 3, 2, 2, 2, 389, 384, 3, 2, 2, 2, 389, 385,
	3, 2, 2, 2, 390, 410, 3, 2, 2, 2, 391, 393, 9, 2, 2, 2, 392, 394, 5, 60,
	31, 2, 393, 392, 3, 2, 2, 2, 393, 394, 3, 2, 2, 2, 394, 410, 3, 2, 2, 2,
	395, 397, 9, 3, 2, 2, 396, 398, 5, 60, 31, 2, 397, 396, 3, 2, 2, 2, 397,
	398, 3, 2, 2, 2, 398, 400, 3, 2, 2, 2, 399, 401, 5, 20, 11, 2, 400, 399,
	3, 2, 2, 2, 400, 401, 3, 2, 2, 2, 401, 403, 3, 2, 2, 2, 402, 404, 5, 24,
	13, 2, 403, 402, 3, 2, 2, 2, 403, 404, 3, 2, 2, 2, 404, 410, 3, 2, 2, 2,
	405, 407, 5, 88, 45, 2, 406, 408, 5, 44, 23, 2, 407, 406, 3, 2, 2, 2, 407,
	408, 3, 2, 2, 2, 408, 410, 3, 2, 2, 2, 409, 375, 3, 2, 2, 2, 409, 376,
	3, 2, 2, 2, 409, 377, 3, 2, 2, 2, 409, 378, 3, 2, 2, 2, 409, 379, 3, 2,
	2, 2, 409, 380, 3, 2, 2, 2, 409, 381, 3, 2, 2, 2, 409, 382, 3, 2, 2, 2,
	409, 383, 3, 2, 2, 2, 409, 389, 3, 2, 2, 2, 409, 391, 3, 2, 2, 2, 409,
	395, 3, 2, 2, 2, 409, 405, 3, 2, 2, 2, 410, 59, 3, 2, 2, 2, 411, 416, 5,
	62, 32, 2, 412, 413, 7, 9, 2, 2, 413, 415, 5, 62, 32, 2, 414, 412, 3, 2,
	2, 2, 415, 418, 3, 2, 2, 2, 416, 414, 3, 2, 2, 2, 416, 417, 3, 2, 2, 2,
	417, 61, 3, 2, 2, 2, 418, 416, 3, 2, 2, 2, 419, 420, 5, 90, 46, 2, 420,
	421, 7, 10, 2, 2, 421, 422, 5, 58, 30, 2, 422, 63, 3, 2, 2, 2, 423, 424,
	8, 33, 1, 2, 424, 520, 5, 18, 10, 2, 425, 426, 5, 88, 45, 2, 426, 427,
	7, 10, 2, 2, 427, 428, 5, 58, 30, 2, 428, 429, 7, 25, 2, 2, 429, 430, 5,
	76, 39, 2, 430, 520, 3, 2, 2, 2, 431, 432, 5, 16, 9, 2, 432, 433, 7, 25,
	2, 2, 433, 434, 5, 80, 41, 2, 434, 520, 3, 2, 2, 2, 435, 436, 5, 86, 44,
	2, 436, 439, 7, 25, 2, 2, 437, 440, 5, 80, 41, 2, 438, 440, 5, 74, 38,
	2, 439, 437, 3, 2, 2, 2, 439, 438, 3, 2, 2, 2, 440, 520, 3, 2, 2, 2, 441,
	442, 5, 78, 40, 2, 442, 443, 7, 42, 2, 2, 443, 444, 5, 92, 47, 2, 444,
	445, 7, 25, 2, 2, 445, 446, 5, 76, 39, 2, 446, 520, 3, 2, 2, 2, 447, 520,
	5, 80, 41, 2, 448, 449, 7, 43, 2, 2, 449, 450, 5, 76, 39, 2, 450, 451,
	7, 44, 2, 2, 451, 452, 5, 72, 37, 2, 452, 453, 7, 5, 2, 2, 453, 520, 3,
	2, 2, 2, 454, 457, 7, 45, 2, 2, 455, 458, 5, 16, 9, 2, 456, 458, 5, 86,
	44, 2, 457, 455, 3, 2, 2, 2, 457, 456, 3, 2, 2, 2, 457, 458, 3, 2, 2, 2,
	458, 459, 3, 2, 2, 2, 459, 460, 7, 19, 2, 2, 460, 461, 5, 80, 41, 2, 461,
	462, 7, 44, 2, 2, 462, 463, 5, 72, 37, 2, 463, 464, 7, 5, 2, 2, 464, 520,
	3, 2, 2, 2, 465, 466, 7, 46, 2, 2, 466, 467, 5, 76, 39, 2, 467, 468, 7,
	47, 2, 2, 468, 476, 5, 72, 37, 2, 469, 470, 7, 48, 2, 2, 470, 471, 5, 76,
	39, 2, 471, 472, 7, 47, 2, 2, 472, 473, 5, 72, 37, 2, 473, 475, 3, 2, 2,
	2, 474, 469, 3, 2, 2, 2, 475, 478, 3, 2, 2, 2, 476, 474, 3, 2, 2, 2, 476,
	477, 3, 2, 2, 2, 477, 481, 3, 2, 2, 2, 478, 476, 3, 2, 2, 2, 479, 480,
	7, 49, 2, 2, 480, 482, 5, 72, 37, 2, 481, 479, 3, 2, 2, 2, 481, 482, 3,
	2, 2, 2, 482, 483, 3, 2, 2, 2, 483, 484, 7, 5, 2, 2, 484, 520, 3, 2, 2,
	2, 485, 486, 7, 50, 2, 2, 486, 490, 5, 76, 39, 2, 487, 489, 5, 66, 34,
	2, 488, 487, 3, 2, 2, 2, 489, 492, 3, 2, 2, 2, 490, 488, 3, 2, 2, 2, 490,
	491, 3, 2, 2, 2, 491, 496, 3, 2, 2, 2, 492, 490, 3, 2, 2, 2, 493, 494,
	7, 51, 2, 2, 494, 495, 7, 10, 2, 2, 495, 497, 5, 72, 37, 2, 496, 493, 3,
	2, 2, 2, 496, 497, 3, 2, 2, 2, 497, 498, 3, 2, 2, 2, 498, 499, 7, 5, 2,
	2, 499, 520, 3, 2, 2, 2, 500, 502, 9, 4, 2, 2, 501, 503, 5, 74, 38, 2,
	502, 501, 3, 2, 2, 2, 502, 503, 3, 2, 2, 2, 503, 520, 3, 2, 2, 2, 504,
	505, 7, 54, 2, 2, 505, 507, 5, 92, 47, 2, 506, 508, 5, 74, 38, 2, 507,
	506, 3, 2, 2, 2, 507, 508, 3, 2, 2, 2, 508, 520, 3, 2, 2, 2, 509, 510,
	7, 55, 2, 2, 510, 512, 5, 92, 47, 2, 511, 513, 5, 74, 38, 2, 512, 511,
	3, 2, 2, 2, 512, 513, 3, 2, 2, 2, 513, 520, 3, 2, 2, 2, 514, 520, 7, 56,
	2, 2, 515, 516, 7, 57, 2, 2, 516, 517, 5, 72, 37, 2, 517, 518, 7, 5, 2,
	2, 518, 520, 3, 2, 2, 2, 519, 423, 3, 2, 2, 2, 519, 425, 3, 2, 2, 2, 519,
	431, 3, 2, 2, 2, 519, 435, 3, 2, 2, 2, 519, 441, 3, 2, 2, 2, 519, 447,
	3, 2, 2, 2, 519, 448, 3, 2, 2, 2, 519, 454, 3, 2, 2, 2, 519, 465, 3, 2,
	2, 2, 519, 485, 3, 2, 2, 2, 519, 500, 3, 2, 2, 2, 519, 504, 3, 2, 2, 2,
	519, 509, 3, 2, 2, 2, 519, 514, 3, 2, 2, 2, 519, 515, 3, 2, 2, 2, 520,
	539, 3, 2, 2, 2, 521, 535, 12, 3, 2, 2, 522, 523, 7, 58, 2, 2, 523, 536,
	5, 90, 46, 2, 524, 528, 7, 59, 2, 2, 525, 527, 5, 68, 35, 2, 526, 525,
	3, 2, 2, 2, 527, 530, 3, 2, 2, 2, 528, 526, 3, 2, 2, 2, 528, 529, 3, 2,
	2, 2, 529, 532, 3, 2, 2, 2, 530, 528, 3, 2, 2, 2, 531, 533, 5, 70, 36,
	2, 532, 531, 3, 2, 2, 2, 532, 533, 3, 2, 2, 2, 533, 534, 3, 2, 2, 2, 534,
	536, 7, 5, 2, 2, 535, 522, 3, 2, 2, 2, 535, 524, 3, 2, 2, 2, 536, 538,
	3, 2, 2, 2, 537, 521, 3, 2, 2, 2, 538, 541, 3, 2, 2, 2, 539, 537, 3, 2,
	2, 2, 539, 540, 3, 2, 2, 2, 540, 65, 3, 2, 2, 2, 541, 539, 3, 2, 2, 2,
	542, 543, 7, 60, 2, 2, 543, 550, 5, 90, 46, 2, 544, 545, 7, 12, 2, 2, 545,
	546, 5, 88, 45, 2, 546, 547, 7, 10, 2, 2, 547, 548, 5, 58, 30, 2, 548,
	549, 7, 13, 2, 2, 549, 551, 3, 2, 2, 2, 550, 544, 3, 2, 2, 2, 550, 551,
	3, 2, 2, 2, 551, 552, 3, 2, 2, 2, 552, 553, 7, 10, 2, 2, 553, 554, 5, 72,
	37, 2, 554, 67, 3, 2, 2, 2, 555, 556, 7, 61, 2, 2, 556, 563, 5, 90, 46,
	2, 557, 558, 7, 12, 2, 2, 558, 559, 7, 62, 2, 2, 559, 564, 7, 13, 2, 2,
	560, 562, 5, 16, 9, 2, 561, 560, 3, 2, 2, 2, 561, 562, 3, 2, 2, 2, 562,
	564, 3, 2, 2, 2, 563, 557, 3, 2, 2, 2, 563, 561, 3, 2, 2, 2, 564, 565,
	3, 2, 2, 2, 565, 566, 7, 10, 2, 2, 566, 567, 5, 72, 37, 2, 567, 69, 3,
	2, 2, 2, 568, 575, 7, 51, 2, 2, 569, 570, 7, 12, 2, 2, 570, 571, 5, 88,
	45, 2, 571, 572, 7, 10, 2, 2, 572, 573, 5, 58, 30, 2, 573, 574, 7, 13,
	2, 2, 574, 576, 3, 2, 2, 2, 575, 569, 3, 2, 2, 2, 575, 576, 3, 2, 2, 2,
	576, 577, 3, 2, 2, 2, 577, 578, 7, 10, 2, 2, 578, 579, 5, 72, 37, 2, 579,
	71, 3, 2, 2, 2, 580, 582, 5, 54, 28, 2, 581, 580, 3, 2, 2, 2, 582, 585,
	3, 2, 2, 2, 583, 581, 3, 2, 2, 2, 583, 584, 3, 2, 2, 2, 584, 589, 3, 2,
	2, 2, 585, 583, 3, 2, 2, 2, 586, 588, 5, 64, 33, 2, 587, 586, 3, 2, 2,
	2, 588, 591, 3, 2, 2, 2, 589, 587, 3, 2, 2, 2, 589, 590, 3, 2, 2, 2, 590,
	73, 3, 2, 2, 2, 591, 589, 3, 2, 2, 2, 592, 597, 5, 76, 39, 2, 593, 594,
	7, 9, 2, 2, 594, 596, 5, 76, 39, 2, 595, 593, 3, 2, 2, 2, 596, 599, 3,
	2, 2, 2, 597, 595, 3, 2, 2, 2, 597, 598, 3, 2, 2, 2, 598, 75, 3, 2, 2,
	2, 599, 597, 3, 2, 2, 2, 600, 601, 8, 39, 1, 2, 601, 611, 5, 78, 40, 2,
	602, 603, 7, 12, 2, 2, 603, 604, 5, 76, 39, 2, 604, 605, 7, 13, 2, 2, 605,
	611, 3, 2, 2, 2, 606, 607, 7, 63, 2, 2, 607, 611, 5, 76, 39, 25, 608, 609,
	7, 64, 2, 2, 609, 611, 5, 76, 39, 24, 610, 600, 3, 2, 2, 2, 610, 602, 3,
	2, 2, 2, 610, 606, 3, 2, 2, 2, 610, 608, 3, 2, 2, 2, 611, 677, 3, 2, 2,
	2, 612, 613, 12, 23, 2, 2, 613, 614, 7, 65, 2, 2, 614, 676, 5, 76, 39,
	24, 615, 616, 12, 22, 2, 2, 616, 617, 7, 66, 2, 2, 617, 676, 5, 76, 39,
	23, 618, 619, 12, 21, 2, 2, 619, 620, 7, 67, 2, 2, 620, 676, 5, 76, 39,
	22, 621, 622, 12, 20, 2, 2, 622, 623, 7, 62, 2, 2, 623, 676, 5, 76, 39,
	21, 624, 625, 12, 19, 2, 2, 625, 626, 7, 68, 2, 2, 626, 676, 5, 76, 39,
	20, 627, 628, 12, 18, 2, 2, 628, 629, 7, 69, 2, 2, 629, 676, 5, 76, 39,
	19, 630, 631, 12, 17, 2, 2, 631, 632, 7, 64, 2, 2, 632, 676, 5, 76, 39,
	18, 633, 634, 12, 16, 2, 2, 634, 635, 7, 70, 2, 2, 635, 676, 5, 76, 39,
	17, 636, 637, 12, 15, 2, 2, 637, 638, 7, 71, 2, 2, 638, 676, 5, 76, 39,
	16, 639, 640, 12, 14, 2, 2, 640, 641, 7, 3, 2, 2, 641, 676, 5, 76, 39,
	15, 642, 643, 12, 13, 2, 2, 643, 644, 7, 72, 2, 2, 644, 676, 5, 76, 39,
	14, 645, 646, 12, 12, 2, 2, 646, 647, 7, 73, 2, 2, 647, 676, 5, 76, 39,
	13, 648, 649, 12, 11, 2, 2, 649, 650, 7, 74, 2, 2, 650, 676, 5, 76, 39,
	12, 651, 652, 12, 10, 2, 2, 652, 653, 7, 75, 2, 2, 653, 676, 5, 76, 39,
	11, 654, 655, 12, 9, 2, 2, 655, 656, 7, 76, 2, 2, 656, 676, 5, 76, 39,
	10, 657, 658, 12, 8, 2, 2, 658, 659, 7, 77, 2, 2, 659, 676, 5, 76, 39,
	9, 660, 661, 12, 7, 2, 2, 661, 662, 7, 78, 2, 2, 662, 676, 5, 76, 39, 8,
	663, 664, 12, 6, 2, 2, 664, 665, 7, 79, 2, 2, 665, 676, 5, 76, 39, 7, 666,
	667, 12, 5, 2, 2, 667, 668, 7, 80, 2, 2, 668, 676, 5, 76, 39, 6, 669, 670,
	12, 4, 2, 2, 670, 671, 7, 81, 2, 2, 671, 676, 5, 76, 39, 5, 672, 673, 12,
	3, 2, 2, 673, 674, 7, 82, 2, 2, 674, 676, 5, 76, 39, 4, 675, 612, 3, 2,
	2, 2, 675, 615, 3, 2, 2, 2, 675, 618, 3, 2, 2, 2, 675, 621, 3, 2, 2, 2,
	675, 624, 3, 2, 2, 2, 675, 627, 3, 2, 2, 2, 675, 630, 3, 2, 2, 2, 675,
	633, 3, 2, 2, 2, 675, 636, 3, 2, 2, 2, 675, 639, 3, 2, 2, 2, 675, 642,
	3, 2, 2, 2, 675, 645, 3, 2, 2, 2, 675, 648, 3, 2, 2, 2, 675, 651, 3, 2,
	2, 2, 675, 654, 3, 2, 2, 2, 675, 657, 3, 2, 2, 2, 675, 660, 3, 2, 2, 2,
	675, 663, 3, 2, 2, 2, 675, 666, 3, 2, 2, 2, 675, 669, 3, 2, 2, 2, 675,
	672, 3, 2, 2, 2, 676, 679, 3, 2, 2, 2, 677, 675, 3, 2, 2, 2, 677, 678,
	3, 2, 2, 2, 678, 77, 3, 2, 2, 2, 679, 677, 3, 2, 2, 2, 680, 681, 8, 40,
	1, 2, 681, 718, 7, 83, 2, 2, 682, 718, 7, 84, 2, 2, 683, 718, 7, 85, 2,
	2, 684, 718, 5, 94, 48, 2, 685, 718, 5, 96, 49, 2, 686, 718, 5, 98, 50,
	2, 687, 689, 5, 88, 45, 2, 688, 690, 5, 44, 23, 2, 689, 688, 3, 2, 2, 2,
	689, 690, 3, 2, 2, 2, 690, 718, 3, 2, 2, 2, 691, 692, 5, 58, 30, 2, 692,
	706, 7, 86, 2, 2, 693, 707, 5, 82, 42, 2, 694, 702, 7, 20, 2, 2, 695, 696,
	5, 76, 39, 2, 696, 697, 7, 10, 2, 2, 697, 699, 3, 2, 2, 2, 698, 695, 3,
	2, 2, 2, 698, 699, 3, 2, 2, 2, 699, 700, 3, 2, 2, 2, 700, 703, 5, 74, 38,
	2, 701, 703, 5, 44, 23, 2, 702, 698, 3, 2, 2, 2, 702, 701, 3, 2, 2, 2,
	703, 704, 3, 2, 2, 2, 704, 705, 7, 21, 2, 2, 705, 707, 3, 2, 2, 2, 706,
	693, 3, 2, 2, 2, 706, 694, 3, 2, 2, 2, 707, 718, 3, 2, 2, 2, 708, 710,
	7, 87, 2, 2, 709, 711, 5, 58, 30, 2, 710, 709, 3, 2, 2, 2, 710, 711, 3,
	2, 2, 2, 711, 718, 3, 2, 2, 2, 712, 713, 9, 5, 2, 2, 713, 714, 7, 12, 2,
	2, 714, 715, 5, 76, 39, 2, 715, 716, 7, 13, 2, 2, 716, 718, 3, 2, 2, 2,
	717, 680, 3, 2, 2, 2, 717, 682, 3, 2, 2, 2, 717, 683, 3, 2, 2, 2, 717,
	684, 3, 2, 2, 2, 717, 685, 3, 2, 2, 2, 717, 686, 3, 2, 2, 2, 717, 687,
	3, 2, 2, 2, 717, 691, 3, 2, 2, 2, 717, 708, 3, 2, 2, 2, 717, 712, 3, 2,
	2, 2, 718, 731, 3, 2, 2, 2, 719, 720, 12, 8, 2, 2, 720, 721, 7, 42, 2,
	2, 721, 730, 5, 92, 47, 2, 722, 723, 12, 7, 2, 2, 723, 730, 5, 76, 39,
	2, 724, 725, 12, 6, 2, 2, 725, 726, 7, 12, 2, 2, 726, 727, 5, 74, 38, 2,
	727, 728, 7, 13, 2, 2, 728, 730, 3, 2, 2, 2, 729, 719, 3, 2, 2, 2, 729,
	722, 3, 2, 2, 2, 729, 724, 3, 2, 2, 2, 730, 733, 3, 2, 2, 2, 731, 729,
	3, 2, 2, 2, 731, 732, 3, 2, 2, 2, 732, 79, 3, 2, 2, 2, 733, 731, 3, 2,
	2, 2, 734, 735, 5, 78, 40, 2, 735, 736, 7, 12, 2, 2, 736, 737, 5, 74, 38,
	2, 737, 738, 7, 13, 2, 2, 738, 81, 3, 2, 2, 2, 739, 744, 5, 84, 43, 2,
	740, 741, 7, 9, 2, 2, 741, 743, 5, 84, 43, 2, 742, 740, 3, 2, 2, 2, 743,
	746, 3, 2, 2, 2, 744, 742, 3, 2, 2, 2, 744, 745, 3, 2, 2, 2, 745, 83, 3,
	2, 2, 2, 746, 744, 3, 2, 2, 2, 747, 748, 5, 90, 46, 2, 748, 749, 7, 10,
	2, 2, 749, 750, 5, 76, 39, 2, 750, 85, 3, 2, 2, 2, 751, 756, 5, 88, 45,
	2, 752, 753, 7, 9, 2, 2, 753, 755, 5, 88, 45, 2, 754, 752, 3, 2, 2, 2,
	755, 758, 3, 2, 2, 2, 756, 754, 3, 2, 2, 2, 756, 757, 3, 2, 2, 2, 757,
	87, 3, 2, 2, 2, 758, 756, 3, 2, 2, 2, 759, 760, 7, 91, 2, 2, 760, 89, 3,
	2, 2, 2, 761, 766, 5, 92, 47, 2, 762, 763, 7, 9, 2, 2, 763, 765, 5, 92,
	47, 2, 764, 762, 3, 2, 2, 2, 765, 768, 3, 2, 2, 2, 766, 764, 3, 2, 2, 2,
	766, 767, 3, 2, 2, 2, 767, 91, 3, 2, 2, 2, 768, 766, 3, 2, 2, 2, 769, 770,
	7, 91, 2, 2, 770, 93, 3, 2, 2, 2, 771, 772, 7, 92, 2, 2, 772, 95, 3, 2,
	2, 2, 773, 774, 7, 93, 2, 2, 774, 97, 3, 2, 2, 2, 775, 776, 7, 90, 2, 2,
	776, 99, 3, 2, 2, 2, 86, 103, 109, 115, 119, 122, 125, 135, 139, 142, 145,
	155, 160, 171, 178, 182, 191, 215, 222, 229, 238, 246, 255, 258, 260, 264,
	271, 283, 289, 298, 303, 308, 314, 320, 326, 335, 341, 348, 353, 359, 373,
	387, 389, 393, 397, 400, 403, 407, 409, 416, 439, 457, 476, 481, 490, 496,
	502, 507, 512, 519, 528, 532, 535, 539, 550, 561, 563, 575, 583, 589, 597,
	610, 675, 677, 689, 698, 702, 706, 710, 717, 729, 731, 744, 756, 766,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'='", "'proc'", "'end'", "'iter'", "'cluster'", "'is'", "','", "':'",
	"'type'", "'('", "')'", "'returns'", "'yields'", "'signals'", "'where'",
	"'has'", "'in'", "'['", "']'", "'rep'", "'routine'", "'own'", "':='", "'null'",
	"'bool'", "'int'", "'real'", "'char'", "'string'", "'any'", "'cvt'", "'array'",
	"'sequence'", "'record'", "'struct'", "'oneof'", "'variant'", "'proctype'",
	"'itertype'", "'.'", "'while'", "'do'", "'for'", "'if'", "'then'", "'elseif'",
	"'else'", "'tagcase'", "'others'", "'return'", "'yield'", "'signal'", "'exit'",
	"'break'", "'begin'", "'resignal'", "'except'", "'tag'", "'when'", "'*'",
	"'~'", "'-'", "'**'", "'//'", "'/'", "'||'", "'+'", "'<'", "'<='", "'>='",
	"'>'", "'~<'", "'~<='", "'~='", "'~>='", "'~>'", "'&'", "'cand'", "'|'",
	"'cor'", "'nil'", "'true'", "'false'", "'$'", "'force'", "'up'", "'down'",
}
var symbolicNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "STRINGLITERAL",
	"STRING", "INT", "FLOAT", "COMMENT", "WS",
}

var ruleNames = []string{
	"module", "procedure", "iterator", "cluster", "parms", "param", "args",
	"decl_list", "decl", "returnz", "yields", "signals", "exception", "type_spec_list",
	"where", "restriction", "type_set", "oper_decl_list", "oper_decl", "op_name_list",
	"op_name", "constant_list", "constant", "routine_body", "cluster_body",
	"routine", "equate", "own_var", "type_spec", "field_spec_list", "field_spec",
	"statement", "tag_arm", "when_handler", "others_handler", "body", "expression_list",
	"expression", "primary", "invocation", "field_list", "field", "idn_list",
	"idn", "name_list", "name", "int_literal", "real_literal", "string_literal",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type cluParser struct {
	*antlr.BaseParser
}

func NewcluParser(input antlr.TokenStream) *cluParser {
	this := new(cluParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "clu.g4"

	return this
}

// cluParser tokens.
const (
	cluParserEOF           = antlr.TokenEOF
	cluParserT__0          = 1
	cluParserT__1          = 2
	cluParserT__2          = 3
	cluParserT__3          = 4
	cluParserT__4          = 5
	cluParserT__5          = 6
	cluParserT__6          = 7
	cluParserT__7          = 8
	cluParserT__8          = 9
	cluParserT__9          = 10
	cluParserT__10         = 11
	cluParserT__11         = 12
	cluParserT__12         = 13
	cluParserT__13         = 14
	cluParserT__14         = 15
	cluParserT__15         = 16
	cluParserT__16         = 17
	cluParserT__17         = 18
	cluParserT__18         = 19
	cluParserT__19         = 20
	cluParserT__20         = 21
	cluParserT__21         = 22
	cluParserT__22         = 23
	cluParserT__23         = 24
	cluParserT__24         = 25
	cluParserT__25         = 26
	cluParserT__26         = 27
	cluParserT__27         = 28
	cluParserT__28         = 29
	cluParserT__29         = 30
	cluParserT__30         = 31
	cluParserT__31         = 32
	cluParserT__32         = 33
	cluParserT__33         = 34
	cluParserT__34         = 35
	cluParserT__35         = 36
	cluParserT__36         = 37
	cluParserT__37         = 38
	cluParserT__38         = 39
	cluParserT__39         = 40
	cluParserT__40         = 41
	cluParserT__41         = 42
	cluParserT__42         = 43
	cluParserT__43         = 44
	cluParserT__44         = 45
	cluParserT__45         = 46
	cluParserT__46         = 47
	cluParserT__47         = 48
	cluParserT__48         = 49
	cluParserT__49         = 50
	cluParserT__50         = 51
	cluParserT__51         = 52
	cluParserT__52         = 53
	cluParserT__53         = 54
	cluParserT__54         = 55
	cluParserT__55         = 56
	cluParserT__56         = 57
	cluParserT__57         = 58
	cluParserT__58         = 59
	cluParserT__59         = 60
	cluParserT__60         = 61
	cluParserT__61         = 62
	cluParserT__62         = 63
	cluParserT__63         = 64
	cluParserT__64         = 65
	cluParserT__65         = 66
	cluParserT__66         = 67
	cluParserT__67         = 68
	cluParserT__68         = 69
	cluParserT__69         = 70
	cluParserT__70         = 71
	cluParserT__71         = 72
	cluParserT__72         = 73
	cluParserT__73         = 74
	cluParserT__74         = 75
	cluParserT__75         = 76
	cluParserT__76         = 77
	cluParserT__77         = 78
	cluParserT__78         = 79
	cluParserT__79         = 80
	cluParserT__80         = 81
	cluParserT__81         = 82
	cluParserT__82         = 83
	cluParserT__83         = 84
	cluParserT__84         = 85
	cluParserT__85         = 86
	cluParserT__86         = 87
	cluParserSTRINGLITERAL = 88
	cluParserSTRING        = 89
	cluParserINT           = 90
	cluParserFLOAT         = 91
	cluParserCOMMENT       = 92
	cluParserWS            = 93
)

// cluParser rules.
const (
	cluParserRULE_module          = 0
	cluParserRULE_procedure       = 1
	cluParserRULE_iterator        = 2
	cluParserRULE_cluster         = 3
	cluParserRULE_parms           = 4
	cluParserRULE_param           = 5
	cluParserRULE_args            = 6
	cluParserRULE_decl_list       = 7
	cluParserRULE_decl            = 8
	cluParserRULE_returnz         = 9
	cluParserRULE_yields          = 10
	cluParserRULE_signals         = 11
	cluParserRULE_exception       = 12
	cluParserRULE_type_spec_list  = 13
	cluParserRULE_where           = 14
	cluParserRULE_restriction     = 15
	cluParserRULE_type_set        = 16
	cluParserRULE_oper_decl_list  = 17
	cluParserRULE_oper_decl       = 18
	cluParserRULE_op_name_list    = 19
	cluParserRULE_op_name         = 20
	cluParserRULE_constant_list   = 21
	cluParserRULE_constant        = 22
	cluParserRULE_routine_body    = 23
	cluParserRULE_cluster_body    = 24
	cluParserRULE_routine         = 25
	cluParserRULE_equate          = 26
	cluParserRULE_own_var         = 27
	cluParserRULE_type_spec       = 28
	cluParserRULE_field_spec_list = 29
	cluParserRULE_field_spec      = 30
	cluParserRULE_statement       = 31
	cluParserRULE_tag_arm         = 32
	cluParserRULE_when_handler    = 33
	cluParserRULE_others_handler  = 34
	cluParserRULE_body            = 35
	cluParserRULE_expression_list = 36
	cluParserRULE_expression      = 37
	cluParserRULE_primary         = 38
	cluParserRULE_invocation      = 39
	cluParserRULE_field_list      = 40
	cluParserRULE_field           = 41
	cluParserRULE_idn_list        = 42
	cluParserRULE_idn             = 43
	cluParserRULE_name_list       = 44
	cluParserRULE_name            = 45
	cluParserRULE_int_literal     = 46
	cluParserRULE_real_literal    = 47
	cluParserRULE_string_literal  = 48
)

// IModuleContext is an interface to support dynamic dispatch.
type IModuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleContext differentiates from other interfaces.
	IsModuleContext()
}

type ModuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleContext() *ModuleContext {
	var p = new(ModuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_module
	return p
}

func (*ModuleContext) IsModuleContext() {}

func NewModuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleContext {
	var p = new(ModuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_module

	return p
}

func (s *ModuleContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleContext) Procedure() IProcedureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureContext)
}

func (s *ModuleContext) Iterator() IIteratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIteratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIteratorContext)
}

func (s *ModuleContext) Cluster() IClusterContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClusterContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClusterContext)
}

func (s *ModuleContext) AllEquate() []IEquateContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEquateContext)(nil)).Elem())
	var tst = make([]IEquateContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEquateContext)
		}
	}

	return tst
}

func (s *ModuleContext) Equate(i int) IEquateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEquateContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEquateContext)
}

func (s *ModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterModule(s)
	}
}

func (s *ModuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitModule(s)
	}
}

func (p *cluParser) Module() (localctx IModuleContext) {
	localctx = NewModuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, cluParserRULE_module)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(101)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(98)
				p.Equate()
			}

		}
		p.SetState(103)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext())
	}
	p.SetState(107)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(104)
			p.Procedure()
		}

	case 2:
		{
			p.SetState(105)
			p.Iterator()
		}

	case 3:
		{
			p.SetState(106)
			p.Cluster()
		}

	}

	return localctx
}

// IProcedureContext is an interface to support dynamic dispatch.
type IProcedureContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureContext differentiates from other interfaces.
	IsProcedureContext()
}

type ProcedureContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureContext() *ProcedureContext {
	var p = new(ProcedureContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_procedure
	return p
}

func (*ProcedureContext) IsProcedureContext() {}

func NewProcedureContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureContext {
	var p = new(ProcedureContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_procedure

	return p
}

func (s *ProcedureContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureContext) AllIdn() []IIdnContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdnContext)(nil)).Elem())
	var tst = make([]IIdnContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdnContext)
		}
	}

	return tst
}

func (s *ProcedureContext) Idn(i int) IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *ProcedureContext) Args() IArgsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgsContext)
}

func (s *ProcedureContext) Routine_body() IRoutine_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoutine_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRoutine_bodyContext)
}

func (s *ProcedureContext) Parms() IParmsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParmsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParmsContext)
}

func (s *ProcedureContext) Returnz() IReturnzContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnzContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnzContext)
}

func (s *ProcedureContext) Signals() ISignalsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignalsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignalsContext)
}

func (s *ProcedureContext) Where() IWhereContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereContext)
}

func (s *ProcedureContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterProcedure(s)
	}
}

func (s *ProcedureContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitProcedure(s)
	}
}

func (p *cluParser) Procedure() (localctx IProcedureContext) {
	localctx = NewProcedureContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, cluParserRULE_procedure)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(109)
		p.Idn()
	}
	{
		p.SetState(110)
		p.Match(cluParserT__0)
	}
	{
		p.SetState(111)
		p.Match(cluParserT__1)
	}
	p.SetState(113)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserSTRING {
		{
			p.SetState(112)
			p.Parms()
		}

	}
	{
		p.SetState(115)
		p.Args()
	}
	p.SetState(117)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserT__11 {
		{
			p.SetState(116)
			p.Returnz()
		}

	}
	p.SetState(120)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserT__13 {
		{
			p.SetState(119)
			p.Signals()
		}

	}
	p.SetState(123)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserT__14 {
		{
			p.SetState(122)
			p.Where()
		}

	}
	{
		p.SetState(125)
		p.Routine_body()
	}
	{
		p.SetState(126)
		p.Match(cluParserT__2)
	}
	{
		p.SetState(127)
		p.Idn()
	}

	return localctx
}

// IIteratorContext is an interface to support dynamic dispatch.
type IIteratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIteratorContext differentiates from other interfaces.
	IsIteratorContext()
}

type IteratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIteratorContext() *IteratorContext {
	var p = new(IteratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_iterator
	return p
}

func (*IteratorContext) IsIteratorContext() {}

func NewIteratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IteratorContext {
	var p = new(IteratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_iterator

	return p
}

func (s *IteratorContext) GetParser() antlr.Parser { return s.parser }

func (s *IteratorContext) AllIdn() []IIdnContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdnContext)(nil)).Elem())
	var tst = make([]IIdnContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdnContext)
		}
	}

	return tst
}

func (s *IteratorContext) Idn(i int) IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *IteratorContext) Args() IArgsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArgsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArgsContext)
}

func (s *IteratorContext) Routine_body() IRoutine_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoutine_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRoutine_bodyContext)
}

func (s *IteratorContext) Parms() IParmsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParmsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParmsContext)
}

func (s *IteratorContext) Yields() IYieldsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYieldsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYieldsContext)
}

func (s *IteratorContext) Signals() ISignalsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignalsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignalsContext)
}

func (s *IteratorContext) Where() IWhereContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereContext)
}

func (s *IteratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IteratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IteratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterIterator(s)
	}
}

func (s *IteratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitIterator(s)
	}
}

func (p *cluParser) Iterator() (localctx IIteratorContext) {
	localctx = NewIteratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, cluParserRULE_iterator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(129)
		p.Idn()
	}
	{
		p.SetState(130)
		p.Match(cluParserT__0)
	}
	{
		p.SetState(131)
		p.Match(cluParserT__3)
	}
	p.SetState(133)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserSTRING {
		{
			p.SetState(132)
			p.Parms()
		}

	}
	{
		p.SetState(135)
		p.Args()
	}
	p.SetState(137)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserT__12 {
		{
			p.SetState(136)
			p.Yields()
		}

	}
	p.SetState(140)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserT__13 {
		{
			p.SetState(139)
			p.Signals()
		}

	}
	p.SetState(143)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserT__14 {
		{
			p.SetState(142)
			p.Where()
		}

	}
	{
		p.SetState(145)
		p.Routine_body()
	}
	{
		p.SetState(146)
		p.Match(cluParserT__2)
	}
	{
		p.SetState(147)
		p.Idn()
	}

	return localctx
}

// IClusterContext is an interface to support dynamic dispatch.
type IClusterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClusterContext differentiates from other interfaces.
	IsClusterContext()
}

type ClusterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClusterContext() *ClusterContext {
	var p = new(ClusterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_cluster
	return p
}

func (*ClusterContext) IsClusterContext() {}

func NewClusterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClusterContext {
	var p = new(ClusterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_cluster

	return p
}

func (s *ClusterContext) GetParser() antlr.Parser { return s.parser }

func (s *ClusterContext) AllIdn() []IIdnContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdnContext)(nil)).Elem())
	var tst = make([]IIdnContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdnContext)
		}
	}

	return tst
}

func (s *ClusterContext) Idn(i int) IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *ClusterContext) Idn_list() IIdn_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdn_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdn_listContext)
}

func (s *ClusterContext) Cluster_body() ICluster_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICluster_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICluster_bodyContext)
}

func (s *ClusterContext) Parms() IParmsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParmsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParmsContext)
}

func (s *ClusterContext) Where() IWhereContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhereContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWhereContext)
}

func (s *ClusterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClusterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClusterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterCluster(s)
	}
}

func (s *ClusterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitCluster(s)
	}
}

func (p *cluParser) Cluster() (localctx IClusterContext) {
	localctx = NewClusterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, cluParserRULE_cluster)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(149)
		p.Idn()
	}
	{
		p.SetState(150)
		p.Match(cluParserT__0)
	}
	{
		p.SetState(151)
		p.Match(cluParserT__4)
	}
	p.SetState(153)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserSTRING {
		{
			p.SetState(152)
			p.Parms()
		}

	}
	{
		p.SetState(155)
		p.Match(cluParserT__5)
	}
	{
		p.SetState(156)
		p.Idn_list()
	}
	p.SetState(158)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserT__14 {
		{
			p.SetState(157)
			p.Where()
		}

	}
	{
		p.SetState(160)
		p.Cluster_body()
	}
	{
		p.SetState(161)
		p.Match(cluParserT__2)
	}
	{
		p.SetState(162)
		p.Idn()
	}

	return localctx
}

// IParmsContext is an interface to support dynamic dispatch.
type IParmsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParmsContext differentiates from other interfaces.
	IsParmsContext()
}

type ParmsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParmsContext() *ParmsContext {
	var p = new(ParmsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_parms
	return p
}

func (*ParmsContext) IsParmsContext() {}

func NewParmsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParmsContext {
	var p = new(ParmsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_parms

	return p
}

func (s *ParmsContext) GetParser() antlr.Parser { return s.parser }

func (s *ParmsContext) AllParam() []IParamContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParamContext)(nil)).Elem())
	var tst = make([]IParamContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParamContext)
		}
	}

	return tst
}

func (s *ParmsContext) Param(i int) IParamContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParamContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParamContext)
}

func (s *ParmsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParmsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParmsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterParms(s)
	}
}

func (s *ParmsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitParms(s)
	}
}

func (p *cluParser) Parms() (localctx IParmsContext) {
	localctx = NewParmsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, cluParserRULE_parms)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(164)
		p.Param()
	}
	p.SetState(169)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cluParserT__6 {
		{
			p.SetState(165)
			p.Match(cluParserT__6)
		}
		{
			p.SetState(166)
			p.Param()
		}

		p.SetState(171)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IParamContext is an interface to support dynamic dispatch.
type IParamContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParamContext differentiates from other interfaces.
	IsParamContext()
}

type ParamContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamContext() *ParamContext {
	var p = new(ParamContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_param
	return p
}

func (*ParamContext) IsParamContext() {}

func NewParamContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamContext {
	var p = new(ParamContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_param

	return p
}

func (s *ParamContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamContext) Idn_list() IIdn_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdn_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdn_listContext)
}

func (s *ParamContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *ParamContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParamContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterParam(s)
	}
}

func (s *ParamContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitParam(s)
	}
}

func (p *cluParser) Param() (localctx IParamContext) {
	localctx = NewParamContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, cluParserRULE_param)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(172)
		p.Idn_list()
	}
	{
		p.SetState(173)
		p.Match(cluParserT__7)
	}
	p.SetState(176)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cluParserT__8:
		{
			p.SetState(174)
			p.Match(cluParserT__8)
		}

	case cluParserT__19, cluParserT__23, cluParserT__24, cluParserT__25, cluParserT__26, cluParserT__27, cluParserT__28, cluParserT__29, cluParserT__30, cluParserT__31, cluParserT__32, cluParserT__33, cluParserT__34, cluParserT__35, cluParserT__36, cluParserT__37, cluParserT__38, cluParserSTRING:
		{
			p.SetState(175)
			p.Type_spec()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IArgsContext is an interface to support dynamic dispatch.
type IArgsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgsContext differentiates from other interfaces.
	IsArgsContext()
}

type ArgsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgsContext() *ArgsContext {
	var p = new(ArgsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_args
	return p
}

func (*ArgsContext) IsArgsContext() {}

func NewArgsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgsContext {
	var p = new(ArgsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_args

	return p
}

func (s *ArgsContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgsContext) Decl_list() IDecl_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_listContext)
}

func (s *ArgsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterArgs(s)
	}
}

func (s *ArgsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitArgs(s)
	}
}

func (p *cluParser) Args() (localctx IArgsContext) {
	localctx = NewArgsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, cluParserRULE_args)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(178)
		p.Match(cluParserT__9)
	}
	p.SetState(180)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserSTRING {
		{
			p.SetState(179)
			p.Decl_list()
		}

	}
	{
		p.SetState(182)
		p.Match(cluParserT__10)
	}

	return localctx
}

// IDecl_listContext is an interface to support dynamic dispatch.
type IDecl_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecl_listContext differentiates from other interfaces.
	IsDecl_listContext()
}

type Decl_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecl_listContext() *Decl_listContext {
	var p = new(Decl_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_decl_list
	return p
}

func (*Decl_listContext) IsDecl_listContext() {}

func NewDecl_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Decl_listContext {
	var p = new(Decl_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_decl_list

	return p
}

func (s *Decl_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Decl_listContext) AllDecl() []IDeclContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclContext)(nil)).Elem())
	var tst = make([]IDeclContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclContext)
		}
	}

	return tst
}

func (s *Decl_listContext) Decl(i int) IDeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclContext)
}

func (s *Decl_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Decl_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Decl_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterDecl_list(s)
	}
}

func (s *Decl_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitDecl_list(s)
	}
}

func (p *cluParser) Decl_list() (localctx IDecl_listContext) {
	localctx = NewDecl_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, cluParserRULE_decl_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(184)
		p.Decl()
	}
	p.SetState(189)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cluParserT__6 {
		{
			p.SetState(185)
			p.Match(cluParserT__6)
		}
		{
			p.SetState(186)
			p.Decl()
		}

		p.SetState(191)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDeclContext is an interface to support dynamic dispatch.
type IDeclContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclContext differentiates from other interfaces.
	IsDeclContext()
}

type DeclContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclContext() *DeclContext {
	var p = new(DeclContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_decl
	return p
}

func (*DeclContext) IsDeclContext() {}

func NewDeclContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclContext {
	var p = new(DeclContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_decl

	return p
}

func (s *DeclContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclContext) Idn_list() IIdn_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdn_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdn_listContext)
}

func (s *DeclContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *DeclContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterDecl(s)
	}
}

func (s *DeclContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitDecl(s)
	}
}

func (p *cluParser) Decl() (localctx IDeclContext) {
	localctx = NewDeclContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, cluParserRULE_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(192)
		p.Idn_list()
	}
	{
		p.SetState(193)
		p.Match(cluParserT__7)
	}
	{
		p.SetState(194)
		p.Type_spec()
	}

	return localctx
}

// IReturnzContext is an interface to support dynamic dispatch.
type IReturnzContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnzContext differentiates from other interfaces.
	IsReturnzContext()
}

type ReturnzContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnzContext() *ReturnzContext {
	var p = new(ReturnzContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_returnz
	return p
}

func (*ReturnzContext) IsReturnzContext() {}

func NewReturnzContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnzContext {
	var p = new(ReturnzContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_returnz

	return p
}

func (s *ReturnzContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnzContext) Type_spec_list() IType_spec_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_spec_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_spec_listContext)
}

func (s *ReturnzContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnzContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnzContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterReturnz(s)
	}
}

func (s *ReturnzContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitReturnz(s)
	}
}

func (p *cluParser) Returnz() (localctx IReturnzContext) {
	localctx = NewReturnzContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, cluParserRULE_returnz)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(196)
		p.Match(cluParserT__11)
	}
	{
		p.SetState(197)
		p.Match(cluParserT__9)
	}
	{
		p.SetState(198)
		p.Type_spec_list()
	}
	{
		p.SetState(199)
		p.Match(cluParserT__10)
	}

	return localctx
}

// IYieldsContext is an interface to support dynamic dispatch.
type IYieldsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYieldsContext differentiates from other interfaces.
	IsYieldsContext()
}

type YieldsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYieldsContext() *YieldsContext {
	var p = new(YieldsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_yields
	return p
}

func (*YieldsContext) IsYieldsContext() {}

func NewYieldsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YieldsContext {
	var p = new(YieldsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_yields

	return p
}

func (s *YieldsContext) GetParser() antlr.Parser { return s.parser }

func (s *YieldsContext) Type_spec_list() IType_spec_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_spec_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_spec_listContext)
}

func (s *YieldsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YieldsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YieldsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterYields(s)
	}
}

func (s *YieldsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitYields(s)
	}
}

func (p *cluParser) Yields() (localctx IYieldsContext) {
	localctx = NewYieldsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, cluParserRULE_yields)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(201)
		p.Match(cluParserT__12)
	}
	{
		p.SetState(202)
		p.Match(cluParserT__9)
	}
	{
		p.SetState(203)
		p.Type_spec_list()
	}
	{
		p.SetState(204)
		p.Match(cluParserT__10)
	}

	return localctx
}

// ISignalsContext is an interface to support dynamic dispatch.
type ISignalsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSignalsContext differentiates from other interfaces.
	IsSignalsContext()
}

type SignalsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignalsContext() *SignalsContext {
	var p = new(SignalsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_signals
	return p
}

func (*SignalsContext) IsSignalsContext() {}

func NewSignalsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignalsContext {
	var p = new(SignalsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_signals

	return p
}

func (s *SignalsContext) GetParser() antlr.Parser { return s.parser }

func (s *SignalsContext) AllException() []IExceptionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExceptionContext)(nil)).Elem())
	var tst = make([]IExceptionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExceptionContext)
		}
	}

	return tst
}

func (s *SignalsContext) Exception(i int) IExceptionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExceptionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExceptionContext)
}

func (s *SignalsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignalsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignalsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterSignals(s)
	}
}

func (s *SignalsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitSignals(s)
	}
}

func (p *cluParser) Signals() (localctx ISignalsContext) {
	localctx = NewSignalsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, cluParserRULE_signals)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(206)
		p.Match(cluParserT__13)
	}
	{
		p.SetState(207)
		p.Match(cluParserT__9)
	}
	{
		p.SetState(208)
		p.Exception()
	}
	p.SetState(213)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cluParserT__6 {
		{
			p.SetState(209)
			p.Match(cluParserT__6)
		}
		{
			p.SetState(210)
			p.Exception()
		}

		p.SetState(215)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(216)
		p.Match(cluParserT__10)
	}

	return localctx
}

// IExceptionContext is an interface to support dynamic dispatch.
type IExceptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExceptionContext differentiates from other interfaces.
	IsExceptionContext()
}

type ExceptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptionContext() *ExceptionContext {
	var p = new(ExceptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_exception
	return p
}

func (*ExceptionContext) IsExceptionContext() {}

func NewExceptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptionContext {
	var p = new(ExceptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_exception

	return p
}

func (s *ExceptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptionContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *ExceptionContext) Type_spec_list() IType_spec_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_spec_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_spec_listContext)
}

func (s *ExceptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExceptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterException(s)
	}
}

func (s *ExceptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitException(s)
	}
}

func (p *cluParser) Exception() (localctx IExceptionContext) {
	localctx = NewExceptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, cluParserRULE_exception)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(218)
		p.Name()
	}
	p.SetState(220)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-20)&-(0x1f+1)) == 0 && ((1<<uint((_la-20)))&((1<<(cluParserT__19-20))|(1<<(cluParserT__23-20))|(1<<(cluParserT__24-20))|(1<<(cluParserT__25-20))|(1<<(cluParserT__26-20))|(1<<(cluParserT__27-20))|(1<<(cluParserT__28-20))|(1<<(cluParserT__29-20))|(1<<(cluParserT__30-20))|(1<<(cluParserT__31-20))|(1<<(cluParserT__32-20))|(1<<(cluParserT__33-20))|(1<<(cluParserT__34-20))|(1<<(cluParserT__35-20))|(1<<(cluParserT__36-20))|(1<<(cluParserT__37-20))|(1<<(cluParserT__38-20)))) != 0) || _la == cluParserSTRING {
		{
			p.SetState(219)
			p.Type_spec_list()
		}

	}

	return localctx
}

// IType_spec_listContext is an interface to support dynamic dispatch.
type IType_spec_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_spec_listContext differentiates from other interfaces.
	IsType_spec_listContext()
}

type Type_spec_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_spec_listContext() *Type_spec_listContext {
	var p = new(Type_spec_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_type_spec_list
	return p
}

func (*Type_spec_listContext) IsType_spec_listContext() {}

func NewType_spec_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_spec_listContext {
	var p = new(Type_spec_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_type_spec_list

	return p
}

func (s *Type_spec_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_spec_listContext) AllType_spec() []IType_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IType_specContext)(nil)).Elem())
	var tst = make([]IType_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IType_specContext)
		}
	}

	return tst
}

func (s *Type_spec_listContext) Type_spec(i int) IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Type_spec_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_spec_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_spec_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterType_spec_list(s)
	}
}

func (s *Type_spec_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitType_spec_list(s)
	}
}

func (p *cluParser) Type_spec_list() (localctx IType_spec_listContext) {
	localctx = NewType_spec_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, cluParserRULE_type_spec_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(222)
		p.Type_spec()
	}
	p.SetState(227)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(223)
				p.Match(cluParserT__6)
			}
			{
				p.SetState(224)
				p.Type_spec()
			}

		}
		p.SetState(229)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext())
	}

	return localctx
}

// IWhereContext is an interface to support dynamic dispatch.
type IWhereContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhereContext differentiates from other interfaces.
	IsWhereContext()
}

type WhereContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereContext() *WhereContext {
	var p = new(WhereContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_where
	return p
}

func (*WhereContext) IsWhereContext() {}

func NewWhereContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereContext {
	var p = new(WhereContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_where

	return p
}

func (s *WhereContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereContext) AllRestriction() []IRestrictionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRestrictionContext)(nil)).Elem())
	var tst = make([]IRestrictionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRestrictionContext)
		}
	}

	return tst
}

func (s *WhereContext) Restriction(i int) IRestrictionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRestrictionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRestrictionContext)
}

func (s *WhereContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterWhere(s)
	}
}

func (s *WhereContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitWhere(s)
	}
}

func (p *cluParser) Where() (localctx IWhereContext) {
	localctx = NewWhereContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, cluParserRULE_where)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(230)
		p.Match(cluParserT__14)
	}
	{
		p.SetState(231)
		p.Restriction()
	}
	p.SetState(236)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cluParserT__6 {
		{
			p.SetState(232)
			p.Match(cluParserT__6)
		}
		{
			p.SetState(233)
			p.Restriction()
		}

		p.SetState(238)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRestrictionContext is an interface to support dynamic dispatch.
type IRestrictionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRestrictionContext differentiates from other interfaces.
	IsRestrictionContext()
}

type RestrictionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRestrictionContext() *RestrictionContext {
	var p = new(RestrictionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_restriction
	return p
}

func (*RestrictionContext) IsRestrictionContext() {}

func NewRestrictionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RestrictionContext {
	var p = new(RestrictionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_restriction

	return p
}

func (s *RestrictionContext) GetParser() antlr.Parser { return s.parser }

func (s *RestrictionContext) Idn() IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *RestrictionContext) Oper_decl_list() IOper_decl_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOper_decl_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOper_decl_listContext)
}

func (s *RestrictionContext) Type_set() IType_setContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_setContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_setContext)
}

func (s *RestrictionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RestrictionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RestrictionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterRestriction(s)
	}
}

func (s *RestrictionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitRestriction(s)
	}
}

func (p *cluParser) Restriction() (localctx IRestrictionContext) {
	localctx = NewRestrictionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, cluParserRULE_restriction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(239)
		p.Idn()
	}
	p.SetState(244)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cluParserT__15:
		{
			p.SetState(240)
			p.Match(cluParserT__15)
		}
		{
			p.SetState(241)
			p.Oper_decl_list()
		}

	case cluParserT__16:
		{
			p.SetState(242)
			p.Match(cluParserT__16)
		}
		{
			p.SetState(243)
			p.Type_set()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IType_setContext is an interface to support dynamic dispatch.
type IType_setContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_setContext differentiates from other interfaces.
	IsType_setContext()
}

type Type_setContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_setContext() *Type_setContext {
	var p = new(Type_setContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_type_set
	return p
}

func (*Type_setContext) IsType_setContext() {}

func NewType_setContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_setContext {
	var p = new(Type_setContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_type_set

	return p
}

func (s *Type_setContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_setContext) AllIdn() []IIdnContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdnContext)(nil)).Elem())
	var tst = make([]IIdnContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdnContext)
		}
	}

	return tst
}

func (s *Type_setContext) Idn(i int) IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *Type_setContext) AllOper_decl_list() []IOper_decl_listContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOper_decl_listContext)(nil)).Elem())
	var tst = make([]IOper_decl_listContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOper_decl_listContext)
		}
	}

	return tst
}

func (s *Type_setContext) Oper_decl_list(i int) IOper_decl_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOper_decl_listContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOper_decl_listContext)
}

func (s *Type_setContext) AllEquate() []IEquateContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEquateContext)(nil)).Elem())
	var tst = make([]IEquateContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEquateContext)
		}
	}

	return tst
}

func (s *Type_setContext) Equate(i int) IEquateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEquateContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEquateContext)
}

func (s *Type_setContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_setContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_setContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterType_set(s)
	}
}

func (s *Type_setContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitType_set(s)
	}
}

func (p *cluParser) Type_set() (localctx IType_setContext) {
	localctx = NewType_setContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, cluParserRULE_type_set)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(262)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(258)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				p.SetState(256)
				p.GetErrorHandler().Sync(p)
				switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 22, p.GetParserRuleContext()) {
				case 1:
					{
						p.SetState(246)
						p.Idn()
					}

				case 2:
					{
						p.SetState(247)
						p.Idn()
					}
					{
						p.SetState(248)
						p.Match(cluParserT__15)
					}
					{
						p.SetState(249)
						p.Oper_decl_list()
					}
					p.SetState(253)
					p.GetErrorHandler().Sync(p)
					_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())

					for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
						if _alt == 1 {
							{
								p.SetState(250)
								p.Equate()
							}

						}
						p.SetState(255)
						p.GetErrorHandler().Sync(p)
						_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())
					}

				}

			}
			p.SetState(260)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 23, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(261)
			p.Idn()
		}

	}

	return localctx
}

// IOper_decl_listContext is an interface to support dynamic dispatch.
type IOper_decl_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOper_decl_listContext differentiates from other interfaces.
	IsOper_decl_listContext()
}

type Oper_decl_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOper_decl_listContext() *Oper_decl_listContext {
	var p = new(Oper_decl_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_oper_decl_list
	return p
}

func (*Oper_decl_listContext) IsOper_decl_listContext() {}

func NewOper_decl_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Oper_decl_listContext {
	var p = new(Oper_decl_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_oper_decl_list

	return p
}

func (s *Oper_decl_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Oper_decl_listContext) AllOper_decl() []IOper_declContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOper_declContext)(nil)).Elem())
	var tst = make([]IOper_declContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOper_declContext)
		}
	}

	return tst
}

func (s *Oper_decl_listContext) Oper_decl(i int) IOper_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOper_declContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOper_declContext)
}

func (s *Oper_decl_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Oper_decl_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Oper_decl_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterOper_decl_list(s)
	}
}

func (s *Oper_decl_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitOper_decl_list(s)
	}
}

func (p *cluParser) Oper_decl_list() (localctx IOper_decl_listContext) {
	localctx = NewOper_decl_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, cluParserRULE_oper_decl_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(264)
		p.Oper_decl()
	}
	p.SetState(269)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(265)
				p.Match(cluParserT__6)
			}
			{
				p.SetState(266)
				p.Oper_decl()
			}

		}
		p.SetState(271)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 25, p.GetParserRuleContext())
	}

	return localctx
}

// IOper_declContext is an interface to support dynamic dispatch.
type IOper_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOper_declContext differentiates from other interfaces.
	IsOper_declContext()
}

type Oper_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOper_declContext() *Oper_declContext {
	var p = new(Oper_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_oper_decl
	return p
}

func (*Oper_declContext) IsOper_declContext() {}

func NewOper_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Oper_declContext {
	var p = new(Oper_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_oper_decl

	return p
}

func (s *Oper_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Oper_declContext) Op_name_list() IOp_name_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOp_name_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOp_name_listContext)
}

func (s *Oper_declContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Oper_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Oper_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Oper_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterOper_decl(s)
	}
}

func (s *Oper_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitOper_decl(s)
	}
}

func (p *cluParser) Oper_decl() (localctx IOper_declContext) {
	localctx = NewOper_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, cluParserRULE_oper_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(272)
		p.Op_name_list()
	}
	{
		p.SetState(273)
		p.Match(cluParserT__7)
	}
	{
		p.SetState(274)
		p.Type_spec()
	}

	return localctx
}

// IOp_name_listContext is an interface to support dynamic dispatch.
type IOp_name_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOp_name_listContext differentiates from other interfaces.
	IsOp_name_listContext()
}

type Op_name_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOp_name_listContext() *Op_name_listContext {
	var p = new(Op_name_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_op_name_list
	return p
}

func (*Op_name_listContext) IsOp_name_listContext() {}

func NewOp_name_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Op_name_listContext {
	var p = new(Op_name_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_op_name_list

	return p
}

func (s *Op_name_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Op_name_listContext) AllOp_name() []IOp_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOp_nameContext)(nil)).Elem())
	var tst = make([]IOp_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOp_nameContext)
		}
	}

	return tst
}

func (s *Op_name_listContext) Op_name(i int) IOp_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOp_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOp_nameContext)
}

func (s *Op_name_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Op_name_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Op_name_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterOp_name_list(s)
	}
}

func (s *Op_name_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitOp_name_list(s)
	}
}

func (p *cluParser) Op_name_list() (localctx IOp_name_listContext) {
	localctx = NewOp_name_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, cluParserRULE_op_name_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(276)
		p.Op_name()
	}
	p.SetState(281)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cluParserT__6 {
		{
			p.SetState(277)
			p.Match(cluParserT__6)
		}
		{
			p.SetState(278)
			p.Op_name()
		}

		p.SetState(283)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOp_nameContext is an interface to support dynamic dispatch.
type IOp_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOp_nameContext differentiates from other interfaces.
	IsOp_nameContext()
}

type Op_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOp_nameContext() *Op_nameContext {
	var p = new(Op_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_op_name
	return p
}

func (*Op_nameContext) IsOp_nameContext() {}

func NewOp_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Op_nameContext {
	var p = new(Op_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_op_name

	return p
}

func (s *Op_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Op_nameContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Op_nameContext) Constant_list() IConstant_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_listContext)
}

func (s *Op_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Op_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Op_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterOp_name(s)
	}
}

func (s *Op_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitOp_name(s)
	}
}

func (p *cluParser) Op_name() (localctx IOp_nameContext) {
	localctx = NewOp_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, cluParserRULE_op_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(284)
		p.Name()
	}
	{
		p.SetState(285)
		p.Match(cluParserT__17)
	}
	p.SetState(287)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la-10)&-(0x1f+1)) == 0 && ((1<<uint((_la-10)))&((1<<(cluParserT__9-10))|(1<<(cluParserT__19-10))|(1<<(cluParserT__23-10))|(1<<(cluParserT__24-10))|(1<<(cluParserT__25-10))|(1<<(cluParserT__26-10))|(1<<(cluParserT__27-10))|(1<<(cluParserT__28-10))|(1<<(cluParserT__29-10))|(1<<(cluParserT__30-10))|(1<<(cluParserT__31-10))|(1<<(cluParserT__32-10))|(1<<(cluParserT__33-10))|(1<<(cluParserT__34-10))|(1<<(cluParserT__35-10))|(1<<(cluParserT__36-10))|(1<<(cluParserT__37-10))|(1<<(cluParserT__38-10)))) != 0) || (((_la-61)&-(0x1f+1)) == 0 && ((1<<uint((_la-61)))&((1<<(cluParserT__60-61))|(1<<(cluParserT__61-61))|(1<<(cluParserT__80-61))|(1<<(cluParserT__81-61))|(1<<(cluParserT__82-61))|(1<<(cluParserT__84-61))|(1<<(cluParserT__85-61))|(1<<(cluParserT__86-61))|(1<<(cluParserSTRINGLITERAL-61))|(1<<(cluParserSTRING-61))|(1<<(cluParserINT-61))|(1<<(cluParserFLOAT-61)))) != 0) {
		{
			p.SetState(286)
			p.Constant_list()
		}

	}
	{
		p.SetState(289)
		p.Match(cluParserT__18)
	}

	return localctx
}

// IConstant_listContext is an interface to support dynamic dispatch.
type IConstant_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_listContext differentiates from other interfaces.
	IsConstant_listContext()
}

type Constant_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_listContext() *Constant_listContext {
	var p = new(Constant_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_constant_list
	return p
}

func (*Constant_listContext) IsConstant_listContext() {}

func NewConstant_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_listContext {
	var p = new(Constant_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_constant_list

	return p
}

func (s *Constant_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_listContext) AllConstant() []IConstantContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstantContext)(nil)).Elem())
	var tst = make([]IConstantContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstantContext)
		}
	}

	return tst
}

func (s *Constant_listContext) Constant(i int) IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *Constant_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterConstant_list(s)
	}
}

func (s *Constant_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitConstant_list(s)
	}
}

func (p *cluParser) Constant_list() (localctx IConstant_listContext) {
	localctx = NewConstant_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, cluParserRULE_constant_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(291)
		p.Constant()
	}
	p.SetState(296)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(292)
				p.Match(cluParserT__6)
			}
			{
				p.SetState(293)
				p.Constant()
			}

		}
		p.SetState(298)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())
	}

	return localctx
}

// IConstantContext is an interface to support dynamic dispatch.
type IConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstantContext differentiates from other interfaces.
	IsConstantContext()
}

type ConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstantContext() *ConstantContext {
	var p = new(ConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_constant
	return p
}

func (*ConstantContext) IsConstantContext() {}

func NewConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstantContext {
	var p = new(ConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_constant

	return p
}

func (s *ConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstantContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConstantContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *ConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterConstant(s)
	}
}

func (s *ConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitConstant(s)
	}
}

func (p *cluParser) Constant() (localctx IConstantContext) {
	localctx = NewConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, cluParserRULE_constant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(301)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(299)
			p.expression(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(300)
			p.Type_spec()
		}

	}

	return localctx
}

// IRoutine_bodyContext is an interface to support dynamic dispatch.
type IRoutine_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRoutine_bodyContext differentiates from other interfaces.
	IsRoutine_bodyContext()
}

type Routine_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutine_bodyContext() *Routine_bodyContext {
	var p = new(Routine_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_routine_body
	return p
}

func (*Routine_bodyContext) IsRoutine_bodyContext() {}

func NewRoutine_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Routine_bodyContext {
	var p = new(Routine_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_routine_body

	return p
}

func (s *Routine_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Routine_bodyContext) AllEquate() []IEquateContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEquateContext)(nil)).Elem())
	var tst = make([]IEquateContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEquateContext)
		}
	}

	return tst
}

func (s *Routine_bodyContext) Equate(i int) IEquateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEquateContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEquateContext)
}

func (s *Routine_bodyContext) AllOwn_var() []IOwn_varContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOwn_varContext)(nil)).Elem())
	var tst = make([]IOwn_varContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOwn_varContext)
		}
	}

	return tst
}

func (s *Routine_bodyContext) Own_var(i int) IOwn_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOwn_varContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOwn_varContext)
}

func (s *Routine_bodyContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Routine_bodyContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Routine_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Routine_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Routine_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterRoutine_body(s)
	}
}

func (s *Routine_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitRoutine_body(s)
	}
}

func (p *cluParser) Routine_body() (localctx IRoutine_bodyContext) {
	localctx = NewRoutine_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, cluParserRULE_routine_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(306)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(303)
				p.Equate()
			}

		}
		p.SetState(308)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext())
	}
	p.SetState(312)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cluParserT__21 {
		{
			p.SetState(309)
			p.Own_var()
		}

		p.SetState(314)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(318)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<cluParserT__19)|(1<<cluParserT__23)|(1<<cluParserT__24)|(1<<cluParserT__25)|(1<<cluParserT__26)|(1<<cluParserT__27)|(1<<cluParserT__28)|(1<<cluParserT__29)|(1<<cluParserT__30))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(cluParserT__31-32))|(1<<(cluParserT__32-32))|(1<<(cluParserT__33-32))|(1<<(cluParserT__34-32))|(1<<(cluParserT__35-32))|(1<<(cluParserT__36-32))|(1<<(cluParserT__37-32))|(1<<(cluParserT__38-32))|(1<<(cluParserT__40-32))|(1<<(cluParserT__42-32))|(1<<(cluParserT__43-32))|(1<<(cluParserT__47-32))|(1<<(cluParserT__49-32))|(1<<(cluParserT__50-32))|(1<<(cluParserT__51-32))|(1<<(cluParserT__52-32))|(1<<(cluParserT__53-32))|(1<<(cluParserT__54-32)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(cluParserT__80-81))|(1<<(cluParserT__81-81))|(1<<(cluParserT__82-81))|(1<<(cluParserT__84-81))|(1<<(cluParserT__85-81))|(1<<(cluParserT__86-81))|(1<<(cluParserSTRINGLITERAL-81))|(1<<(cluParserSTRING-81))|(1<<(cluParserINT-81))|(1<<(cluParserFLOAT-81)))) != 0) {
		{
			p.SetState(315)
			p.statement(0)
		}

		p.SetState(320)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICluster_bodyContext is an interface to support dynamic dispatch.
type ICluster_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCluster_bodyContext differentiates from other interfaces.
	IsCluster_bodyContext()
}

type Cluster_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCluster_bodyContext() *Cluster_bodyContext {
	var p = new(Cluster_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_cluster_body
	return p
}

func (*Cluster_bodyContext) IsCluster_bodyContext() {}

func NewCluster_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cluster_bodyContext {
	var p = new(Cluster_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_cluster_body

	return p
}

func (s *Cluster_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Cluster_bodyContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Cluster_bodyContext) AllEquate() []IEquateContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEquateContext)(nil)).Elem())
	var tst = make([]IEquateContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEquateContext)
		}
	}

	return tst
}

func (s *Cluster_bodyContext) Equate(i int) IEquateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEquateContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEquateContext)
}

func (s *Cluster_bodyContext) AllOwn_var() []IOwn_varContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IOwn_varContext)(nil)).Elem())
	var tst = make([]IOwn_varContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IOwn_varContext)
		}
	}

	return tst
}

func (s *Cluster_bodyContext) Own_var(i int) IOwn_varContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOwn_varContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IOwn_varContext)
}

func (s *Cluster_bodyContext) AllRoutine() []IRoutineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IRoutineContext)(nil)).Elem())
	var tst = make([]IRoutineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IRoutineContext)
		}
	}

	return tst
}

func (s *Cluster_bodyContext) Routine(i int) IRoutineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRoutineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IRoutineContext)
}

func (s *Cluster_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cluster_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cluster_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterCluster_body(s)
	}
}

func (s *Cluster_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitCluster_body(s)
	}
}

func (p *cluParser) Cluster_body() (localctx ICluster_bodyContext) {
	localctx = NewCluster_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, cluParserRULE_cluster_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(324)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cluParserSTRING {
		{
			p.SetState(321)
			p.Equate()
		}

		p.SetState(326)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(327)
		p.Match(cluParserT__19)
	}
	{
		p.SetState(328)
		p.Match(cluParserT__0)
	}
	{
		p.SetState(329)
		p.Type_spec()
	}
	p.SetState(333)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cluParserSTRING {
		{
			p.SetState(330)
			p.Equate()
		}

		p.SetState(335)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(339)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cluParserT__21 {
		{
			p.SetState(336)
			p.Own_var()
		}

		p.SetState(341)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(342)
		p.Match(cluParserT__20)
	}
	p.SetState(346)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cluParserSTRING {
		{
			p.SetState(343)
			p.Routine()
		}

		p.SetState(348)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRoutineContext is an interface to support dynamic dispatch.
type IRoutineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRoutineContext differentiates from other interfaces.
	IsRoutineContext()
}

type RoutineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineContext() *RoutineContext {
	var p = new(RoutineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_routine
	return p
}

func (*RoutineContext) IsRoutineContext() {}

func NewRoutineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineContext {
	var p = new(RoutineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_routine

	return p
}

func (s *RoutineContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineContext) Procedure() IProcedureContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProcedureContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProcedureContext)
}

func (s *RoutineContext) Iterator() IIteratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIteratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIteratorContext)
}

func (s *RoutineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterRoutine(s)
	}
}

func (s *RoutineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitRoutine(s)
	}
}

func (p *cluParser) Routine() (localctx IRoutineContext) {
	localctx = NewRoutineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, cluParserRULE_routine)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(351)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(349)
			p.Procedure()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(350)
			p.Iterator()
		}

	}

	return localctx
}

// IEquateContext is an interface to support dynamic dispatch.
type IEquateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEquateContext differentiates from other interfaces.
	IsEquateContext()
}

type EquateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEquateContext() *EquateContext {
	var p = new(EquateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_equate
	return p
}

func (*EquateContext) IsEquateContext() {}

func NewEquateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EquateContext {
	var p = new(EquateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_equate

	return p
}

func (s *EquateContext) GetParser() antlr.Parser { return s.parser }

func (s *EquateContext) Idn() IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *EquateContext) Constant() IConstantContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstantContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstantContext)
}

func (s *EquateContext) Type_set() IType_setContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_setContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_setContext)
}

func (s *EquateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EquateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EquateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterEquate(s)
	}
}

func (s *EquateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitEquate(s)
	}
}

func (p *cluParser) Equate() (localctx IEquateContext) {
	localctx = NewEquateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, cluParserRULE_equate)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(353)
		p.Idn()
	}
	{
		p.SetState(354)
		p.Match(cluParserT__0)
	}
	p.SetState(357)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(355)
			p.Constant()
		}

	case 2:
		{
			p.SetState(356)
			p.Type_set()
		}

	}

	return localctx
}

// IOwn_varContext is an interface to support dynamic dispatch.
type IOwn_varContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOwn_varContext differentiates from other interfaces.
	IsOwn_varContext()
}

type Own_varContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOwn_varContext() *Own_varContext {
	var p = new(Own_varContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_own_var
	return p
}

func (*Own_varContext) IsOwn_varContext() {}

func NewOwn_varContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Own_varContext {
	var p = new(Own_varContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_own_var

	return p
}

func (s *Own_varContext) GetParser() antlr.Parser { return s.parser }

func (s *Own_varContext) Decl() IDeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclContext)
}

func (s *Own_varContext) Idn() IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *Own_varContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Own_varContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Own_varContext) Decl_list() IDecl_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_listContext)
}

func (s *Own_varContext) Invocation() IInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInvocationContext)
}

func (s *Own_varContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Own_varContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Own_varContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterOwn_var(s)
	}
}

func (s *Own_varContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitOwn_var(s)
	}
}

func (p *cluParser) Own_var() (localctx IOwn_varContext) {
	localctx = NewOwn_varContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, cluParserRULE_own_var)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(359)
		p.Match(cluParserT__21)
	}
	p.SetState(371)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(360)
			p.Decl()
		}

	case 2:
		{
			p.SetState(361)
			p.Idn()
		}
		{
			p.SetState(362)
			p.Match(cluParserT__7)
		}
		{
			p.SetState(363)
			p.Type_spec()
		}
		{
			p.SetState(364)
			p.Match(cluParserT__22)
		}
		{
			p.SetState(365)
			p.expression(0)
		}

	case 3:
		{
			p.SetState(367)
			p.Decl_list()
		}
		{
			p.SetState(368)
			p.Match(cluParserT__22)
		}
		{
			p.SetState(369)
			p.Invocation()
		}

	}

	return localctx
}

// IType_specContext is an interface to support dynamic dispatch.
type IType_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_specContext differentiates from other interfaces.
	IsType_specContext()
}

type Type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_specContext() *Type_specContext {
	var p = new(Type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_type_spec
	return p
}

func (*Type_specContext) IsType_specContext() {}

func NewType_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_specContext {
	var p = new(Type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_type_spec

	return p
}

func (s *Type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_specContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Type_specContext) Field_spec_list() IField_spec_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IField_spec_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IField_spec_listContext)
}

func (s *Type_specContext) Returnz() IReturnzContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturnzContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturnzContext)
}

func (s *Type_specContext) Signals() ISignalsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISignalsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISignalsContext)
}

func (s *Type_specContext) Idn() IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *Type_specContext) Constant_list() IConstant_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_listContext)
}

func (s *Type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterType_spec(s)
	}
}

func (s *Type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitType_spec(s)
	}
}

func (p *cluParser) Type_spec() (localctx IType_specContext) {
	localctx = NewType_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, cluParserRULE_type_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(407)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cluParserT__23:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(373)
			p.Match(cluParserT__23)
		}

	case cluParserT__24:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(374)
			p.Match(cluParserT__24)
		}

	case cluParserT__25:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(375)
			p.Match(cluParserT__25)
		}

	case cluParserT__26:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(376)
			p.Match(cluParserT__26)
		}

	case cluParserT__27:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(377)
			p.Match(cluParserT__27)
		}

	case cluParserT__28:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(378)
			p.Match(cluParserT__28)
		}

	case cluParserT__29:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(379)
			p.Match(cluParserT__29)
		}

	case cluParserT__19:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(380)
			p.Match(cluParserT__19)
		}

	case cluParserT__30:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(381)
			p.Match(cluParserT__30)
		}

	case cluParserT__31, cluParserT__32:
		p.EnterOuterAlt(localctx, 10)
		p.SetState(387)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case cluParserT__31:
			{
				p.SetState(382)
				p.Match(cluParserT__31)
			}

		case cluParserT__32:
			{
				p.SetState(383)
				p.Match(cluParserT__32)
			}
			p.SetState(385)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(384)
					p.Type_spec()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case cluParserT__33, cluParserT__34, cluParserT__35, cluParserT__36:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(389)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-34)&-(0x1f+1)) == 0 && ((1<<uint((_la-34)))&((1<<(cluParserT__33-34))|(1<<(cluParserT__34-34))|(1<<(cluParserT__35-34))|(1<<(cluParserT__36-34)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(391)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(390)
				p.Field_spec_list()
			}

		}

	case cluParserT__37, cluParserT__38:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(393)
			_la = p.GetTokenStream().LA(1)

			if !(_la == cluParserT__37 || _la == cluParserT__38) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(395)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(394)
				p.Field_spec_list()
			}

		}
		p.SetState(398)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(397)
				p.Returnz()
			}

		}
		p.SetState(401)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(400)
				p.Signals()
			}

		}

	case cluParserSTRING:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(403)
			p.Idn()
		}
		p.SetState(405)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(404)
				p.Constant_list()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IField_spec_listContext is an interface to support dynamic dispatch.
type IField_spec_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsField_spec_listContext differentiates from other interfaces.
	IsField_spec_listContext()
}

type Field_spec_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyField_spec_listContext() *Field_spec_listContext {
	var p = new(Field_spec_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_field_spec_list
	return p
}

func (*Field_spec_listContext) IsField_spec_listContext() {}

func NewField_spec_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Field_spec_listContext {
	var p = new(Field_spec_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_field_spec_list

	return p
}

func (s *Field_spec_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Field_spec_listContext) AllField_spec() []IField_specContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IField_specContext)(nil)).Elem())
	var tst = make([]IField_specContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IField_specContext)
		}
	}

	return tst
}

func (s *Field_spec_listContext) Field_spec(i int) IField_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IField_specContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IField_specContext)
}

func (s *Field_spec_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_spec_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Field_spec_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterField_spec_list(s)
	}
}

func (s *Field_spec_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitField_spec_list(s)
	}
}

func (p *cluParser) Field_spec_list() (localctx IField_spec_listContext) {
	localctx = NewField_spec_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, cluParserRULE_field_spec_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(409)
		p.Field_spec()
	}
	p.SetState(414)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(410)
				p.Match(cluParserT__6)
			}
			{
				p.SetState(411)
				p.Field_spec()
			}

		}
		p.SetState(416)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext())
	}

	return localctx
}

// IField_specContext is an interface to support dynamic dispatch.
type IField_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsField_specContext differentiates from other interfaces.
	IsField_specContext()
}

type Field_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyField_specContext() *Field_specContext {
	var p = new(Field_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_field_spec
	return p
}

func (*Field_specContext) IsField_specContext() {}

func NewField_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Field_specContext {
	var p = new(Field_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_field_spec

	return p
}

func (s *Field_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Field_specContext) Name_list() IName_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_listContext)
}

func (s *Field_specContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Field_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Field_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterField_spec(s)
	}
}

func (s *Field_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitField_spec(s)
	}
}

func (p *cluParser) Field_spec() (localctx IField_specContext) {
	localctx = NewField_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, cluParserRULE_field_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(417)
		p.Name_list()
	}
	{
		p.SetState(418)
		p.Match(cluParserT__7)
	}
	{
		p.SetState(419)
		p.Type_spec()
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) Decl() IDeclContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclContext)
}

func (s *StatementContext) Idn() IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *StatementContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *StatementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *StatementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StatementContext) Decl_list() IDecl_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_listContext)
}

func (s *StatementContext) Invocation() IInvocationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInvocationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInvocationContext)
}

func (s *StatementContext) Idn_list() IIdn_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdn_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdn_listContext)
}

func (s *StatementContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *StatementContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *StatementContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *StatementContext) AllBody() []IBodyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBodyContext)(nil)).Elem())
	var tst = make([]IBodyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBodyContext)
		}
	}

	return tst
}

func (s *StatementContext) Body(i int) IBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBodyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBodyContext)
}

func (s *StatementContext) AllTag_arm() []ITag_armContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ITag_armContext)(nil)).Elem())
	var tst = make([]ITag_armContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ITag_armContext)
		}
	}

	return tst
}

func (s *StatementContext) Tag_arm(i int) ITag_armContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITag_armContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ITag_armContext)
}

func (s *StatementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *StatementContext) Name_list() IName_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_listContext)
}

func (s *StatementContext) AllWhen_handler() []IWhen_handlerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWhen_handlerContext)(nil)).Elem())
	var tst = make([]IWhen_handlerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWhen_handlerContext)
		}
	}

	return tst
}

func (s *StatementContext) When_handler(i int) IWhen_handlerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWhen_handlerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWhen_handlerContext)
}

func (s *StatementContext) Others_handler() IOthers_handlerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOthers_handlerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOthers_handlerContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *cluParser) Statement() (localctx IStatementContext) {
	return p.statement(0)
}

func (p *cluParser) statement(_p int) (localctx IStatementContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewStatementContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IStatementContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 62
	p.EnterRecursionRule(localctx, 62, cluParserRULE_statement, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(517)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(422)
			p.Decl()
		}

	case 2:
		{
			p.SetState(423)
			p.Idn()
		}
		{
			p.SetState(424)
			p.Match(cluParserT__7)
		}
		{
			p.SetState(425)
			p.Type_spec()
		}
		{
			p.SetState(426)
			p.Match(cluParserT__22)
		}
		{
			p.SetState(427)
			p.expression(0)
		}

	case 3:
		{
			p.SetState(429)
			p.Decl_list()
		}
		{
			p.SetState(430)
			p.Match(cluParserT__22)
		}
		{
			p.SetState(431)
			p.Invocation()
		}

	case 4:
		{
			p.SetState(433)
			p.Idn_list()
		}
		{
			p.SetState(434)
			p.Match(cluParserT__22)
		}
		p.SetState(437)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(435)
				p.Invocation()
			}

		case 2:
			{
				p.SetState(436)
				p.Expression_list()
			}

		}

	case 5:
		{
			p.SetState(439)
			p.primary(0)
		}
		{
			p.SetState(440)
			p.Match(cluParserT__39)
		}
		{
			p.SetState(441)
			p.Name()
		}
		{
			p.SetState(442)
			p.Match(cluParserT__22)
		}
		{
			p.SetState(443)
			p.expression(0)
		}

	case 6:
		{
			p.SetState(445)
			p.Invocation()
		}

	case 7:
		{
			p.SetState(446)
			p.Match(cluParserT__40)
		}
		{
			p.SetState(447)
			p.expression(0)
		}
		{
			p.SetState(448)
			p.Match(cluParserT__41)
		}
		{
			p.SetState(449)
			p.Body()
		}
		{
			p.SetState(450)
			p.Match(cluParserT__2)
		}

	case 8:
		{
			p.SetState(452)
			p.Match(cluParserT__42)
		}
		p.SetState(455)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(453)
				p.Decl_list()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 50, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(454)
				p.Idn_list()
			}

		}
		{
			p.SetState(457)
			p.Match(cluParserT__16)
		}
		{
			p.SetState(458)
			p.Invocation()
		}
		{
			p.SetState(459)
			p.Match(cluParserT__41)
		}
		{
			p.SetState(460)
			p.Body()
		}
		{
			p.SetState(461)
			p.Match(cluParserT__2)
		}

	case 9:
		{
			p.SetState(463)
			p.Match(cluParserT__43)
		}
		{
			p.SetState(464)
			p.expression(0)
		}
		{
			p.SetState(465)
			p.Match(cluParserT__44)
		}
		{
			p.SetState(466)
			p.Body()
		}
		p.SetState(474)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == cluParserT__45 {
			{
				p.SetState(467)
				p.Match(cluParserT__45)
			}
			{
				p.SetState(468)
				p.expression(0)
			}
			{
				p.SetState(469)
				p.Match(cluParserT__44)
			}
			{
				p.SetState(470)
				p.Body()
			}

			p.SetState(476)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(479)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == cluParserT__46 {
			{
				p.SetState(477)
				p.Match(cluParserT__46)
			}
			{
				p.SetState(478)
				p.Body()
			}

		}
		{
			p.SetState(481)
			p.Match(cluParserT__2)
		}

	case 10:
		{
			p.SetState(483)
			p.Match(cluParserT__47)
		}
		{
			p.SetState(484)
			p.expression(0)
		}
		p.SetState(488)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == cluParserT__57 {
			{
				p.SetState(485)
				p.Tag_arm()
			}

			p.SetState(490)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(494)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == cluParserT__48 {
			{
				p.SetState(491)
				p.Match(cluParserT__48)
			}
			{
				p.SetState(492)
				p.Match(cluParserT__7)
			}
			{
				p.SetState(493)
				p.Body()
			}

		}
		{
			p.SetState(496)
			p.Match(cluParserT__2)
		}

	case 11:
		{
			p.SetState(498)
			_la = p.GetTokenStream().LA(1)

			if !(_la == cluParserT__49 || _la == cluParserT__50) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(500)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(499)
				p.Expression_list()
			}

		}

	case 12:
		{
			p.SetState(502)
			p.Match(cluParserT__51)
		}
		{
			p.SetState(503)
			p.Name()
		}
		p.SetState(505)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(504)
				p.Expression_list()
			}

		}

	case 13:
		{
			p.SetState(507)
			p.Match(cluParserT__52)
		}
		{
			p.SetState(508)
			p.Name()
		}
		p.SetState(510)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(509)
				p.Expression_list()
			}

		}

	case 14:
		{
			p.SetState(512)
			p.Match(cluParserT__53)
		}

	case 15:
		{
			p.SetState(513)
			p.Match(cluParserT__54)
		}
		{
			p.SetState(514)
			p.Body()
		}
		{
			p.SetState(515)
			p.Match(cluParserT__2)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(537)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			localctx = NewStatementContext(p, _parentctx, _parentState)
			p.PushNewRecursionContext(localctx, _startState, cluParserRULE_statement)
			p.SetState(519)

			if !(p.Precpred(p.GetParserRuleContext(), 1)) {
				panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
			}
			p.SetState(533)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case cluParserT__55:
				{
					p.SetState(520)
					p.Match(cluParserT__55)
				}
				{
					p.SetState(521)
					p.Name_list()
				}

			case cluParserT__56:
				{
					p.SetState(522)
					p.Match(cluParserT__56)
				}
				p.SetState(526)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				for _la == cluParserT__58 {
					{
						p.SetState(523)
						p.When_handler()
					}

					p.SetState(528)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)
				}
				p.SetState(530)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == cluParserT__48 {
					{
						p.SetState(529)
						p.Others_handler()
					}

				}
				{
					p.SetState(532)
					p.Match(cluParserT__2)
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(539)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext())
	}

	return localctx
}

// ITag_armContext is an interface to support dynamic dispatch.
type ITag_armContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTag_armContext differentiates from other interfaces.
	IsTag_armContext()
}

type Tag_armContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTag_armContext() *Tag_armContext {
	var p = new(Tag_armContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_tag_arm
	return p
}

func (*Tag_armContext) IsTag_armContext() {}

func NewTag_armContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Tag_armContext {
	var p = new(Tag_armContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_tag_arm

	return p
}

func (s *Tag_armContext) GetParser() antlr.Parser { return s.parser }

func (s *Tag_armContext) Name_list() IName_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_listContext)
}

func (s *Tag_armContext) Body() IBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBodyContext)
}

func (s *Tag_armContext) Idn() IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *Tag_armContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Tag_armContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Tag_armContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Tag_armContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterTag_arm(s)
	}
}

func (s *Tag_armContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitTag_arm(s)
	}
}

func (p *cluParser) Tag_arm() (localctx ITag_armContext) {
	localctx = NewTag_armContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, cluParserRULE_tag_arm)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(540)
		p.Match(cluParserT__57)
	}
	{
		p.SetState(541)
		p.Name_list()
	}
	p.SetState(548)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserT__9 {
		{
			p.SetState(542)
			p.Match(cluParserT__9)
		}
		{
			p.SetState(543)
			p.Idn()
		}
		{
			p.SetState(544)
			p.Match(cluParserT__7)
		}
		{
			p.SetState(545)
			p.Type_spec()
		}
		{
			p.SetState(546)
			p.Match(cluParserT__10)
		}

	}
	{
		p.SetState(550)
		p.Match(cluParserT__7)
	}
	{
		p.SetState(551)
		p.Body()
	}

	return localctx
}

// IWhen_handlerContext is an interface to support dynamic dispatch.
type IWhen_handlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWhen_handlerContext differentiates from other interfaces.
	IsWhen_handlerContext()
}

type When_handlerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhen_handlerContext() *When_handlerContext {
	var p = new(When_handlerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_when_handler
	return p
}

func (*When_handlerContext) IsWhen_handlerContext() {}

func NewWhen_handlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *When_handlerContext {
	var p = new(When_handlerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_when_handler

	return p
}

func (s *When_handlerContext) GetParser() antlr.Parser { return s.parser }

func (s *When_handlerContext) Name_list() IName_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_listContext)
}

func (s *When_handlerContext) Body() IBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBodyContext)
}

func (s *When_handlerContext) Decl_list() IDecl_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecl_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecl_listContext)
}

func (s *When_handlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *When_handlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *When_handlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterWhen_handler(s)
	}
}

func (s *When_handlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitWhen_handler(s)
	}
}

func (p *cluParser) When_handler() (localctx IWhen_handlerContext) {
	localctx = NewWhen_handlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, cluParserRULE_when_handler)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(553)
		p.Match(cluParserT__58)
	}
	{
		p.SetState(554)
		p.Name_list()
	}
	p.SetState(561)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cluParserT__9:
		{
			p.SetState(555)
			p.Match(cluParserT__9)
		}
		{
			p.SetState(556)
			p.Match(cluParserT__59)
		}
		{
			p.SetState(557)
			p.Match(cluParserT__10)
		}

	case cluParserT__7, cluParserSTRING:
		p.SetState(559)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == cluParserSTRING {
			{
				p.SetState(558)
				p.Decl_list()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(563)
		p.Match(cluParserT__7)
	}
	{
		p.SetState(564)
		p.Body()
	}

	return localctx
}

// IOthers_handlerContext is an interface to support dynamic dispatch.
type IOthers_handlerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOthers_handlerContext differentiates from other interfaces.
	IsOthers_handlerContext()
}

type Others_handlerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOthers_handlerContext() *Others_handlerContext {
	var p = new(Others_handlerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_others_handler
	return p
}

func (*Others_handlerContext) IsOthers_handlerContext() {}

func NewOthers_handlerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Others_handlerContext {
	var p = new(Others_handlerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_others_handler

	return p
}

func (s *Others_handlerContext) GetParser() antlr.Parser { return s.parser }

func (s *Others_handlerContext) Body() IBodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBodyContext)
}

func (s *Others_handlerContext) Idn() IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *Others_handlerContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Others_handlerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Others_handlerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Others_handlerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterOthers_handler(s)
	}
}

func (s *Others_handlerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitOthers_handler(s)
	}
}

func (p *cluParser) Others_handler() (localctx IOthers_handlerContext) {
	localctx = NewOthers_handlerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, cluParserRULE_others_handler)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(566)
		p.Match(cluParserT__48)
	}
	p.SetState(573)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == cluParserT__9 {
		{
			p.SetState(567)
			p.Match(cluParserT__9)
		}
		{
			p.SetState(568)
			p.Idn()
		}
		{
			p.SetState(569)
			p.Match(cluParserT__7)
		}
		{
			p.SetState(570)
			p.Type_spec()
		}
		{
			p.SetState(571)
			p.Match(cluParserT__10)
		}

	}
	{
		p.SetState(575)
		p.Match(cluParserT__7)
	}
	{
		p.SetState(576)
		p.Body()
	}

	return localctx
}

// IBodyContext is an interface to support dynamic dispatch.
type IBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBodyContext differentiates from other interfaces.
	IsBodyContext()
}

type BodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBodyContext() *BodyContext {
	var p = new(BodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_body
	return p
}

func (*BodyContext) IsBodyContext() {}

func NewBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BodyContext {
	var p = new(BodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_body

	return p
}

func (s *BodyContext) GetParser() antlr.Parser { return s.parser }

func (s *BodyContext) AllEquate() []IEquateContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEquateContext)(nil)).Elem())
	var tst = make([]IEquateContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEquateContext)
		}
	}

	return tst
}

func (s *BodyContext) Equate(i int) IEquateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEquateContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEquateContext)
}

func (s *BodyContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *BodyContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *BodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterBody(s)
	}
}

func (s *BodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitBody(s)
	}
}

func (p *cluParser) Body() (localctx IBodyContext) {
	localctx = NewBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, cluParserRULE_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(581)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(578)
				p.Equate()
			}

		}
		p.SetState(583)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext())
	}
	p.SetState(587)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<cluParserT__19)|(1<<cluParserT__23)|(1<<cluParserT__24)|(1<<cluParserT__25)|(1<<cluParserT__26)|(1<<cluParserT__27)|(1<<cluParserT__28)|(1<<cluParserT__29)|(1<<cluParserT__30))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(cluParserT__31-32))|(1<<(cluParserT__32-32))|(1<<(cluParserT__33-32))|(1<<(cluParserT__34-32))|(1<<(cluParserT__35-32))|(1<<(cluParserT__36-32))|(1<<(cluParserT__37-32))|(1<<(cluParserT__38-32))|(1<<(cluParserT__40-32))|(1<<(cluParserT__42-32))|(1<<(cluParserT__43-32))|(1<<(cluParserT__47-32))|(1<<(cluParserT__49-32))|(1<<(cluParserT__50-32))|(1<<(cluParserT__51-32))|(1<<(cluParserT__52-32))|(1<<(cluParserT__53-32))|(1<<(cluParserT__54-32)))) != 0) || (((_la-81)&-(0x1f+1)) == 0 && ((1<<uint((_la-81)))&((1<<(cluParserT__80-81))|(1<<(cluParserT__81-81))|(1<<(cluParserT__82-81))|(1<<(cluParserT__84-81))|(1<<(cluParserT__85-81))|(1<<(cluParserT__86-81))|(1<<(cluParserSTRINGLITERAL-81))|(1<<(cluParserSTRING-81))|(1<<(cluParserINT-81))|(1<<(cluParserFLOAT-81)))) != 0) {
		{
			p.SetState(584)
			p.statement(0)
		}

		p.SetState(589)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExpression_listContext is an interface to support dynamic dispatch.
type IExpression_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpression_listContext differentiates from other interfaces.
	IsExpression_listContext()
}

type Expression_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpression_listContext() *Expression_listContext {
	var p = new(Expression_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_expression_list
	return p
}

func (*Expression_listContext) IsExpression_listContext() {}

func NewExpression_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expression_listContext {
	var p = new(Expression_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_expression_list

	return p
}

func (s *Expression_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expression_listContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Expression_listContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Expression_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expression_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterExpression_list(s)
	}
}

func (s *Expression_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitExpression_list(s)
	}
}

func (p *cluParser) Expression_list() (localctx IExpression_listContext) {
	localctx = NewExpression_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, cluParserRULE_expression_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(590)
		p.expression(0)
	}
	p.SetState(595)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(591)
				p.Match(cluParserT__6)
			}
			{
				p.SetState(592)
				p.expression(0)
			}

		}
		p.SetState(597)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext())
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *ExpressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *ExpressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *cluParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *cluParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 74
	p.EnterRecursionRule(localctx, 74, cluParserRULE_expression, _p)

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(608)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case cluParserT__19, cluParserT__23, cluParserT__24, cluParserT__25, cluParserT__26, cluParserT__27, cluParserT__28, cluParserT__29, cluParserT__30, cluParserT__31, cluParserT__32, cluParserT__33, cluParserT__34, cluParserT__35, cluParserT__36, cluParserT__37, cluParserT__38, cluParserT__80, cluParserT__81, cluParserT__82, cluParserT__84, cluParserT__85, cluParserT__86, cluParserSTRINGLITERAL, cluParserSTRING, cluParserINT, cluParserFLOAT:
		{
			p.SetState(599)
			p.primary(0)
		}

	case cluParserT__9:
		{
			p.SetState(600)
			p.Match(cluParserT__9)
		}
		{
			p.SetState(601)
			p.expression(0)
		}
		{
			p.SetState(602)
			p.Match(cluParserT__10)
		}

	case cluParserT__60:
		{
			p.SetState(604)
			p.Match(cluParserT__60)
		}
		{
			p.SetState(605)
			p.expression(23)
		}

	case cluParserT__61:
		{
			p.SetState(606)
			p.Match(cluParserT__61)
		}
		{
			p.SetState(607)
			p.expression(22)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(675)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(673)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 71, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(610)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
				}
				{
					p.SetState(611)
					p.Match(cluParserT__62)
				}
				{
					p.SetState(612)
					p.expression(22)
				}

			case 2:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(613)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
				}
				{
					p.SetState(614)
					p.Match(cluParserT__63)
				}
				{
					p.SetState(615)
					p.expression(21)
				}

			case 3:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(616)

				if !(p.Precpred(p.GetParserRuleContext(), 19)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 19)", ""))
				}
				{
					p.SetState(617)
					p.Match(cluParserT__64)
				}
				{
					p.SetState(618)
					p.expression(20)
				}

			case 4:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(619)

				if !(p.Precpred(p.GetParserRuleContext(), 18)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 18)", ""))
				}
				{
					p.SetState(620)
					p.Match(cluParserT__59)
				}
				{
					p.SetState(621)
					p.expression(19)
				}

			case 5:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(622)

				if !(p.Precpred(p.GetParserRuleContext(), 17)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 17)", ""))
				}
				{
					p.SetState(623)
					p.Match(cluParserT__65)
				}
				{
					p.SetState(624)
					p.expression(18)
				}

			case 6:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(625)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
				}
				{
					p.SetState(626)
					p.Match(cluParserT__66)
				}
				{
					p.SetState(627)
					p.expression(17)
				}

			case 7:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(628)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
				}
				{
					p.SetState(629)
					p.Match(cluParserT__61)
				}
				{
					p.SetState(630)
					p.expression(16)
				}

			case 8:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(631)

				if !(p.Precpred(p.GetParserRuleContext(), 14)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 14)", ""))
				}
				{
					p.SetState(632)
					p.Match(cluParserT__67)
				}
				{
					p.SetState(633)
					p.expression(15)
				}

			case 9:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(634)

				if !(p.Precpred(p.GetParserRuleContext(), 13)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 13)", ""))
				}
				{
					p.SetState(635)
					p.Match(cluParserT__68)
				}
				{
					p.SetState(636)
					p.expression(14)
				}

			case 10:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(637)

				if !(p.Precpred(p.GetParserRuleContext(), 12)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 12)", ""))
				}
				{
					p.SetState(638)
					p.Match(cluParserT__0)
				}
				{
					p.SetState(639)
					p.expression(13)
				}

			case 11:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(640)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
				}
				{
					p.SetState(641)
					p.Match(cluParserT__69)
				}
				{
					p.SetState(642)
					p.expression(12)
				}

			case 12:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(643)

				if !(p.Precpred(p.GetParserRuleContext(), 10)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 10)", ""))
				}
				{
					p.SetState(644)
					p.Match(cluParserT__70)
				}
				{
					p.SetState(645)
					p.expression(11)
				}

			case 13:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(646)

				if !(p.Precpred(p.GetParserRuleContext(), 9)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 9)", ""))
				}
				{
					p.SetState(647)
					p.Match(cluParserT__71)
				}
				{
					p.SetState(648)
					p.expression(10)
				}

			case 14:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(649)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
				}
				{
					p.SetState(650)
					p.Match(cluParserT__72)
				}
				{
					p.SetState(651)
					p.expression(9)
				}

			case 15:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(652)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
				}
				{
					p.SetState(653)
					p.Match(cluParserT__73)
				}
				{
					p.SetState(654)
					p.expression(8)
				}

			case 16:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(655)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(656)
					p.Match(cluParserT__74)
				}
				{
					p.SetState(657)
					p.expression(7)
				}

			case 17:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(658)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(659)
					p.Match(cluParserT__75)
				}
				{
					p.SetState(660)
					p.expression(6)
				}

			case 18:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(661)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(662)
					p.Match(cluParserT__76)
				}
				{
					p.SetState(663)
					p.expression(5)
				}

			case 19:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(664)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
				}
				{
					p.SetState(665)
					p.Match(cluParserT__77)
				}
				{
					p.SetState(666)
					p.expression(4)
				}

			case 20:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(667)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
				}
				{
					p.SetState(668)
					p.Match(cluParserT__78)
				}
				{
					p.SetState(669)
					p.expression(3)
				}

			case 21:
				localctx = NewExpressionContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_expression)
				p.SetState(670)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
				}
				{
					p.SetState(671)
					p.Match(cluParserT__79)
				}
				{
					p.SetState(672)
					p.expression(2)
				}

			}

		}
		p.SetState(677)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext())
	}

	return localctx
}

// IPrimaryContext is an interface to support dynamic dispatch.
type IPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimaryContext differentiates from other interfaces.
	IsPrimaryContext()
}

type PrimaryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimaryContext() *PrimaryContext {
	var p = new(PrimaryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_primary
	return p
}

func (*PrimaryContext) IsPrimaryContext() {}

func NewPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrimaryContext {
	var p = new(PrimaryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_primary

	return p
}

func (s *PrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *PrimaryContext) Int_literal() IInt_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInt_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInt_literalContext)
}

func (s *PrimaryContext) Real_literal() IReal_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReal_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReal_literalContext)
}

func (s *PrimaryContext) String_literal() IString_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_literalContext)
}

func (s *PrimaryContext) Idn() IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *PrimaryContext) Constant_list() IConstant_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_listContext)
}

func (s *PrimaryContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *PrimaryContext) Field_list() IField_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IField_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IField_listContext)
}

func (s *PrimaryContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *PrimaryContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *PrimaryContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *PrimaryContext) Name() INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *PrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterPrimary(s)
	}
}

func (s *PrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitPrimary(s)
	}
}

func (p *cluParser) Primary() (localctx IPrimaryContext) {
	return p.primary(0)
}

func (p *cluParser) primary(_p int) (localctx IPrimaryContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()
	_parentState := p.GetState()
	localctx = NewPrimaryContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IPrimaryContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 76
	p.EnterRecursionRule(localctx, 76, cluParserRULE_primary, _p)
	var _la int

	defer func() {
		p.UnrollRecursionContexts(_parentctx)
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(715)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(679)
			p.Match(cluParserT__80)
		}

	case 2:
		{
			p.SetState(680)
			p.Match(cluParserT__81)
		}

	case 3:
		{
			p.SetState(681)
			p.Match(cluParserT__82)
		}

	case 4:
		{
			p.SetState(682)
			p.Int_literal()
		}

	case 5:
		{
			p.SetState(683)
			p.Real_literal()
		}

	case 6:
		{
			p.SetState(684)
			p.String_literal()
		}

	case 7:
		{
			p.SetState(685)
			p.Idn()
		}
		p.SetState(687)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 73, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(686)
				p.Constant_list()
			}

		}

	case 8:
		{
			p.SetState(689)
			p.Type_spec()
		}
		{
			p.SetState(690)
			p.Match(cluParserT__83)
		}
		p.SetState(704)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case cluParserSTRING:
			{
				p.SetState(691)
				p.Field_list()
			}

		case cluParserT__17:
			{
				p.SetState(692)
				p.Match(cluParserT__17)
			}
			p.SetState(700)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) {
			case 1:
				p.SetState(696)
				p.GetErrorHandler().Sync(p)

				if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(693)
						p.expression(0)
					}
					{
						p.SetState(694)
						p.Match(cluParserT__7)
					}

				}
				{
					p.SetState(698)
					p.Expression_list()
				}

			case 2:
				{
					p.SetState(699)
					p.Constant_list()
				}

			}
			{
				p.SetState(702)
				p.Match(cluParserT__18)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 9:
		{
			p.SetState(706)
			p.Match(cluParserT__84)
		}
		p.SetState(708)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 77, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(707)
				p.Type_spec()
			}

		}

	case 10:
		{
			p.SetState(710)
			_la = p.GetTokenStream().LA(1)

			if !(_la == cluParserT__85 || _la == cluParserT__86) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(711)
			p.Match(cluParserT__9)
		}
		{
			p.SetState(712)
			p.expression(0)
		}
		{
			p.SetState(713)
			p.Match(cluParserT__10)
		}

	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(729)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(727)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext()) {
			case 1:
				localctx = NewPrimaryContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_primary)
				p.SetState(717)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
				}
				{
					p.SetState(718)
					p.Match(cluParserT__39)
				}
				{
					p.SetState(719)
					p.Name()
				}

			case 2:
				localctx = NewPrimaryContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_primary)
				p.SetState(720)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
				}
				{
					p.SetState(721)
					p.expression(0)
				}

			case 3:
				localctx = NewPrimaryContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, cluParserRULE_primary)
				p.SetState(722)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					panic(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
				}
				{
					p.SetState(723)
					p.Match(cluParserT__9)
				}
				{
					p.SetState(724)
					p.Expression_list()
				}
				{
					p.SetState(725)
					p.Match(cluParserT__10)
				}

			}

		}
		p.SetState(731)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 80, p.GetParserRuleContext())
	}

	return localctx
}

// IInvocationContext is an interface to support dynamic dispatch.
type IInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInvocationContext differentiates from other interfaces.
	IsInvocationContext()
}

type InvocationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInvocationContext() *InvocationContext {
	var p = new(InvocationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_invocation
	return p
}

func (*InvocationContext) IsInvocationContext() {}

func NewInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InvocationContext {
	var p = new(InvocationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_invocation

	return p
}

func (s *InvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *InvocationContext) Primary() IPrimaryContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimaryContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimaryContext)
}

func (s *InvocationContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *InvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InvocationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterInvocation(s)
	}
}

func (s *InvocationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitInvocation(s)
	}
}

func (p *cluParser) Invocation() (localctx IInvocationContext) {
	localctx = NewInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, cluParserRULE_invocation)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(732)
		p.primary(0)
	}
	{
		p.SetState(733)
		p.Match(cluParserT__9)
	}
	{
		p.SetState(734)
		p.Expression_list()
	}
	{
		p.SetState(735)
		p.Match(cluParserT__10)
	}

	return localctx
}

// IField_listContext is an interface to support dynamic dispatch.
type IField_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsField_listContext differentiates from other interfaces.
	IsField_listContext()
}

type Field_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyField_listContext() *Field_listContext {
	var p = new(Field_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_field_list
	return p
}

func (*Field_listContext) IsField_listContext() {}

func NewField_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Field_listContext {
	var p = new(Field_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_field_list

	return p
}

func (s *Field_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Field_listContext) AllField() []IFieldContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFieldContext)(nil)).Elem())
	var tst = make([]IFieldContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFieldContext)
		}
	}

	return tst
}

func (s *Field_listContext) Field(i int) IFieldContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFieldContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFieldContext)
}

func (s *Field_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Field_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Field_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterField_list(s)
	}
}

func (s *Field_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitField_list(s)
	}
}

func (p *cluParser) Field_list() (localctx IField_listContext) {
	localctx = NewField_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, cluParserRULE_field_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(737)
		p.Field()
	}
	p.SetState(742)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(738)
				p.Match(cluParserT__6)
			}
			{
				p.SetState(739)
				p.Field()
			}

		}
		p.SetState(744)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext())
	}

	return localctx
}

// IFieldContext is an interface to support dynamic dispatch.
type IFieldContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFieldContext differentiates from other interfaces.
	IsFieldContext()
}

type FieldContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldContext() *FieldContext {
	var p = new(FieldContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_field
	return p
}

func (*FieldContext) IsFieldContext() {}

func NewFieldContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldContext {
	var p = new(FieldContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_field

	return p
}

func (s *FieldContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldContext) Name_list() IName_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_listContext)
}

func (s *FieldContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FieldContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterField(s)
	}
}

func (s *FieldContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitField(s)
	}
}

func (p *cluParser) Field() (localctx IFieldContext) {
	localctx = NewFieldContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, cluParserRULE_field)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(745)
		p.Name_list()
	}
	{
		p.SetState(746)
		p.Match(cluParserT__7)
	}
	{
		p.SetState(747)
		p.expression(0)
	}

	return localctx
}

// IIdn_listContext is an interface to support dynamic dispatch.
type IIdn_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdn_listContext differentiates from other interfaces.
	IsIdn_listContext()
}

type Idn_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdn_listContext() *Idn_listContext {
	var p = new(Idn_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_idn_list
	return p
}

func (*Idn_listContext) IsIdn_listContext() {}

func NewIdn_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Idn_listContext {
	var p = new(Idn_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_idn_list

	return p
}

func (s *Idn_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Idn_listContext) AllIdn() []IIdnContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdnContext)(nil)).Elem())
	var tst = make([]IIdnContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdnContext)
		}
	}

	return tst
}

func (s *Idn_listContext) Idn(i int) IIdnContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdnContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdnContext)
}

func (s *Idn_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Idn_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Idn_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterIdn_list(s)
	}
}

func (s *Idn_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitIdn_list(s)
	}
}

func (p *cluParser) Idn_list() (localctx IIdn_listContext) {
	localctx = NewIdn_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, cluParserRULE_idn_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(749)
		p.Idn()
	}
	p.SetState(754)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == cluParserT__6 {
		{
			p.SetState(750)
			p.Match(cluParserT__6)
		}
		{
			p.SetState(751)
			p.Idn()
		}

		p.SetState(756)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IIdnContext is an interface to support dynamic dispatch.
type IIdnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdnContext differentiates from other interfaces.
	IsIdnContext()
}

type IdnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdnContext() *IdnContext {
	var p = new(IdnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_idn
	return p
}

func (*IdnContext) IsIdnContext() {}

func NewIdnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdnContext {
	var p = new(IdnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_idn

	return p
}

func (s *IdnContext) GetParser() antlr.Parser { return s.parser }

func (s *IdnContext) STRING() antlr.TerminalNode {
	return s.GetToken(cluParserSTRING, 0)
}

func (s *IdnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterIdn(s)
	}
}

func (s *IdnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitIdn(s)
	}
}

func (p *cluParser) Idn() (localctx IIdnContext) {
	localctx = NewIdnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, cluParserRULE_idn)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(757)
		p.Match(cluParserSTRING)
	}

	return localctx
}

// IName_listContext is an interface to support dynamic dispatch.
type IName_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_listContext differentiates from other interfaces.
	IsName_listContext()
}

type Name_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_listContext() *Name_listContext {
	var p = new(Name_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_name_list
	return p
}

func (*Name_listContext) IsName_listContext() {}

func NewName_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_listContext {
	var p = new(Name_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_name_list

	return p
}

func (s *Name_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_listContext) AllName() []INameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*INameContext)(nil)).Elem())
	var tst = make([]INameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(INameContext)
		}
	}

	return tst
}

func (s *Name_listContext) Name(i int) INameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(INameContext)
}

func (s *Name_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterName_list(s)
	}
}

func (s *Name_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitName_list(s)
	}
}

func (p *cluParser) Name_list() (localctx IName_listContext) {
	localctx = NewName_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, cluParserRULE_name_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(759)
		p.Name()
	}
	p.SetState(764)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(760)
				p.Match(cluParserT__6)
			}
			{
				p.SetState(761)
				p.Name()
			}

		}
		p.SetState(766)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 83, p.GetParserRuleContext())
	}

	return localctx
}

// INameContext is an interface to support dynamic dispatch.
type INameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNameContext differentiates from other interfaces.
	IsNameContext()
}

type NameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNameContext() *NameContext {
	var p = new(NameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_name
	return p
}

func (*NameContext) IsNameContext() {}

func NewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NameContext {
	var p = new(NameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_name

	return p
}

func (s *NameContext) GetParser() antlr.Parser { return s.parser }

func (s *NameContext) STRING() antlr.TerminalNode {
	return s.GetToken(cluParserSTRING, 0)
}

func (s *NameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterName(s)
	}
}

func (s *NameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitName(s)
	}
}

func (p *cluParser) Name() (localctx INameContext) {
	localctx = NewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, cluParserRULE_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(767)
		p.Match(cluParserSTRING)
	}

	return localctx
}

// IInt_literalContext is an interface to support dynamic dispatch.
type IInt_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInt_literalContext differentiates from other interfaces.
	IsInt_literalContext()
}

type Int_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInt_literalContext() *Int_literalContext {
	var p = new(Int_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_int_literal
	return p
}

func (*Int_literalContext) IsInt_literalContext() {}

func NewInt_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Int_literalContext {
	var p = new(Int_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_int_literal

	return p
}

func (s *Int_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Int_literalContext) INT() antlr.TerminalNode {
	return s.GetToken(cluParserINT, 0)
}

func (s *Int_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Int_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Int_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterInt_literal(s)
	}
}

func (s *Int_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitInt_literal(s)
	}
}

func (p *cluParser) Int_literal() (localctx IInt_literalContext) {
	localctx = NewInt_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, cluParserRULE_int_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(769)
		p.Match(cluParserINT)
	}

	return localctx
}

// IReal_literalContext is an interface to support dynamic dispatch.
type IReal_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReal_literalContext differentiates from other interfaces.
	IsReal_literalContext()
}

type Real_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReal_literalContext() *Real_literalContext {
	var p = new(Real_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_real_literal
	return p
}

func (*Real_literalContext) IsReal_literalContext() {}

func NewReal_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Real_literalContext {
	var p = new(Real_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_real_literal

	return p
}

func (s *Real_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Real_literalContext) FLOAT() antlr.TerminalNode {
	return s.GetToken(cluParserFLOAT, 0)
}

func (s *Real_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Real_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Real_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterReal_literal(s)
	}
}

func (s *Real_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitReal_literal(s)
	}
}

func (p *cluParser) Real_literal() (localctx IReal_literalContext) {
	localctx = NewReal_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, cluParserRULE_real_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(771)
		p.Match(cluParserFLOAT)
	}

	return localctx
}

// IString_literalContext is an interface to support dynamic dispatch.
type IString_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsString_literalContext differentiates from other interfaces.
	IsString_literalContext()
}

type String_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyString_literalContext() *String_literalContext {
	var p = new(String_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = cluParserRULE_string_literal
	return p
}

func (*String_literalContext) IsString_literalContext() {}

func NewString_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_literalContext {
	var p = new(String_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = cluParserRULE_string_literal

	return p
}

func (s *String_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *String_literalContext) STRINGLITERAL() antlr.TerminalNode {
	return s.GetToken(cluParserSTRINGLITERAL, 0)
}

func (s *String_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *String_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.EnterString_literal(s)
	}
}

func (s *String_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(cluListener); ok {
		listenerT.ExitString_literal(s)
	}
}

func (p *cluParser) String_literal() (localctx IString_literalContext) {
	localctx = NewString_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, cluParserRULE_string_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(773)
		p.Match(cluParserSTRINGLITERAL)
	}

	return localctx
}

func (p *cluParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 31:
		var t *StatementContext = nil
		if localctx != nil {
			t = localctx.(*StatementContext)
		}
		return p.Statement_Sempred(t, predIndex)

	case 37:
		var t *ExpressionContext = nil
		if localctx != nil {
			t = localctx.(*ExpressionContext)
		}
		return p.Expression_Sempred(t, predIndex)

	case 38:
		var t *PrimaryContext = nil
		if localctx != nil {
			t = localctx.(*PrimaryContext)
		}
		return p.Primary_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *cluParser) Statement_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *cluParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 1:
		return p.Precpred(p.GetParserRuleContext(), 21)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 20)

	case 3:
		return p.Precpred(p.GetParserRuleContext(), 19)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 18)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 17)

	case 6:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 15)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 14)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 13)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 12)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 11)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 10)

	case 13:
		return p.Precpred(p.GetParserRuleContext(), 9)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 8)

	case 15:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 16:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 17:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 18:
		return p.Precpred(p.GetParserRuleContext(), 4)

	case 19:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 20:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 21:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *cluParser) Primary_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 22:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 23:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 24:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
