// Code generated from IDL.g4 by ANTLR 4.7.2. DO NOT EDIT.

package idl // IDL
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 103, 1186,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 4, 103, 9, 103, 4, 104, 9, 104, 4, 105, 9, 105, 4, 106, 9, 106,
	4, 107, 9, 107, 4, 108, 9, 108, 4, 109, 9, 109, 4, 110, 9, 110, 4, 111,
	9, 111, 4, 112, 9, 112, 4, 113, 9, 113, 4, 114, 9, 114, 4, 115, 9, 115,
	4, 116, 9, 116, 4, 117, 9, 117, 4, 118, 9, 118, 4, 119, 9, 119, 4, 120,
	9, 120, 4, 121, 9, 121, 4, 122, 9, 122, 4, 123, 9, 123, 4, 124, 9, 124,
	4, 125, 9, 125, 4, 126, 9, 126, 4, 127, 9, 127, 4, 128, 9, 128, 4, 129,
	9, 129, 4, 130, 9, 130, 4, 131, 9, 131, 4, 132, 9, 132, 4, 133, 9, 133,
	4, 134, 9, 134, 4, 135, 9, 135, 4, 136, 9, 136, 4, 137, 9, 137, 4, 138,
	9, 138, 3, 2, 7, 2, 278, 10, 2, 12, 2, 14, 2, 281, 11, 2, 3, 2, 6, 2, 284,
	10, 2, 13, 2, 14, 2, 285, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
	3, 3, 3, 5, 3, 321, 10, 3, 3, 4, 3, 4, 3, 4, 3, 4, 6, 4, 327, 10, 4, 13,
	4, 14, 4, 328, 3, 4, 3, 4, 3, 5, 3, 5, 5, 5, 335, 10, 5, 3, 6, 3, 6, 3,
	6, 3, 6, 3, 6, 3, 7, 5, 7, 343, 10, 7, 3, 7, 3, 7, 3, 7, 3, 8, 5, 8, 349,
	10, 8, 3, 8, 3, 8, 3, 8, 5, 8, 354, 10, 8, 3, 9, 7, 9, 357, 10, 9, 12,
	9, 14, 9, 360, 11, 9, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10,
	3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3, 10, 3,
	10, 3, 10, 3, 10, 3, 10, 5, 10, 383, 10, 10, 3, 11, 3, 11, 3, 11, 3, 11,
	7, 11, 389, 10, 11, 12, 11, 14, 11, 392, 11, 11, 3, 12, 3, 12, 3, 13, 5,
	13, 397, 10, 13, 3, 13, 3, 13, 3, 13, 7, 13, 402, 10, 13, 12, 13, 14, 13,
	405, 11, 13, 3, 14, 3, 14, 3, 14, 3, 14, 5, 14, 411, 10, 14, 3, 15, 5,
	15, 414, 10, 15, 3, 15, 3, 15, 3, 15, 3, 16, 3, 16, 3, 16, 3, 16, 3, 17,
	3, 17, 3, 17, 3, 17, 3, 17, 3, 17, 7, 17, 429, 10, 17, 12, 17, 14, 17,
	432, 11, 17, 3, 17, 3, 17, 3, 18, 3, 18, 3, 18, 7, 18, 439, 10, 18, 12,
	18, 14, 18, 442, 11, 18, 3, 18, 3, 18, 3, 19, 5, 19, 447, 10, 19, 3, 19,
	3, 19, 3, 19, 3, 19, 3, 20, 3, 20, 5, 20, 455, 10, 20, 3, 20, 3, 20, 3,
	20, 7, 20, 460, 10, 20, 12, 20, 14, 20, 463, 11, 20, 5, 20, 465, 10, 20,
	3, 20, 3, 20, 3, 20, 3, 20, 7, 20, 471, 10, 20, 12, 20, 14, 20, 474, 11,
	20, 5, 20, 476, 10, 20, 3, 21, 3, 21, 3, 22, 3, 22, 3, 22, 5, 22, 483,
	10, 22, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 24, 3, 24, 3, 24, 3, 24,
	5, 24, 494, 10, 24, 3, 24, 3, 24, 5, 24, 498, 10, 24, 3, 24, 3, 24, 3,
	25, 3, 25, 3, 25, 7, 25, 505, 10, 25, 12, 25, 14, 25, 508, 11, 25, 3, 26,
	3, 26, 3, 26, 3, 26, 3, 27, 3, 27, 3, 28, 3, 28, 3, 28, 3, 28, 3, 28, 3,
	28, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29,
	5, 29, 532, 10, 29, 3, 30, 3, 30, 3, 31, 3, 31, 3, 31, 7, 31, 539, 10,
	31, 12, 31, 14, 31, 542, 11, 31, 3, 32, 3, 32, 3, 32, 7, 32, 547, 10, 32,
	12, 32, 14, 32, 550, 11, 32, 3, 33, 3, 33, 3, 33, 7, 33, 555, 10, 33, 12,
	33, 14, 33, 558, 11, 33, 3, 34, 3, 34, 3, 34, 7, 34, 563, 10, 34, 12, 34,
	14, 34, 566, 11, 34, 3, 35, 3, 35, 3, 35, 7, 35, 571, 10, 35, 12, 35, 14,
	35, 574, 11, 35, 3, 36, 3, 36, 3, 36, 7, 36, 579, 10, 36, 12, 36, 14, 36,
	582, 11, 36, 3, 37, 3, 37, 3, 37, 3, 37, 5, 37, 588, 10, 37, 3, 38, 3,
	38, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 3, 39, 5, 39, 598, 10, 39, 3, 40,
	3, 40, 3, 41, 3, 41, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3, 42, 3,
	42, 5, 42, 612, 10, 42, 3, 43, 3, 43, 3, 43, 3, 44, 3, 44, 5, 44, 619,
	10, 44, 3, 45, 3, 45, 3, 45, 5, 45, 624, 10, 45, 3, 46, 3, 46, 3, 46, 3,
	46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 5, 46, 635, 10, 46, 3, 47, 3, 47,
	3, 47, 3, 47, 5, 47, 641, 10, 47, 3, 48, 3, 48, 3, 48, 5, 48, 646, 10,
	48, 3, 49, 3, 49, 3, 49, 7, 49, 651, 10, 49, 12, 49, 14, 49, 654, 11, 49,
	3, 50, 3, 50, 5, 50, 658, 10, 50, 3, 51, 3, 51, 3, 52, 3, 52, 3, 53, 3,
	53, 3, 53, 3, 53, 5, 53, 668, 10, 53, 3, 54, 3, 54, 5, 54, 672, 10, 54,
	3, 55, 3, 55, 3, 55, 5, 55, 677, 10, 55, 3, 56, 3, 56, 3, 57, 3, 57, 3,
	58, 3, 58, 3, 58, 3, 59, 3, 59, 3, 59, 5, 59, 689, 10, 59, 3, 60, 3, 60,
	3, 60, 3, 61, 3, 61, 3, 61, 3, 62, 3, 62, 3, 62, 3, 62, 3, 63, 3, 63, 3,
	64, 3, 64, 3, 65, 3, 65, 3, 66, 3, 66, 3, 67, 3, 67, 3, 68, 3, 68, 3, 69,
	3, 69, 3, 69, 3, 69, 3, 69, 3, 69, 3, 70, 6, 70, 720, 10, 70, 13, 70, 14,
	70, 721, 3, 71, 3, 71, 3, 71, 3, 71, 3, 72, 3, 72, 3, 72, 3, 72, 3, 72,
	3, 72, 3, 72, 3, 72, 3, 72, 3, 72, 3, 73, 3, 73, 3, 73, 3, 73, 3, 73, 5,
	73, 743, 10, 73, 3, 74, 6, 74, 746, 10, 74, 13, 74, 14, 74, 747, 3, 75,
	6, 75, 751, 10, 75, 13, 75, 14, 75, 752, 3, 75, 3, 75, 3, 75, 3, 76, 3,
	76, 3, 76, 3, 76, 3, 76, 3, 76, 5, 76, 764, 10, 76, 3, 77, 3, 77, 3, 77,
	3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 7, 78, 775, 10, 78, 12, 78, 14,
	78, 778, 11, 78, 3, 78, 3, 78, 3, 79, 3, 79, 3, 80, 3, 80, 3, 80, 3, 80,
	3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 5, 80, 796, 10,
	80, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 3, 81, 5, 81, 804, 10, 81, 3, 82,
	3, 82, 3, 82, 3, 82, 3, 82, 3, 82, 5, 82, 812, 10, 82, 3, 83, 3, 83, 6,
	83, 816, 10, 83, 13, 83, 14, 83, 817, 3, 84, 3, 84, 3, 84, 3, 84, 3, 85,
	3, 85, 5, 85, 826, 10, 85, 3, 86, 3, 86, 3, 86, 3, 86, 7, 86, 832, 10,
	86, 12, 86, 14, 86, 835, 11, 86, 3, 86, 3, 86, 3, 87, 5, 87, 840, 10, 87,
	3, 87, 3, 87, 3, 87, 3, 87, 5, 87, 846, 10, 87, 3, 87, 5, 87, 849, 10,
	87, 3, 88, 3, 88, 3, 89, 3, 89, 5, 89, 855, 10, 89, 3, 90, 3, 90, 3, 90,
	3, 90, 7, 90, 861, 10, 90, 12, 90, 14, 90, 864, 11, 90, 3, 90, 3, 90, 3,
	90, 3, 90, 5, 90, 870, 10, 90, 3, 91, 3, 91, 3, 91, 3, 91, 3, 92, 3, 92,
	3, 93, 3, 93, 3, 93, 3, 93, 3, 93, 7, 93, 883, 10, 93, 12, 93, 14, 93,
	886, 11, 93, 3, 93, 3, 93, 3, 94, 3, 94, 3, 94, 3, 94, 3, 94, 7, 94, 895,
	10, 94, 12, 94, 14, 94, 898, 11, 94, 3, 94, 3, 94, 3, 95, 3, 95, 3, 95,
	3, 95, 5, 95, 906, 10, 95, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3,
	96, 3, 97, 3, 97, 3, 98, 3, 98, 3, 99, 3, 99, 3, 99, 3, 99, 5, 99, 923,
	10, 99, 3, 100, 3, 100, 3, 100, 3, 100, 3, 101, 3, 101, 5, 101, 931, 10,
	101, 3, 102, 3, 102, 3, 102, 3, 102, 3, 103, 3, 103, 3, 103, 3, 103, 3,
	104, 3, 104, 3, 104, 3, 104, 3, 104, 3, 105, 3, 105, 3, 105, 3, 105, 3,
	105, 3, 105, 7, 105, 952, 10, 105, 12, 105, 14, 105, 955, 11, 105, 5, 105,
	957, 10, 105, 3, 106, 3, 106, 3, 106, 3, 106, 3, 107, 3, 107, 3, 107, 3,
	107, 3, 107, 3, 107, 7, 107, 969, 10, 107, 12, 107, 14, 107, 972, 11, 107,
	5, 107, 974, 10, 107, 3, 108, 3, 108, 5, 108, 978, 10, 108, 3, 108, 5,
	108, 981, 10, 108, 3, 109, 3, 109, 3, 109, 3, 110, 3, 110, 3, 110, 3, 111,
	3, 111, 3, 111, 3, 111, 7, 111, 993, 10, 111, 12, 111, 14, 111, 996, 11,
	111, 3, 111, 3, 111, 3, 112, 3, 112, 5, 112, 1002, 10, 112, 3, 113, 3,
	113, 3, 113, 3, 114, 3, 114, 3, 114, 3, 114, 3, 114, 3, 115, 3, 115, 3,
	115, 5, 115, 1015, 10, 115, 3, 115, 5, 115, 1018, 10, 115, 3, 116, 3, 116,
	3, 116, 3, 116, 7, 116, 1024, 10, 116, 12, 116, 14, 116, 1027, 11, 116,
	3, 117, 3, 117, 3, 117, 3, 118, 7, 118, 1033, 10, 118, 12, 118, 14, 118,
	1036, 11, 118, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119,
	3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119, 3, 119,
	3, 119, 3, 119, 5, 119, 1056, 10, 119, 3, 120, 3, 120, 3, 120, 3, 120,
	3, 121, 3, 121, 5, 121, 1064, 10, 121, 3, 122, 3, 122, 5, 122, 1068, 10,
	122, 3, 122, 3, 122, 3, 122, 3, 123, 3, 123, 3, 123, 3, 123, 3, 124, 3,
	124, 3, 124, 3, 124, 3, 125, 3, 125, 3, 125, 3, 125, 3, 126, 3, 126, 3,
	126, 3, 127, 3, 127, 3, 127, 5, 127, 1091, 10, 127, 3, 127, 5, 127, 1094,
	10, 127, 3, 127, 3, 127, 3, 127, 5, 127, 1099, 10, 127, 3, 128, 3, 128,
	3, 128, 3, 129, 3, 129, 3, 129, 3, 130, 3, 130, 7, 130, 1109, 10, 130,
	12, 130, 14, 130, 1112, 11, 130, 3, 130, 3, 130, 3, 131, 3, 131, 3, 131,
	3, 131, 3, 131, 3, 131, 3, 131, 5, 131, 1123, 10, 131, 3, 132, 3, 132,
	3, 132, 3, 132, 5, 132, 1129, 10, 132, 3, 132, 3, 132, 5, 132, 1133, 10,
	132, 3, 133, 3, 133, 3, 133, 3, 133, 5, 133, 1139, 10, 133, 3, 133, 3,
	133, 5, 133, 1143, 10, 133, 3, 134, 3, 134, 3, 134, 5, 134, 1148, 10, 134,
	3, 135, 5, 135, 1151, 10, 135, 3, 135, 3, 135, 3, 135, 3, 136, 3, 136,
	3, 136, 3, 136, 3, 136, 3, 136, 7, 136, 1162, 10, 136, 12, 136, 14, 136,
	1165, 11, 136, 3, 136, 3, 136, 3, 137, 3, 137, 3, 137, 7, 137, 1172, 10,
	137, 12, 137, 14, 137, 1175, 11, 137, 3, 137, 3, 137, 3, 138, 5, 138, 1180,
	10, 138, 3, 138, 3, 138, 3, 138, 3, 138, 3, 138, 2, 2, 139, 2, 4, 6, 8,
	10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44,
	46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80,
	82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112,
	114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142,
	144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172,
	174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202,
	204, 206, 208, 210, 212, 214, 216, 218, 220, 222, 224, 226, 228, 230, 232,
	234, 236, 238, 240, 242, 244, 246, 248, 250, 252, 254, 256, 258, 260, 262,
	264, 266, 268, 270, 272, 274, 2, 10, 4, 2, 88, 88, 96, 96, 4, 2, 56, 56,
	61, 61, 3, 2, 35, 36, 3, 2, 27, 28, 5, 2, 23, 23, 26, 26, 33, 33, 4, 2,
	22, 22, 27, 28, 4, 2, 3, 3, 5, 12, 5, 2, 38, 38, 59, 59, 89, 89, 2, 1203,
	2, 279, 3, 2, 2, 2, 4, 320, 3, 2, 2, 2, 6, 322, 3, 2, 2, 2, 8, 334, 3,
	2, 2, 2, 10, 336, 3, 2, 2, 2, 12, 342, 3, 2, 2, 2, 14, 348, 3, 2, 2, 2,
	16, 358, 3, 2, 2, 2, 18, 382, 3, 2, 2, 2, 20, 384, 3, 2, 2, 2, 22, 393,
	3, 2, 2, 2, 24, 396, 3, 2, 2, 2, 26, 410, 3, 2, 2, 2, 28, 413, 3, 2, 2,
	2, 30, 418, 3, 2, 2, 2, 32, 422, 3, 2, 2, 2, 34, 435, 3, 2, 2, 2, 36, 446,
	3, 2, 2, 2, 38, 464, 3, 2, 2, 2, 40, 477, 3, 2, 2, 2, 42, 482, 3, 2, 2,
	2, 44, 484, 3, 2, 2, 2, 46, 489, 3, 2, 2, 2, 48, 501, 3, 2, 2, 2, 50, 509,
	3, 2, 2, 2, 52, 513, 3, 2, 2, 2, 54, 515, 3, 2, 2, 2, 56, 531, 3, 2, 2,
	2, 58, 533, 3, 2, 2, 2, 60, 535, 3, 2, 2, 2, 62, 543, 3, 2, 2, 2, 64, 551,
	3, 2, 2, 2, 66, 559, 3, 2, 2, 2, 68, 567, 3, 2, 2, 2, 70, 575, 3, 2, 2,
	2, 72, 587, 3, 2, 2, 2, 74, 589, 3, 2, 2, 2, 76, 597, 3, 2, 2, 2, 78, 599,
	3, 2, 2, 2, 80, 601, 3, 2, 2, 2, 82, 611, 3, 2, 2, 2, 84, 613, 3, 2, 2,
	2, 86, 618, 3, 2, 2, 2, 88, 623, 3, 2, 2, 2, 90, 634, 3, 2, 2, 2, 92, 640,
	3, 2, 2, 2, 94, 645, 3, 2, 2, 2, 96, 647, 3, 2, 2, 2, 98, 657, 3, 2, 2,
	2, 100, 659, 3, 2, 2, 2, 102, 661, 3, 2, 2, 2, 104, 667, 3, 2, 2, 2, 106,
	671, 3, 2, 2, 2, 108, 676, 3, 2, 2, 2, 110, 678, 3, 2, 2, 2, 112, 680,
	3, 2, 2, 2, 114, 682, 3, 2, 2, 2, 116, 688, 3, 2, 2, 2, 118, 690, 3, 2,
	2, 2, 120, 693, 3, 2, 2, 2, 122, 696, 3, 2, 2, 2, 124, 700, 3, 2, 2, 2,
	126, 702, 3, 2, 2, 2, 128, 704, 3, 2, 2, 2, 130, 706, 3, 2, 2, 2, 132,
	708, 3, 2, 2, 2, 134, 710, 3, 2, 2, 2, 136, 712, 3, 2, 2, 2, 138, 719,
	3, 2, 2, 2, 140, 723, 3, 2, 2, 2, 142, 727, 3, 2, 2, 2, 144, 742, 3, 2,
	2, 2, 146, 745, 3, 2, 2, 2, 148, 750, 3, 2, 2, 2, 150, 763, 3, 2, 2, 2,
	152, 765, 3, 2, 2, 2, 154, 768, 3, 2, 2, 2, 156, 781, 3, 2, 2, 2, 158,
	795, 3, 2, 2, 2, 160, 803, 3, 2, 2, 2, 162, 811, 3, 2, 2, 2, 164, 813,
	3, 2, 2, 2, 166, 819, 3, 2, 2, 2, 168, 825, 3, 2, 2, 2, 170, 827, 3, 2,
	2, 2, 172, 839, 3, 2, 2, 2, 174, 850, 3, 2, 2, 2, 176, 854, 3, 2, 2, 2,
	178, 869, 3, 2, 2, 2, 180, 871, 3, 2, 2, 2, 182, 875, 3, 2, 2, 2, 184,
	877, 3, 2, 2, 2, 186, 889, 3, 2, 2, 2, 188, 905, 3, 2, 2, 2, 190, 907,
	3, 2, 2, 2, 192, 914, 3, 2, 2, 2, 194, 916, 3, 2, 2, 2, 196, 922, 3, 2,
	2, 2, 198, 924, 3, 2, 2, 2, 200, 930, 3, 2, 2, 2, 202, 932, 3, 2, 2, 2,
	204, 936, 3, 2, 2, 2, 206, 940, 3, 2, 2, 2, 208, 956, 3, 2, 2, 2, 210,
	958, 3, 2, 2, 2, 212, 973, 3, 2, 2, 2, 214, 980, 3, 2, 2, 2, 216, 982,
	3, 2, 2, 2, 218, 985, 3, 2, 2, 2, 220, 988, 3, 2, 2, 2, 222, 1001, 3, 2,
	2, 2, 224, 1003, 3, 2, 2, 2, 226, 1006, 3, 2, 2, 2, 228, 1011, 3, 2, 2,
	2, 230, 1019, 3, 2, 2, 2, 232, 1028, 3, 2, 2, 2, 234, 1034, 3, 2, 2, 2,
	236, 1055, 3, 2, 2, 2, 238, 1057, 3, 2, 2, 2, 240, 1063, 3, 2, 2, 2, 242,
	1065, 3, 2, 2, 2, 244, 1072, 3, 2, 2, 2, 246, 1076, 3, 2, 2, 2, 248, 1080,
	3, 2, 2, 2, 250, 1084, 3, 2, 2, 2, 252, 1087, 3, 2, 2, 2, 254, 1100, 3,
	2, 2, 2, 256, 1103, 3, 2, 2, 2, 258, 1106, 3, 2, 2, 2, 260, 1122, 3, 2,
	2, 2, 262, 1124, 3, 2, 2, 2, 264, 1134, 3, 2, 2, 2, 266, 1147, 3, 2, 2,
	2, 268, 1150, 3, 2, 2, 2, 270, 1155, 3, 2, 2, 2, 272, 1168, 3, 2, 2, 2,
	274, 1179, 3, 2, 2, 2, 276, 278, 5, 198, 100, 2, 277, 276, 3, 2, 2, 2,
	278, 281, 3, 2, 2, 2, 279, 277, 3, 2, 2, 2, 279, 280, 3, 2, 2, 2, 280,
	283, 3, 2, 2, 2, 281, 279, 3, 2, 2, 2, 282, 284, 5, 4, 3, 2, 283, 282,
	3, 2, 2, 2, 284, 285, 3, 2, 2, 2, 285, 283, 3, 2, 2, 2, 285, 286, 3, 2,
	2, 2, 286, 3, 3, 2, 2, 2, 287, 288, 5, 82, 42, 2, 288, 289, 7, 13, 2, 2,
	289, 321, 3, 2, 2, 2, 290, 291, 5, 54, 28, 2, 291, 292, 7, 13, 2, 2, 292,
	321, 3, 2, 2, 2, 293, 294, 5, 170, 86, 2, 294, 295, 7, 13, 2, 2, 295, 321,
	3, 2, 2, 2, 296, 297, 5, 8, 5, 2, 297, 298, 7, 13, 2, 2, 298, 321, 3, 2,
	2, 2, 299, 300, 5, 6, 4, 2, 300, 301, 7, 13, 2, 2, 301, 321, 3, 2, 2, 2,
	302, 303, 5, 26, 14, 2, 303, 304, 7, 13, 2, 2, 304, 321, 3, 2, 2, 2, 305,
	306, 5, 202, 102, 2, 306, 307, 7, 13, 2, 2, 307, 321, 3, 2, 2, 2, 308,
	309, 5, 204, 103, 2, 309, 310, 7, 13, 2, 2, 310, 321, 3, 2, 2, 2, 311,
	312, 5, 266, 134, 2, 312, 313, 7, 13, 2, 2, 313, 321, 3, 2, 2, 2, 314,
	315, 5, 222, 112, 2, 315, 316, 7, 13, 2, 2, 316, 321, 3, 2, 2, 2, 317,
	318, 5, 250, 126, 2, 318, 319, 7, 13, 2, 2, 319, 321, 3, 2, 2, 2, 320,
	287, 3, 2, 2, 2, 320, 290, 3, 2, 2, 2, 320, 293, 3, 2, 2, 2, 320, 296,
	3, 2, 2, 2, 320, 299, 3, 2, 2, 2, 320, 302, 3, 2, 2, 2, 320, 305, 3, 2,
	2, 2, 320, 308, 3, 2, 2, 2, 320, 311, 3, 2, 2, 2, 320, 314, 3, 2, 2, 2,
	320, 317, 3, 2, 2, 2, 321, 5, 3, 2, 2, 2, 322, 323, 7, 75, 2, 2, 323, 324,
	7, 100, 2, 2, 324, 326, 7, 16, 2, 2, 325, 327, 5, 4, 3, 2, 326, 325, 3,
	2, 2, 2, 327, 328, 3, 2, 2, 2, 328, 326, 3, 2, 2, 2, 328, 329, 3, 2, 2,
	2, 329, 330, 3, 2, 2, 2, 330, 331, 7, 17, 2, 2, 331, 7, 3, 2, 2, 2, 332,
	335, 5, 10, 6, 2, 333, 335, 5, 12, 7, 2, 334, 332, 3, 2, 2, 2, 334, 333,
	3, 2, 2, 2, 335, 9, 3, 2, 2, 2, 336, 337, 5, 14, 8, 2, 337, 338, 7, 16,
	2, 2, 338, 339, 5, 16, 9, 2, 339, 340, 7, 17, 2, 2, 340, 11, 3, 2, 2, 2,
	341, 343, 9, 2, 2, 2, 342, 341, 3, 2, 2, 2, 342, 343, 3, 2, 2, 2, 343,
	344, 3, 2, 2, 2, 344, 345, 7, 98, 2, 2, 345, 346, 7, 100, 2, 2, 346, 13,
	3, 2, 2, 2, 347, 349, 9, 2, 2, 2, 348, 347, 3, 2, 2, 2, 348, 349, 3, 2,
	2, 2, 349, 350, 3, 2, 2, 2, 350, 351, 7, 98, 2, 2, 351, 353, 7, 100, 2,
	2, 352, 354, 5, 20, 11, 2, 353, 352, 3, 2, 2, 2, 353, 354, 3, 2, 2, 2,
	354, 15, 3, 2, 2, 2, 355, 357, 5, 18, 10, 2, 356, 355, 3, 2, 2, 2, 357,
	360, 3, 2, 2, 2, 358, 356, 3, 2, 2, 2, 358, 359, 3, 2, 2, 2, 359, 17, 3,
	2, 2, 2, 360, 358, 3, 2, 2, 2, 361, 362, 5, 82, 42, 2, 362, 363, 7, 13,
	2, 2, 363, 383, 3, 2, 2, 2, 364, 365, 5, 54, 28, 2, 365, 366, 7, 13, 2,
	2, 366, 383, 3, 2, 2, 2, 367, 368, 5, 170, 86, 2, 368, 369, 7, 13, 2, 2,
	369, 383, 3, 2, 2, 2, 370, 371, 5, 168, 85, 2, 371, 372, 7, 13, 2, 2, 372,
	383, 3, 2, 2, 2, 373, 374, 5, 172, 87, 2, 374, 375, 7, 13, 2, 2, 375, 383,
	3, 2, 2, 2, 376, 377, 5, 202, 102, 2, 377, 378, 7, 13, 2, 2, 378, 383,
	3, 2, 2, 2, 379, 380, 5, 204, 103, 2, 380, 381, 7, 13, 2, 2, 381, 383,
	3, 2, 2, 2, 382, 361, 3, 2, 2, 2, 382, 364, 3, 2, 2, 2, 382, 367, 3, 2,
	2, 2, 382, 370, 3, 2, 2, 2, 382, 373, 3, 2, 2, 2, 382, 376, 3, 2, 2, 2,
	382, 379, 3, 2, 2, 2, 383, 19, 3, 2, 2, 2, 384, 385, 7, 14, 2, 2, 385,
	390, 5, 22, 12, 2, 386, 387, 7, 15, 2, 2, 387, 389, 5, 22, 12, 2, 388,
	386, 3, 2, 2, 2, 389, 392, 3, 2, 2, 2, 390, 388, 3, 2, 2, 2, 390, 391,
	3, 2, 2, 2, 391, 21, 3, 2, 2, 2, 392, 390, 3, 2, 2, 2, 393, 394, 5, 24,
	13, 2, 394, 23, 3, 2, 2, 2, 395, 397, 7, 34, 2, 2, 396, 395, 3, 2, 2, 2,
	396, 397, 3, 2, 2, 2, 397, 398, 3, 2, 2, 2, 398, 403, 7, 100, 2, 2, 399,
	400, 7, 34, 2, 2, 400, 402, 7, 100, 2, 2, 401, 399, 3, 2, 2, 2, 402, 405,
	3, 2, 2, 2, 403, 401, 3, 2, 2, 2, 403, 404, 3, 2, 2, 2, 404, 25, 3, 2,
	2, 2, 405, 403, 3, 2, 2, 2, 406, 411, 5, 34, 18, 2, 407, 411, 5, 32, 17,
	2, 408, 411, 5, 30, 16, 2, 409, 411, 5, 28, 15, 2, 410, 406, 3, 2, 2, 2,
	410, 407, 3, 2, 2, 2, 410, 408, 3, 2, 2, 2, 410, 409, 3, 2, 2, 2, 411,
	27, 3, 2, 2, 2, 412, 414, 7, 88, 2, 2, 413, 412, 3, 2, 2, 2, 413, 414,
	3, 2, 2, 2, 414, 415, 3, 2, 2, 2, 415, 416, 7, 73, 2, 2, 416, 417, 7, 100,
	2, 2, 417, 29, 3, 2, 2, 2, 418, 419, 7, 73, 2, 2, 419, 420, 7, 100, 2,
	2, 420, 421, 5, 86, 44, 2, 421, 31, 3, 2, 2, 2, 422, 423, 7, 88, 2, 2,
	423, 424, 7, 73, 2, 2, 424, 425, 7, 100, 2, 2, 425, 426, 5, 38, 20, 2,
	426, 430, 7, 16, 2, 2, 427, 429, 5, 18, 10, 2, 428, 427, 3, 2, 2, 2, 429,
	432, 3, 2, 2, 2, 430, 428, 3, 2, 2, 2, 430, 431, 3, 2, 2, 2, 431, 433,
	3, 2, 2, 2, 432, 430, 3, 2, 2, 2, 433, 434, 7, 17, 2, 2, 434, 33, 3, 2,
	2, 2, 435, 436, 5, 36, 19, 2, 436, 440, 7, 16, 2, 2, 437, 439, 5, 42, 22,
	2, 438, 437, 3, 2, 2, 2, 439, 442, 3, 2, 2, 2, 440, 438, 3, 2, 2, 2, 440,
	441, 3, 2, 2, 2, 441, 443, 3, 2, 2, 2, 442, 440, 3, 2, 2, 2, 443, 444,
	7, 17, 2, 2, 444, 35, 3, 2, 2, 2, 445, 447, 7, 46, 2, 2, 446, 445, 3, 2,
	2, 2, 446, 447, 3, 2, 2, 2, 447, 448, 3, 2, 2, 2, 448, 449, 7, 73, 2, 2,
	449, 450, 7, 100, 2, 2, 450, 451, 5, 38, 20, 2, 451, 37, 3, 2, 2, 2, 452,
	454, 7, 14, 2, 2, 453, 455, 7, 77, 2, 2, 454, 453, 3, 2, 2, 2, 454, 455,
	3, 2, 2, 2, 455, 456, 3, 2, 2, 2, 456, 461, 5, 40, 21, 2, 457, 458, 7,
	15, 2, 2, 458, 460, 5, 40, 21, 2, 459, 457, 3, 2, 2, 2, 460, 463, 3, 2,
	2, 2, 461, 459, 3, 2, 2, 2, 461, 462, 3, 2, 2, 2, 462, 465, 3, 2, 2, 2,
	463, 461, 3, 2, 2, 2, 464, 452, 3, 2, 2, 2, 464, 465, 3, 2, 2, 2, 465,
	475, 3, 2, 2, 2, 466, 467, 7, 74, 2, 2, 467, 472, 5, 22, 12, 2, 468, 469,
	7, 15, 2, 2, 469, 471, 5, 22, 12, 2, 470, 468, 3, 2, 2, 2, 471, 474, 3,
	2, 2, 2, 472, 470, 3, 2, 2, 2, 472, 473, 3, 2, 2, 2, 473, 476, 3, 2, 2,
	2, 474, 472, 3, 2, 2, 2, 475, 466, 3, 2, 2, 2, 475, 476, 3, 2, 2, 2, 476,
	39, 3, 2, 2, 2, 477, 478, 5, 24, 13, 2, 478, 41, 3, 2, 2, 2, 479, 483,
	5, 18, 10, 2, 480, 483, 5, 44, 23, 2, 481, 483, 5, 46, 24, 2, 482, 479,
	3, 2, 2, 2, 482, 480, 3, 2, 2, 2, 482, 481, 3, 2, 2, 2, 483, 43, 3, 2,
	2, 2, 484, 485, 9, 3, 2, 2, 485, 486, 5, 86, 44, 2, 486, 487, 5, 96, 49,
	2, 487, 488, 7, 13, 2, 2, 488, 45, 3, 2, 2, 2, 489, 490, 7, 68, 2, 2, 490,
	491, 7, 100, 2, 2, 491, 493, 7, 18, 2, 2, 492, 494, 5, 48, 25, 2, 493,
	492, 3, 2, 2, 2, 493, 494, 3, 2, 2, 2, 494, 495, 3, 2, 2, 2, 495, 497,
	7, 19, 2, 2, 496, 498, 5, 184, 93, 2, 497, 496, 3, 2, 2, 2, 497, 498, 3,
	2, 2, 2, 498, 499, 3, 2, 2, 2, 499, 500, 7, 13, 2, 2, 500, 47, 3, 2, 2,
	2, 501, 506, 5, 50, 26, 2, 502, 503, 7, 15, 2, 2, 503, 505, 5, 50, 26,
	2, 504, 502, 3, 2, 2, 2, 505, 508, 3, 2, 2, 2, 506, 504, 3, 2, 2, 2, 506,
	507, 3, 2, 2, 2, 507, 49, 3, 2, 2, 2, 508, 506, 3, 2, 2, 2, 509, 510, 5,
	52, 27, 2, 510, 511, 5, 188, 95, 2, 511, 512, 5, 100, 51, 2, 512, 51, 3,
	2, 2, 2, 513, 514, 7, 59, 2, 2, 514, 53, 3, 2, 2, 2, 515, 516, 7, 71, 2,
	2, 516, 517, 5, 56, 29, 2, 517, 518, 7, 100, 2, 2, 518, 519, 7, 32, 2,
	2, 519, 520, 5, 58, 30, 2, 520, 55, 3, 2, 2, 2, 521, 532, 5, 106, 54, 2,
	522, 532, 5, 124, 63, 2, 523, 532, 5, 126, 64, 2, 524, 532, 5, 128, 65,
	2, 525, 532, 5, 104, 53, 2, 526, 532, 5, 160, 81, 2, 527, 532, 5, 162,
	82, 2, 528, 532, 5, 192, 97, 2, 529, 532, 5, 24, 13, 2, 530, 532, 5, 130,
	66, 2, 531, 521, 3, 2, 2, 2, 531, 522, 3, 2, 2, 2, 531, 523, 3, 2, 2, 2,
	531, 524, 3, 2, 2, 2, 531, 525, 3, 2, 2, 2, 531, 526, 3, 2, 2, 2, 531,
	527, 3, 2, 2, 2, 531, 528, 3, 2, 2, 2, 531, 529, 3, 2, 2, 2, 531, 530,
	3, 2, 2, 2, 532, 57, 3, 2, 2, 2, 533, 534, 5, 60, 31, 2, 534, 59, 3, 2,
	2, 2, 535, 540, 5, 62, 32, 2, 536, 537, 7, 31, 2, 2, 537, 539, 5, 62, 32,
	2, 538, 536, 3, 2, 2, 2, 539, 542, 3, 2, 2, 2, 540, 538, 3, 2, 2, 2, 540,
	541, 3, 2, 2, 2, 541, 61, 3, 2, 2, 2, 542, 540, 3, 2, 2, 2, 543, 548, 5,
	64, 33, 2, 544, 545, 7, 29, 2, 2, 545, 547, 5, 64, 33, 2, 546, 544, 3,
	2, 2, 2, 547, 550, 3, 2, 2, 2, 548, 546, 3, 2, 2, 2, 548, 549, 3, 2, 2,
	2, 549, 63, 3, 2, 2, 2, 550, 548, 3, 2, 2, 2, 551, 556, 5, 66, 34, 2, 552,
	553, 7, 30, 2, 2, 553, 555, 5, 66, 34, 2, 554, 552, 3, 2, 2, 2, 555, 558,
	3, 2, 2, 2, 556, 554, 3, 2, 2, 2, 556, 557, 3, 2, 2, 2, 557, 65, 3, 2,
	2, 2, 558, 556, 3, 2, 2, 2, 559, 564, 5, 68, 35, 2, 560, 561, 9, 4, 2,
	2, 561, 563, 5, 68, 35, 2, 562, 560, 3, 2, 2, 2, 563, 566, 3, 2, 2, 2,
	564, 562, 3, 2, 2, 2, 564, 565, 3, 2, 2, 2, 565, 67, 3, 2, 2, 2, 566, 564,
	3, 2, 2, 2, 567, 572, 5, 70, 36, 2, 568, 569, 9, 5, 2, 2, 569, 571, 5,
	70, 36, 2, 570, 568, 3, 2, 2, 2, 571, 574, 3, 2, 2, 2, 572, 570, 3, 2,
	2, 2, 572, 573, 3, 2, 2, 2, 573, 69, 3, 2, 2, 2, 574, 572, 3, 2, 2, 2,
	575, 580, 5, 72, 37, 2, 576, 577, 9, 6, 2, 2, 577, 579, 5, 72, 37, 2, 578,
	576, 3, 2, 2, 2, 579, 582, 3, 2, 2, 2, 580, 578, 3, 2, 2, 2, 580, 581,
	3, 2, 2, 2, 581, 71, 3, 2, 2, 2, 582, 580, 3, 2, 2, 2, 583, 584, 5, 74,
	38, 2, 584, 585, 5, 76, 39, 2, 585, 588, 3, 2, 2, 2, 586, 588, 5, 76, 39,
	2, 587, 583, 3, 2, 2, 2, 587, 586, 3, 2, 2, 2, 588, 73, 3, 2, 2, 2, 589,
	590, 9, 7, 2, 2, 590, 75, 3, 2, 2, 2, 591, 598, 5, 24, 13, 2, 592, 598,
	5, 78, 40, 2, 593, 594, 7, 18, 2, 2, 594, 595, 5, 58, 30, 2, 595, 596,
	7, 19, 2, 2, 596, 598, 3, 2, 2, 2, 597, 591, 3, 2, 2, 2, 597, 592, 3, 2,
	2, 2, 597, 593, 3, 2, 2, 2, 598, 77, 3, 2, 2, 2, 599, 600, 9, 8, 2, 2,
	600, 79, 3, 2, 2, 2, 601, 602, 5, 58, 30, 2, 602, 81, 3, 2, 2, 2, 603,
	604, 7, 43, 2, 2, 604, 612, 5, 84, 43, 2, 605, 612, 5, 136, 69, 2, 606,
	612, 5, 142, 72, 2, 607, 612, 5, 154, 78, 2, 608, 609, 7, 51, 2, 2, 609,
	612, 5, 100, 51, 2, 610, 612, 5, 196, 99, 2, 611, 603, 3, 2, 2, 2, 611,
	605, 3, 2, 2, 2, 611, 606, 3, 2, 2, 2, 611, 607, 3, 2, 2, 2, 611, 608,
	3, 2, 2, 2, 611, 610, 3, 2, 2, 2, 612, 83, 3, 2, 2, 2, 613, 614, 5, 86,
	44, 2, 614, 615, 5, 96, 49, 2, 615, 85, 3, 2, 2, 2, 616, 619, 5, 88, 45,
	2, 617, 619, 5, 94, 48, 2, 618, 616, 3, 2, 2, 2, 618, 617, 3, 2, 2, 2,
	619, 87, 3, 2, 2, 2, 620, 624, 5, 90, 46, 2, 621, 624, 5, 92, 47, 2, 622,
	624, 5, 24, 13, 2, 623, 620, 3, 2, 2, 2, 623, 621, 3, 2, 2, 2, 623, 622,
	3, 2, 2, 2, 624, 89, 3, 2, 2, 2, 625, 635, 5, 104, 53, 2, 626, 635, 5,
	106, 54, 2, 627, 635, 5, 124, 63, 2, 628, 635, 5, 126, 64, 2, 629, 635,
	5, 128, 65, 2, 630, 635, 5, 130, 66, 2, 631, 635, 5, 132, 67, 2, 632, 635,
	5, 134, 68, 2, 633, 635, 5, 194, 98, 2, 634, 625, 3, 2, 2, 2, 634, 626,
	3, 2, 2, 2, 634, 627, 3, 2, 2, 2, 634, 628, 3, 2, 2, 2, 634, 629, 3, 2,
	2, 2, 634, 630, 3, 2, 2, 2, 634, 631, 3, 2, 2, 2, 634, 632, 3, 2, 2, 2,
	634, 633, 3, 2, 2, 2, 635, 91, 3, 2, 2, 2, 636, 641, 5, 158, 80, 2, 637,
	641, 5, 160, 81, 2, 638, 641, 5, 162, 82, 2, 639, 641, 5, 190, 96, 2, 640,
	636, 3, 2, 2, 2, 640, 637, 3, 2, 2, 2, 640, 638, 3, 2, 2, 2, 640, 639,
	3, 2, 2, 2, 641, 93, 3, 2, 2, 2, 642, 646, 5, 136, 69, 2, 643, 646, 5,
	142, 72, 2, 644, 646, 5, 154, 78, 2, 645, 642, 3, 2, 2, 2, 645, 643, 3,
	2, 2, 2, 645, 644, 3, 2, 2, 2, 646, 95, 3, 2, 2, 2, 647, 652, 5, 98, 50,
	2, 648, 649, 7, 15, 2, 2, 649, 651, 5, 98, 50, 2, 650, 648, 3, 2, 2, 2,
	651, 654, 3, 2, 2, 2, 652, 650, 3, 2, 2, 2, 652, 653, 3, 2, 2, 2, 653,
	97, 3, 2, 2, 2, 654, 652, 3, 2, 2, 2, 655, 658, 5, 100, 51, 2, 656, 658,
	5, 102, 52, 2, 657, 655, 3, 2, 2, 2, 657, 656, 3, 2, 2, 2, 658, 99, 3,
	2, 2, 2, 659, 660, 7, 100, 2, 2, 660, 101, 3, 2, 2, 2, 661, 662, 5, 164,
	83, 2, 662, 103, 3, 2, 2, 2, 663, 668, 7, 85, 2, 2, 664, 668, 7, 92, 2,
	2, 665, 666, 7, 63, 2, 2, 666, 668, 7, 92, 2, 2, 667, 663, 3, 2, 2, 2,
	667, 664, 3, 2, 2, 2, 667, 665, 3, 2, 2, 2, 668, 105, 3, 2, 2, 2, 669,
	672, 5, 108, 55, 2, 670, 672, 5, 116, 59, 2, 671, 669, 3, 2, 2, 2, 671,
	670, 3, 2, 2, 2, 672, 107, 3, 2, 2, 2, 673, 677, 5, 110, 56, 2, 674, 677,
	5, 112, 57, 2, 675, 677, 5, 114, 58, 2, 676, 673, 3, 2, 2, 2, 676, 674,
	3, 2, 2, 2, 676, 675, 3, 2, 2, 2, 677, 109, 3, 2, 2, 2, 678, 679, 7, 62,
	2, 2, 679, 111, 3, 2, 2, 2, 680, 681, 7, 63, 2, 2, 681, 113, 3, 2, 2, 2,
	682, 683, 7, 63, 2, 2, 683, 684, 7, 63, 2, 2, 684, 115, 3, 2, 2, 2, 685,
	689, 5, 118, 60, 2, 686, 689, 5, 120, 61, 2, 687, 689, 5, 122, 62, 2, 688,
	685, 3, 2, 2, 2, 688, 686, 3, 2, 2, 2, 688, 687, 3, 2, 2, 2, 689, 117,
	3, 2, 2, 2, 690, 691, 7, 78, 2, 2, 691, 692, 7, 62, 2, 2, 692, 119, 3,
	2, 2, 2, 693, 694, 7, 78, 2, 2, 694, 695, 7, 63, 2, 2, 695, 121, 3, 2,
	2, 2, 696, 697, 7, 78, 2, 2, 697, 698, 7, 63, 2, 2, 698, 699, 7, 63, 2,
	2, 699, 123, 3, 2, 2, 2, 700, 701, 7, 83, 2, 2, 701, 125, 3, 2, 2, 2, 702,
	703, 7, 58, 2, 2, 703, 127, 3, 2, 2, 2, 704, 705, 7, 86, 2, 2, 705, 129,
	3, 2, 2, 2, 706, 707, 7, 47, 2, 2, 707, 131, 3, 2, 2, 2, 708, 709, 7, 82,
	2, 2, 709, 133, 3, 2, 2, 2, 710, 711, 7, 76, 2, 2, 711, 135, 3, 2, 2, 2,
	712, 713, 7, 50, 2, 2, 713, 714, 7, 100, 2, 2, 714, 715, 7, 16, 2, 2, 715,
	716, 5, 138, 70, 2, 716, 717, 7, 17, 2, 2, 717, 137, 3, 2, 2, 2, 718, 720,
	5, 140, 71, 2, 719, 718, 3, 2, 2, 2, 720, 721, 3, 2, 2, 2, 721, 719, 3,
	2, 2, 2, 721, 722, 3, 2, 2, 2, 722, 139, 3, 2, 2, 2, 723, 724, 5, 86, 44,
	2, 724, 725, 5, 96, 49, 2, 725, 726, 7, 13, 2, 2, 726, 141, 3, 2, 2, 2,
	727, 728, 7, 80, 2, 2, 728, 729, 7, 100, 2, 2, 729, 730, 7, 41, 2, 2, 730,
	731, 7, 18, 2, 2, 731, 732, 5, 144, 73, 2, 732, 733, 7, 19, 2, 2, 733,
	734, 7, 16, 2, 2, 734, 735, 5, 146, 74, 2, 735, 736, 7, 17, 2, 2, 736,
	143, 3, 2, 2, 2, 737, 743, 5, 106, 54, 2, 738, 743, 5, 124, 63, 2, 739,
	743, 5, 128, 65, 2, 740, 743, 5, 154, 78, 2, 741, 743, 5, 24, 13, 2, 742,
	737, 3, 2, 2, 2, 742, 738, 3, 2, 2, 2, 742, 739, 3, 2, 2, 2, 742, 740,
	3, 2, 2, 2, 742, 741, 3, 2, 2, 2, 743, 145, 3, 2, 2, 2, 744, 746, 5, 148,
	75, 2, 745, 744, 3, 2, 2, 2, 746, 747, 3, 2, 2, 2, 747, 745, 3, 2, 2, 2,
	747, 748, 3, 2, 2, 2, 748, 147, 3, 2, 2, 2, 749, 751, 5, 150, 76, 2, 750,
	749, 3, 2, 2, 2, 751, 752, 3, 2, 2, 2, 752, 750, 3, 2, 2, 2, 752, 753,
	3, 2, 2, 2, 753, 754, 3, 2, 2, 2, 754, 755, 5, 152, 77, 2, 755, 756, 7,
	13, 2, 2, 756, 149, 3, 2, 2, 2, 757, 758, 7, 84, 2, 2, 758, 759, 5, 58,
	30, 2, 759, 760, 7, 14, 2, 2, 760, 764, 3, 2, 2, 2, 761, 762, 7, 60, 2,
	2, 762, 764, 7, 14, 2, 2, 763, 757, 3, 2, 2, 2, 763, 761, 3, 2, 2, 2, 764,
	151, 3, 2, 2, 2, 765, 766, 5, 86, 44, 2, 766, 767, 5, 98, 50, 2, 767, 153,
	3, 2, 2, 2, 768, 769, 7, 64, 2, 2, 769, 770, 7, 100, 2, 2, 770, 771, 7,
	16, 2, 2, 771, 776, 5, 156, 79, 2, 772, 773, 7, 15, 2, 2, 773, 775, 5,
	156, 79, 2, 774, 772, 3, 2, 2, 2, 775, 778, 3, 2, 2, 2, 776, 774, 3, 2,
	2, 2, 776, 777, 3, 2, 2, 2, 777, 779, 3, 2, 2, 2, 778, 776, 3, 2, 2, 2,
	779, 780, 7, 17, 2, 2, 780, 155, 3, 2, 2, 2, 781, 782, 7, 100, 2, 2, 782,
	157, 3, 2, 2, 2, 783, 784, 7, 48, 2, 2, 784, 785, 7, 24, 2, 2, 785, 786,
	5, 88, 45, 2, 786, 787, 7, 15, 2, 2, 787, 788, 5, 80, 41, 2, 788, 789,
	7, 25, 2, 2, 789, 796, 3, 2, 2, 2, 790, 791, 7, 48, 2, 2, 791, 792, 7,
	24, 2, 2, 792, 793, 5, 88, 45, 2, 793, 794, 7, 25, 2, 2, 794, 796, 3, 2,
	2, 2, 795, 783, 3, 2, 2, 2, 795, 790, 3, 2, 2, 2, 796, 159, 3, 2, 2, 2,
	797, 798, 7, 40, 2, 2, 798, 799, 7, 24, 2, 2, 799, 800, 5, 80, 41, 2, 800,
	801, 7, 25, 2, 2, 801, 804, 3, 2, 2, 2, 802, 804, 7, 40, 2, 2, 803, 797,
	3, 2, 2, 2, 803, 802, 3, 2, 2, 2, 804, 161, 3, 2, 2, 2, 805, 806, 7, 65,
	2, 2, 806, 807, 7, 24, 2, 2, 807, 808, 5, 80, 41, 2, 808, 809, 7, 25, 2,
	2, 809, 812, 3, 2, 2, 2, 810, 812, 7, 65, 2, 2, 811, 805, 3, 2, 2, 2, 811,
	810, 3, 2, 2, 2, 812, 163, 3, 2, 2, 2, 813, 815, 7, 100, 2, 2, 814, 816,
	5, 166, 84, 2, 815, 814, 3, 2, 2, 2, 816, 817, 3, 2, 2, 2, 817, 815, 3,
	2, 2, 2, 817, 818, 3, 2, 2, 2, 818, 165, 3, 2, 2, 2, 819, 820, 7, 20, 2,
	2, 820, 821, 5, 80, 41, 2, 821, 822, 7, 21, 2, 2, 822, 167, 3, 2, 2, 2,
	823, 826, 5, 206, 104, 2, 824, 826, 5, 210, 106, 2, 825, 823, 3, 2, 2,
	2, 825, 824, 3, 2, 2, 2, 826, 169, 3, 2, 2, 2, 827, 828, 7, 69, 2, 2, 828,
	829, 7, 100, 2, 2, 829, 833, 7, 16, 2, 2, 830, 832, 5, 140, 71, 2, 831,
	830, 3, 2, 2, 2, 832, 835, 3, 2, 2, 2, 833, 831, 3, 2, 2, 2, 833, 834,
	3, 2, 2, 2, 834, 836, 3, 2, 2, 2, 835, 833, 3, 2, 2, 2, 836, 837, 7, 17,
	2, 2, 837, 171, 3, 2, 2, 2, 838, 840, 5, 174, 88, 2, 839, 838, 3, 2, 2,
	2, 839, 840, 3, 2, 2, 2, 840, 841, 3, 2, 2, 2, 841, 842, 5, 176, 89, 2,
	842, 843, 7, 100, 2, 2, 843, 845, 5, 178, 90, 2, 844, 846, 5, 184, 93,
	2, 845, 844, 3, 2, 2, 2, 845, 846, 3, 2, 2, 2, 846, 848, 3, 2, 2, 2, 847,
	849, 5, 186, 94, 2, 848, 847, 3, 2, 2, 2, 848, 849, 3, 2, 2, 2, 849, 173,
	3, 2, 2, 2, 850, 851, 7, 81, 2, 2, 851, 175, 3, 2, 2, 2, 852, 855, 5, 188,
	95, 2, 853, 855, 7, 55, 2, 2, 854, 852, 3, 2, 2, 2, 854, 853, 3, 2, 2,
	2, 855, 177, 3, 2, 2, 2, 856, 857, 7, 18, 2, 2, 857, 862, 5, 180, 91, 2,
	858, 859, 7, 15, 2, 2, 859, 861, 5, 180, 91, 2, 860, 858, 3, 2, 2, 2, 861,
	864, 3, 2, 2, 2, 862, 860, 3, 2, 2, 2, 862, 863, 3, 2, 2, 2, 863, 865,
	3, 2, 2, 2, 864, 862, 3, 2, 2, 2, 865, 866, 7, 19, 2, 2, 866, 870, 3, 2,
	2, 2, 867, 868, 7, 18, 2, 2, 868, 870, 7, 19, 2, 2, 869, 856, 3, 2, 2,
	2, 869, 867, 3, 2, 2, 2, 870, 179, 3, 2, 2, 2, 871, 872, 5, 182, 92, 2,
	872, 873, 5, 188, 95, 2, 873, 874, 5, 100, 51, 2, 874, 181, 3, 2, 2, 2,
	875, 876, 9, 9, 2, 2, 876, 183, 3, 2, 2, 2, 877, 878, 7, 54, 2, 2, 878,
	879, 7, 18, 2, 2, 879, 884, 5, 24, 13, 2, 880, 881, 7, 15, 2, 2, 881, 883,
	5, 24, 13, 2, 882, 880, 3, 2, 2, 2, 883, 886, 3, 2, 2, 2, 884, 882, 3,
	2, 2, 2, 884, 885, 3, 2, 2, 2, 885, 887, 3, 2, 2, 2, 886, 884, 3, 2, 2,
	2, 887, 888, 7, 19, 2, 2, 888, 185, 3, 2, 2, 2, 889, 890, 7, 66, 2, 2,
	890, 891, 7, 18, 2, 2, 891, 896, 7, 11, 2, 2, 892, 893, 7, 15, 2, 2, 893,
	895, 7, 11, 2, 2, 894, 892, 3, 2, 2, 2, 895, 898, 3, 2, 2, 2, 896, 894,
	3, 2, 2, 2, 896, 897, 3, 2, 2, 2, 897, 899, 3, 2, 2, 2, 898, 896, 3, 2,
	2, 2, 899, 900, 7, 19, 2, 2, 900, 187, 3, 2, 2, 2, 901, 906, 5, 90, 46,
	2, 902, 906, 5, 160, 81, 2, 903, 906, 5, 162, 82, 2, 904, 906, 5, 24, 13,
	2, 905, 901, 3, 2, 2, 2, 905, 902, 3, 2, 2, 2, 905, 903, 3, 2, 2, 2, 905,
	904, 3, 2, 2, 2, 906, 189, 3, 2, 2, 2, 907, 908, 7, 79, 2, 2, 908, 909,
	7, 24, 2, 2, 909, 910, 5, 80, 41, 2, 910, 911, 7, 15, 2, 2, 911, 912, 5,
	80, 41, 2, 912, 913, 7, 25, 2, 2, 913, 191, 3, 2, 2, 2, 914, 915, 7, 79,
	2, 2, 915, 193, 3, 2, 2, 2, 916, 917, 7, 72, 2, 2, 917, 195, 3, 2, 2, 2,
	918, 919, 7, 50, 2, 2, 919, 923, 7, 100, 2, 2, 920, 921, 7, 80, 2, 2, 921,
	923, 7, 100, 2, 2, 922, 918, 3, 2, 2, 2, 922, 920, 3, 2, 2, 2, 923, 197,
	3, 2, 2, 2, 924, 925, 7, 49, 2, 2, 925, 926, 5, 200, 101, 2, 926, 927,
	7, 13, 2, 2, 927, 199, 3, 2, 2, 2, 928, 931, 5, 24, 13, 2, 929, 931, 7,
	11, 2, 2, 930, 928, 3, 2, 2, 2, 930, 929, 3, 2, 2, 2, 931, 201, 3, 2, 2,
	2, 932, 933, 7, 94, 2, 2, 933, 934, 5, 24, 13, 2, 934, 935, 7, 11, 2, 2,
	935, 203, 3, 2, 2, 2, 936, 937, 7, 93, 2, 2, 937, 938, 5, 24, 13, 2, 938,
	939, 7, 11, 2, 2, 939, 205, 3, 2, 2, 2, 940, 941, 7, 52, 2, 2, 941, 942,
	7, 95, 2, 2, 942, 943, 5, 188, 95, 2, 943, 944, 5, 208, 105, 2, 944, 207,
	3, 2, 2, 2, 945, 946, 5, 100, 51, 2, 946, 947, 5, 184, 93, 2, 947, 957,
	3, 2, 2, 2, 948, 953, 5, 100, 51, 2, 949, 950, 7, 15, 2, 2, 950, 952, 5,
	100, 51, 2, 951, 949, 3, 2, 2, 2, 952, 955, 3, 2, 2, 2, 953, 951, 3, 2,
	2, 2, 953, 954, 3, 2, 2, 2, 954, 957, 3, 2, 2, 2, 955, 953, 3, 2, 2, 2,
	956, 945, 3, 2, 2, 2, 956, 948, 3, 2, 2, 2, 957, 209, 3, 2, 2, 2, 958,
	959, 7, 95, 2, 2, 959, 960, 5, 188, 95, 2, 960, 961, 5, 212, 107, 2, 961,
	211, 3, 2, 2, 2, 962, 963, 5, 100, 51, 2, 963, 964, 5, 214, 108, 2, 964,
	974, 3, 2, 2, 2, 965, 970, 5, 100, 51, 2, 966, 967, 7, 15, 2, 2, 967, 969,
	5, 100, 51, 2, 968, 966, 3, 2, 2, 2, 969, 972, 3, 2, 2, 2, 970, 968, 3,
	2, 2, 2, 970, 971, 3, 2, 2, 2, 971, 974, 3, 2, 2, 2, 972, 970, 3, 2, 2,
	2, 973, 962, 3, 2, 2, 2, 973, 965, 3, 2, 2, 2, 974, 213, 3, 2, 2, 2, 975,
	977, 5, 216, 109, 2, 976, 978, 5, 218, 110, 2, 977, 976, 3, 2, 2, 2, 977,
	978, 3, 2, 2, 2, 978, 981, 3, 2, 2, 2, 979, 981, 5, 218, 110, 2, 980, 975,
	3, 2, 2, 2, 980, 979, 3, 2, 2, 2, 981, 215, 3, 2, 2, 2, 982, 983, 7, 70,
	2, 2, 983, 984, 5, 220, 111, 2, 984, 217, 3, 2, 2, 2, 985, 986, 7, 37,
	2, 2, 986, 987, 5, 220, 111, 2, 987, 219, 3, 2, 2, 2, 988, 989, 7, 18,
	2, 2, 989, 994, 5, 24, 13, 2, 990, 991, 7, 15, 2, 2, 991, 993, 5, 24, 13,
	2, 992, 990, 3, 2, 2, 2, 993, 996, 3, 2, 2, 2, 994, 992, 3, 2, 2, 2, 994,
	995, 3, 2, 2, 2, 995, 997, 3, 2, 2, 2, 996, 994, 3, 2, 2, 2, 997, 998,
	7, 19, 2, 2, 998, 221, 3, 2, 2, 2, 999, 1002, 5, 226, 114, 2, 1000, 1002,
	5, 224, 113, 2, 1001, 999, 3, 2, 2, 2, 1001, 1000, 3, 2, 2, 2, 1002, 223,
	3, 2, 2, 2, 1003, 1004, 7, 99, 2, 2, 1004, 1005, 7, 100, 2, 2, 1005, 225,
	3, 2, 2, 2, 1006, 1007, 5, 228, 115, 2, 1007, 1008, 7, 16, 2, 2, 1008,
	1009, 5, 234, 118, 2, 1009, 1010, 7, 17, 2, 2, 1010, 227, 3, 2, 2, 2, 1011,
	1012, 7, 99, 2, 2, 1012, 1014, 7, 100, 2, 2, 1013, 1015, 5, 232, 117, 2,
	1014, 1013, 3, 2, 2, 2, 1014, 1015, 3, 2, 2, 2, 1015, 1017, 3, 2, 2, 2,
	1016, 1018, 5, 230, 116, 2, 1017, 1016, 3, 2, 2, 2, 1017, 1018, 3, 2, 2,
	2, 1018, 229, 3, 2, 2, 2, 1019, 1020, 7, 74, 2, 2, 1020, 1025, 5, 24, 13,
	2, 1021, 1022, 7, 15, 2, 2, 1022, 1024, 5, 24, 13, 2, 1023, 1021, 3, 2,
	2, 2, 1024, 1027, 3, 2, 2, 2, 1025, 1023, 3, 2, 2, 2, 1025, 1026, 3, 2,
	2, 2, 1026, 231, 3, 2, 2, 2, 1027, 1025, 3, 2, 2, 2, 1028, 1029, 7, 14,
	2, 2, 1029, 1030, 5, 24, 13, 2, 1030, 233, 3, 2, 2, 2, 1031, 1033, 5, 236,
	119, 2, 1032, 1031, 3, 2, 2, 2, 1033, 1036, 3, 2, 2, 2, 1034, 1032, 3,
	2, 2, 2, 1034, 1035, 3, 2, 2, 2, 1035, 235, 3, 2, 2, 2, 1036, 1034, 3,
	2, 2, 2, 1037, 1038, 5, 238, 120, 2, 1038, 1039, 7, 13, 2, 2, 1039, 1056,
	3, 2, 2, 2, 1040, 1041, 5, 242, 122, 2, 1041, 1042, 7, 13, 2, 2, 1042,
	1056, 3, 2, 2, 2, 1043, 1044, 5, 244, 123, 2, 1044, 1045, 7, 13, 2, 2,
	1045, 1056, 3, 2, 2, 2, 1046, 1047, 5, 246, 124, 2, 1047, 1048, 7, 13,
	2, 2, 1048, 1056, 3, 2, 2, 2, 1049, 1050, 5, 248, 125, 2, 1050, 1051, 7,
	13, 2, 2, 1051, 1056, 3, 2, 2, 2, 1052, 1053, 5, 168, 85, 2, 1053, 1054,
	7, 13, 2, 2, 1054, 1056, 3, 2, 2, 2, 1055, 1037, 3, 2, 2, 2, 1055, 1040,
	3, 2, 2, 2, 1055, 1043, 3, 2, 2, 2, 1055, 1046, 3, 2, 2, 2, 1055, 1049,
	3, 2, 2, 2, 1055, 1052, 3, 2, 2, 2, 1056, 237, 3, 2, 2, 2, 1057, 1058,
	7, 90, 2, 2, 1058, 1059, 5, 240, 121, 2, 1059, 1060, 7, 100, 2, 2, 1060,
	239, 3, 2, 2, 2, 1061, 1064, 5, 24, 13, 2, 1062, 1064, 7, 76, 2, 2, 1063,
	1061, 3, 2, 2, 2, 1063, 1062, 3, 2, 2, 2, 1064, 241, 3, 2, 2, 2, 1065,
	1067, 7, 44, 2, 2, 1066, 1068, 7, 87, 2, 2, 1067, 1066, 3, 2, 2, 2, 1067,
	1068, 3, 2, 2, 2, 1068, 1069, 3, 2, 2, 2, 1069, 1070, 5, 240, 121, 2, 1070,
	1071, 7, 100, 2, 2, 1071, 243, 3, 2, 2, 2, 1072, 1073, 7, 39, 2, 2, 1073,
	1074, 5, 24, 13, 2, 1074, 1075, 7, 100, 2, 2, 1075, 245, 3, 2, 2, 2, 1076,
	1077, 7, 42, 2, 2, 1077, 1078, 5, 24, 13, 2, 1078, 1079, 7, 100, 2, 2,
	1079, 247, 3, 2, 2, 2, 1080, 1081, 7, 91, 2, 2, 1081, 1082, 5, 24, 13,
	2, 1082, 1083, 7, 100, 2, 2, 1083, 249, 3, 2, 2, 2, 1084, 1085, 5, 252,
	127, 2, 1085, 1086, 5, 258, 130, 2, 1086, 251, 3, 2, 2, 2, 1087, 1088,
	7, 67, 2, 2, 1088, 1090, 7, 100, 2, 2, 1089, 1091, 5, 254, 128, 2, 1090,
	1089, 3, 2, 2, 2, 1090, 1091, 3, 2, 2, 2, 1091, 1093, 3, 2, 2, 2, 1092,
	1094, 5, 230, 116, 2, 1093, 1092, 3, 2, 2, 2, 1093, 1094, 3, 2, 2, 2, 1094,
	1095, 3, 2, 2, 2, 1095, 1096, 7, 97, 2, 2, 1096, 1098, 5, 24, 13, 2, 1097,
	1099, 5, 256, 129, 2, 1098, 1097, 3, 2, 2, 2, 1098, 1099, 3, 2, 2, 2, 1099,
	253, 3, 2, 2, 2, 1100, 1101, 7, 14, 2, 2, 1101, 1102, 5, 24, 13, 2, 1102,
	255, 3, 2, 2, 2, 1103, 1104, 7, 45, 2, 2, 1104, 1105, 5, 24, 13, 2, 1105,
	257, 3, 2, 2, 2, 1106, 1110, 7, 16, 2, 2, 1107, 1109, 5, 260, 131, 2, 1108,
	1107, 3, 2, 2, 2, 1109, 1112, 3, 2, 2, 2, 1110, 1108, 3, 2, 2, 2, 1110,
	1111, 3, 2, 2, 2, 1111, 1113, 3, 2, 2, 2, 1112, 1110, 3, 2, 2, 2, 1113,
	1114, 7, 17, 2, 2, 1114, 259, 3, 2, 2, 2, 1115, 1123, 5, 18, 10, 2, 1116,
	1117, 5, 262, 132, 2, 1117, 1118, 7, 13, 2, 2, 1118, 1123, 3, 2, 2, 2,
	1119, 1120, 5, 264, 133, 2, 1120, 1121, 7, 13, 2, 2, 1121, 1123, 3, 2,
	2, 2, 1122, 1115, 3, 2, 2, 2, 1122, 1116, 3, 2, 2, 2, 1122, 1119, 3, 2,
	2, 2, 1123, 261, 3, 2, 2, 2, 1124, 1125, 7, 68, 2, 2, 1125, 1126, 7, 100,
	2, 2, 1126, 1128, 7, 18, 2, 2, 1127, 1129, 5, 48, 25, 2, 1128, 1127, 3,
	2, 2, 2, 1128, 1129, 3, 2, 2, 2, 1129, 1130, 3, 2, 2, 2, 1130, 1132, 7,
	19, 2, 2, 1131, 1133, 5, 184, 93, 2, 1132, 1131, 3, 2, 2, 2, 1132, 1133,
	3, 2, 2, 2, 1133, 263, 3, 2, 2, 2, 1134, 1135, 7, 53, 2, 2, 1135, 1136,
	7, 100, 2, 2, 1136, 1138, 7, 18, 2, 2, 1137, 1139, 5, 48, 25, 2, 1138,
	1137, 3, 2, 2, 2, 1138, 1139, 3, 2, 2, 2, 1139, 1140, 3, 2, 2, 2, 1140,
	1142, 7, 19, 2, 2, 1141, 1143, 5, 184, 93, 2, 1142, 1141, 3, 2, 2, 2, 1142,
	1143, 3, 2, 2, 2, 1143, 265, 3, 2, 2, 2, 1144, 1148, 5, 272, 137, 2, 1145,
	1148, 5, 270, 136, 2, 1146, 1148, 5, 268, 135, 2, 1147, 1144, 3, 2, 2,
	2, 1147, 1145, 3, 2, 2, 2, 1147, 1146, 3, 2, 2, 2, 1148, 267, 3, 2, 2,
	2, 1149, 1151, 7, 88, 2, 2, 1150, 1149, 3, 2, 2, 2, 1150, 1151, 3, 2, 2,
	2, 1151, 1152, 3, 2, 2, 2, 1152, 1153, 7, 57, 2, 2, 1153, 1154, 7, 100,
	2, 2, 1154, 269, 3, 2, 2, 2, 1155, 1156, 7, 88, 2, 2, 1156, 1157, 7, 57,
	2, 2, 1157, 1158, 7, 100, 2, 2, 1158, 1159, 5, 38, 20, 2, 1159, 1163, 7,
	16, 2, 2, 1160, 1162, 5, 18, 10, 2, 1161, 1160, 3, 2, 2, 2, 1162, 1165,
	3, 2, 2, 2, 1163, 1161, 3, 2, 2, 2, 1163, 1164, 3, 2, 2, 2, 1164, 1166,
	3, 2, 2, 2, 1165, 1163, 3, 2, 2, 2, 1166, 1167, 7, 17, 2, 2, 1167, 271,
	3, 2, 2, 2, 1168, 1169, 5, 274, 138, 2, 1169, 1173, 7, 16, 2, 2, 1170,
	1172, 5, 42, 22, 2, 1171, 1170, 3, 2, 2, 2, 1172, 1175, 3, 2, 2, 2, 1173,
	1171, 3, 2, 2, 2, 1173, 1174, 3, 2, 2, 2, 1174, 1176, 3, 2, 2, 2, 1175,
	1173, 3, 2, 2, 2, 1176, 1177, 7, 17, 2, 2, 1177, 273, 3, 2, 2, 2, 1178,
	1180, 7, 46, 2, 2, 1179, 1178, 3, 2, 2, 2, 1179, 1180, 3, 2, 2, 2, 1180,
	1181, 3, 2, 2, 2, 1181, 1182, 7, 57, 2, 2, 1182, 1183, 7, 100, 2, 2, 1183,
	1184, 5, 38, 20, 2, 1184, 275, 3, 2, 2, 2, 102, 279, 285, 320, 328, 334,
	342, 348, 353, 358, 382, 390, 396, 403, 410, 413, 430, 440, 446, 454, 461,
	464, 472, 475, 482, 493, 497, 506, 531, 540, 548, 556, 564, 572, 580, 587,
	597, 611, 618, 623, 634, 640, 645, 652, 657, 667, 671, 676, 688, 721, 742,
	747, 752, 763, 776, 795, 803, 811, 817, 825, 833, 839, 845, 848, 854, 862,
	869, 884, 896, 905, 922, 930, 953, 956, 970, 973, 977, 980, 994, 1001,
	1014, 1017, 1025, 1034, 1055, 1063, 1067, 1090, 1093, 1098, 1110, 1122,
	1128, 1132, 1138, 1142, 1147, 1150, 1163, 1173, 1179,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "';'", "':'", "','", "'{'",
	"'}'", "'('", "')'", "'['", "']'", "'~'", "'/'", "'<'", "'>'", "'*'", "'+'",
	"'-'", "'^'", "'&'", "'|'", "'='", "'%'", "'::'", "'>>'", "'<<'", "'setraises'",
	"'out'", "'emits'", "'string'", "'switch'", "'publishes'", "'typedef'",
	"'uses'", "'primarykey'", "'custom'", "'octet'", "'sequence'", "'import'",
	"'struct'", "'native'", "'readonly'", "'finder'", "'raises'", "'void'",
	"'private'", "'eventtype'", "'wchar'", "'in'", "'default'", "'public'",
	"'short'", "'long'", "'enum'", "'wstring'", "'context'", "'home'", "'factory'",
	"'exception'", "'getraises'", "'const'", "'ValueBase'", "'valuetype'",
	"'supports'", "'module'", "'Object'", "'truncatable'", "'unsigned'", "'fixed'",
	"'union'", "'oneway'", "'any'", "'char'", "'case'", "'float'", "'boolean'",
	"'multiple'", "'abstract'", "'inout'", "'provides'", "'consumes'", "'double'",
	"'typeprefix'", "'typeid'", "'attribute'", "'local'", "'manages'", "'interface'",
	"'component'",
}
var symbolicNames = []string{
	"", "INTEGER_LITERAL", "OCTAL_LITERAL", "HEX_LITERAL", "FLOATING_PT_LITERAL",
	"FIXED_PT_LITERAL", "WIDE_CHARACTER_LITERAL", "CHARACTER_LITERAL", "WIDE_STRING_LITERAL",
	"STRING_LITERAL", "BOOLEAN_LITERAL", "SEMICOLON", "COLON", "COMA", "LEFT_BRACE",
	"RIGHT_BRACE", "LEFT_BRACKET", "RIGHT_BRACKET", "LEFT_SQUARE_BRACKET",
	"RIGHT_SQUARE_BRACKET", "TILDE", "SLASH", "LEFT_ANG_BRACKET", "RIGHT_ANG_BRACKET",
	"STAR", "PLUS", "MINUS", "CARET", "AMPERSAND", "PIPE", "EQUAL", "PERCENT",
	"DOUBLE_COLON", "RIGHT_SHIFT", "LEFT_SHIFT", "KW_SETRAISES", "KW_OUT",
	"KW_EMITS", "KW_STRING", "KW_SWITCH", "KW_PUBLISHES", "KW_TYPEDEF", "KW_USES",
	"KW_PRIMARYKEY", "KW_CUSTOM", "KW_OCTET", "KW_SEQUENCE", "KW_IMPORT", "KW_STRUCT",
	"KW_NATIVE", "KW_READONLY", "KW_FINDER", "KW_RAISES", "KW_VOID", "KW_PRIVATE",
	"KW_EVENTTYPE", "KW_WCHAR", "KW_IN", "KW_DEFAULT", "KW_PUBLIC", "KW_SHORT",
	"KW_LONG", "KW_ENUM", "KW_WSTRING", "KW_CONTEXT", "KW_HOME", "KW_FACTORY",
	"KW_EXCEPTION", "KW_GETRAISES", "KW_CONST", "KW_VALUEBASE", "KW_VALUETYPE",
	"KW_SUPPORTS", "KW_MODULE", "KW_OBJECT", "KW_TRUNCATABLE", "KW_UNSIGNED",
	"KW_FIXED", "KW_UNION", "KW_ONEWAY", "KW_ANY", "KW_CHAR", "KW_CASE", "KW_FLOAT",
	"KW_BOOLEAN", "KW_MULTIPLE", "KW_ABSTRACT", "KW_INOUT", "KW_PROVIDES",
	"KW_CONSUMES", "KW_DOUBLE", "KW_TYPEPREFIX", "KW_TYPEID", "KW_ATTRIBUTE",
	"KW_LOCAL", "KW_MANAGES", "KW_INTERFACE", "KW_COMPONENT", "ID", "WS", "COMMENT",
	"LINE_COMMENT",
}

var ruleNames = []string{
	"specification", "definition", "module", "interface_or_forward_decl", "interface_decl",
	"forward_decl", "interface_header", "interface_body", "export", "interface_inheritance_spec",
	"interface_name", "scoped_name", "value", "value_forward_decl", "value_box_decl",
	"value_abs_decl", "value_decl", "value_header", "value_inheritance_spec",
	"value_name", "value_element", "state_member", "init_decl", "init_param_decls",
	"init_param_decl", "init_param_attribute", "const_decl", "const_type",
	"const_exp", "or_expr", "xor_expr", "and_expr", "shift_expr", "add_expr",
	"mult_expr", "unary_expr", "unary_operator", "primary_expr", "literal",
	"positive_int_const", "type_decl", "type_declarator", "type_spec", "simple_type_spec",
	"base_type_spec", "template_type_spec", "constr_type_spec", "declarators",
	"declarator", "simple_declarator", "complex_declarator", "floating_pt_type",
	"integer_type", "signed_int", "signed_short_int", "signed_long_int", "signed_longlong_int",
	"unsigned_int", "unsigned_short_int", "unsigned_long_int", "unsigned_longlong_int",
	"char_type", "wide_char_type", "boolean_type", "octet_type", "any_type",
	"object_type", "struct_type", "member_list", "member", "union_type", "switch_type_spec",
	"switch_body", "case_stmt", "case_label", "element_spec", "enum_type",
	"enumerator", "sequence_type", "string_type", "wide_string_type", "array_declarator",
	"fixed_array_size", "attr_decl", "except_decl", "op_decl", "op_attribute",
	"op_type_spec", "parameter_decls", "param_decl", "param_attribute", "raises_expr",
	"context_expr", "param_type_spec", "fixed_pt_type", "fixed_pt_const_type",
	"value_base_type", "constr_forward_decl", "import_decl", "imported_scope",
	"type_id_decl", "type_prefix_decl", "readonly_attr_spec", "readonly_attr_declarator",
	"attr_spec", "attr_declarator", "attr_raises_expr", "get_excep_expr", "set_excep_expr",
	"exception_list", "component", "component_forward_decl", "component_decl",
	"component_header", "supported_interface_spec", "component_inheritance_spec",
	"component_body", "component_export", "provides_decl", "interface_type",
	"uses_decl", "emits_decl", "publishes_decl", "consumes_decl", "home_decl",
	"home_header", "home_inheritance_spec", "primary_key_spec", "home_body",
	"home_export", "factory_decl", "finder_decl", "event", "event_forward_decl",
	"event_abs_decl", "event_decl", "event_header",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type IDLParser struct {
	*antlr.BaseParser
}

func NewIDLParser(input antlr.TokenStream) *IDLParser {
	this := new(IDLParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "IDL.g4"

	return this
}

// IDLParser tokens.
const (
	IDLParserEOF                    = antlr.TokenEOF
	IDLParserINTEGER_LITERAL        = 1
	IDLParserOCTAL_LITERAL          = 2
	IDLParserHEX_LITERAL            = 3
	IDLParserFLOATING_PT_LITERAL    = 4
	IDLParserFIXED_PT_LITERAL       = 5
	IDLParserWIDE_CHARACTER_LITERAL = 6
	IDLParserCHARACTER_LITERAL      = 7
	IDLParserWIDE_STRING_LITERAL    = 8
	IDLParserSTRING_LITERAL         = 9
	IDLParserBOOLEAN_LITERAL        = 10
	IDLParserSEMICOLON              = 11
	IDLParserCOLON                  = 12
	IDLParserCOMA                   = 13
	IDLParserLEFT_BRACE             = 14
	IDLParserRIGHT_BRACE            = 15
	IDLParserLEFT_BRACKET           = 16
	IDLParserRIGHT_BRACKET          = 17
	IDLParserLEFT_SQUARE_BRACKET    = 18
	IDLParserRIGHT_SQUARE_BRACKET   = 19
	IDLParserTILDE                  = 20
	IDLParserSLASH                  = 21
	IDLParserLEFT_ANG_BRACKET       = 22
	IDLParserRIGHT_ANG_BRACKET      = 23
	IDLParserSTAR                   = 24
	IDLParserPLUS                   = 25
	IDLParserMINUS                  = 26
	IDLParserCARET                  = 27
	IDLParserAMPERSAND              = 28
	IDLParserPIPE                   = 29
	IDLParserEQUAL                  = 30
	IDLParserPERCENT                = 31
	IDLParserDOUBLE_COLON           = 32
	IDLParserRIGHT_SHIFT            = 33
	IDLParserLEFT_SHIFT             = 34
	IDLParserKW_SETRAISES           = 35
	IDLParserKW_OUT                 = 36
	IDLParserKW_EMITS               = 37
	IDLParserKW_STRING              = 38
	IDLParserKW_SWITCH              = 39
	IDLParserKW_PUBLISHES           = 40
	IDLParserKW_TYPEDEF             = 41
	IDLParserKW_USES                = 42
	IDLParserKW_PRIMARYKEY          = 43
	IDLParserKW_CUSTOM              = 44
	IDLParserKW_OCTET               = 45
	IDLParserKW_SEQUENCE            = 46
	IDLParserKW_IMPORT              = 47
	IDLParserKW_STRUCT              = 48
	IDLParserKW_NATIVE              = 49
	IDLParserKW_READONLY            = 50
	IDLParserKW_FINDER              = 51
	IDLParserKW_RAISES              = 52
	IDLParserKW_VOID                = 53
	IDLParserKW_PRIVATE             = 54
	IDLParserKW_EVENTTYPE           = 55
	IDLParserKW_WCHAR               = 56
	IDLParserKW_IN                  = 57
	IDLParserKW_DEFAULT             = 58
	IDLParserKW_PUBLIC              = 59
	IDLParserKW_SHORT               = 60
	IDLParserKW_LONG                = 61
	IDLParserKW_ENUM                = 62
	IDLParserKW_WSTRING             = 63
	IDLParserKW_CONTEXT             = 64
	IDLParserKW_HOME                = 65
	IDLParserKW_FACTORY             = 66
	IDLParserKW_EXCEPTION           = 67
	IDLParserKW_GETRAISES           = 68
	IDLParserKW_CONST               = 69
	IDLParserKW_VALUEBASE           = 70
	IDLParserKW_VALUETYPE           = 71
	IDLParserKW_SUPPORTS            = 72
	IDLParserKW_MODULE              = 73
	IDLParserKW_OBJECT              = 74
	IDLParserKW_TRUNCATABLE         = 75
	IDLParserKW_UNSIGNED            = 76
	IDLParserKW_FIXED               = 77
	IDLParserKW_UNION               = 78
	IDLParserKW_ONEWAY              = 79
	IDLParserKW_ANY                 = 80
	IDLParserKW_CHAR                = 81
	IDLParserKW_CASE                = 82
	IDLParserKW_FLOAT               = 83
	IDLParserKW_BOOLEAN             = 84
	IDLParserKW_MULTIPLE            = 85
	IDLParserKW_ABSTRACT            = 86
	IDLParserKW_INOUT               = 87
	IDLParserKW_PROVIDES            = 88
	IDLParserKW_CONSUMES            = 89
	IDLParserKW_DOUBLE              = 90
	IDLParserKW_TYPEPREFIX          = 91
	IDLParserKW_TYPEID              = 92
	IDLParserKW_ATTRIBUTE           = 93
	IDLParserKW_LOCAL               = 94
	IDLParserKW_MANAGES             = 95
	IDLParserKW_INTERFACE           = 96
	IDLParserKW_COMPONENT           = 97
	IDLParserID                     = 98
	IDLParserWS                     = 99
	IDLParserCOMMENT                = 100
	IDLParserLINE_COMMENT           = 101
)

// IDLParser rules.
const (
	IDLParserRULE_specification              = 0
	IDLParserRULE_definition                 = 1
	IDLParserRULE_module                     = 2
	IDLParserRULE_interface_or_forward_decl  = 3
	IDLParserRULE_interface_decl             = 4
	IDLParserRULE_forward_decl               = 5
	IDLParserRULE_interface_header           = 6
	IDLParserRULE_interface_body             = 7
	IDLParserRULE_export                     = 8
	IDLParserRULE_interface_inheritance_spec = 9
	IDLParserRULE_interface_name             = 10
	IDLParserRULE_scoped_name                = 11
	IDLParserRULE_value                      = 12
	IDLParserRULE_value_forward_decl         = 13
	IDLParserRULE_value_box_decl             = 14
	IDLParserRULE_value_abs_decl             = 15
	IDLParserRULE_value_decl                 = 16
	IDLParserRULE_value_header               = 17
	IDLParserRULE_value_inheritance_spec     = 18
	IDLParserRULE_value_name                 = 19
	IDLParserRULE_value_element              = 20
	IDLParserRULE_state_member               = 21
	IDLParserRULE_init_decl                  = 22
	IDLParserRULE_init_param_decls           = 23
	IDLParserRULE_init_param_decl            = 24
	IDLParserRULE_init_param_attribute       = 25
	IDLParserRULE_const_decl                 = 26
	IDLParserRULE_const_type                 = 27
	IDLParserRULE_const_exp                  = 28
	IDLParserRULE_or_expr                    = 29
	IDLParserRULE_xor_expr                   = 30
	IDLParserRULE_and_expr                   = 31
	IDLParserRULE_shift_expr                 = 32
	IDLParserRULE_add_expr                   = 33
	IDLParserRULE_mult_expr                  = 34
	IDLParserRULE_unary_expr                 = 35
	IDLParserRULE_unary_operator             = 36
	IDLParserRULE_primary_expr               = 37
	IDLParserRULE_literal                    = 38
	IDLParserRULE_positive_int_const         = 39
	IDLParserRULE_type_decl                  = 40
	IDLParserRULE_type_declarator            = 41
	IDLParserRULE_type_spec                  = 42
	IDLParserRULE_simple_type_spec           = 43
	IDLParserRULE_base_type_spec             = 44
	IDLParserRULE_template_type_spec         = 45
	IDLParserRULE_constr_type_spec           = 46
	IDLParserRULE_declarators                = 47
	IDLParserRULE_declarator                 = 48
	IDLParserRULE_simple_declarator          = 49
	IDLParserRULE_complex_declarator         = 50
	IDLParserRULE_floating_pt_type           = 51
	IDLParserRULE_integer_type               = 52
	IDLParserRULE_signed_int                 = 53
	IDLParserRULE_signed_short_int           = 54
	IDLParserRULE_signed_long_int            = 55
	IDLParserRULE_signed_longlong_int        = 56
	IDLParserRULE_unsigned_int               = 57
	IDLParserRULE_unsigned_short_int         = 58
	IDLParserRULE_unsigned_long_int          = 59
	IDLParserRULE_unsigned_longlong_int      = 60
	IDLParserRULE_char_type                  = 61
	IDLParserRULE_wide_char_type             = 62
	IDLParserRULE_boolean_type               = 63
	IDLParserRULE_octet_type                 = 64
	IDLParserRULE_any_type                   = 65
	IDLParserRULE_object_type                = 66
	IDLParserRULE_struct_type                = 67
	IDLParserRULE_member_list                = 68
	IDLParserRULE_member                     = 69
	IDLParserRULE_union_type                 = 70
	IDLParserRULE_switch_type_spec           = 71
	IDLParserRULE_switch_body                = 72
	IDLParserRULE_case_stmt                  = 73
	IDLParserRULE_case_label                 = 74
	IDLParserRULE_element_spec               = 75
	IDLParserRULE_enum_type                  = 76
	IDLParserRULE_enumerator                 = 77
	IDLParserRULE_sequence_type              = 78
	IDLParserRULE_string_type                = 79
	IDLParserRULE_wide_string_type           = 80
	IDLParserRULE_array_declarator           = 81
	IDLParserRULE_fixed_array_size           = 82
	IDLParserRULE_attr_decl                  = 83
	IDLParserRULE_except_decl                = 84
	IDLParserRULE_op_decl                    = 85
	IDLParserRULE_op_attribute               = 86
	IDLParserRULE_op_type_spec               = 87
	IDLParserRULE_parameter_decls            = 88
	IDLParserRULE_param_decl                 = 89
	IDLParserRULE_param_attribute            = 90
	IDLParserRULE_raises_expr                = 91
	IDLParserRULE_context_expr               = 92
	IDLParserRULE_param_type_spec            = 93
	IDLParserRULE_fixed_pt_type              = 94
	IDLParserRULE_fixed_pt_const_type        = 95
	IDLParserRULE_value_base_type            = 96
	IDLParserRULE_constr_forward_decl        = 97
	IDLParserRULE_import_decl                = 98
	IDLParserRULE_imported_scope             = 99
	IDLParserRULE_type_id_decl               = 100
	IDLParserRULE_type_prefix_decl           = 101
	IDLParserRULE_readonly_attr_spec         = 102
	IDLParserRULE_readonly_attr_declarator   = 103
	IDLParserRULE_attr_spec                  = 104
	IDLParserRULE_attr_declarator            = 105
	IDLParserRULE_attr_raises_expr           = 106
	IDLParserRULE_get_excep_expr             = 107
	IDLParserRULE_set_excep_expr             = 108
	IDLParserRULE_exception_list             = 109
	IDLParserRULE_component                  = 110
	IDLParserRULE_component_forward_decl     = 111
	IDLParserRULE_component_decl             = 112
	IDLParserRULE_component_header           = 113
	IDLParserRULE_supported_interface_spec   = 114
	IDLParserRULE_component_inheritance_spec = 115
	IDLParserRULE_component_body             = 116
	IDLParserRULE_component_export           = 117
	IDLParserRULE_provides_decl              = 118
	IDLParserRULE_interface_type             = 119
	IDLParserRULE_uses_decl                  = 120
	IDLParserRULE_emits_decl                 = 121
	IDLParserRULE_publishes_decl             = 122
	IDLParserRULE_consumes_decl              = 123
	IDLParserRULE_home_decl                  = 124
	IDLParserRULE_home_header                = 125
	IDLParserRULE_home_inheritance_spec      = 126
	IDLParserRULE_primary_key_spec           = 127
	IDLParserRULE_home_body                  = 128
	IDLParserRULE_home_export                = 129
	IDLParserRULE_factory_decl               = 130
	IDLParserRULE_finder_decl                = 131
	IDLParserRULE_event                      = 132
	IDLParserRULE_event_forward_decl         = 133
	IDLParserRULE_event_abs_decl             = 134
	IDLParserRULE_event_decl                 = 135
	IDLParserRULE_event_header               = 136
)

// ISpecificationContext is an interface to support dynamic dispatch.
type ISpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecificationContext differentiates from other interfaces.
	IsSpecificationContext()
}

type SpecificationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecificationContext() *SpecificationContext {
	var p = new(SpecificationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_specification
	return p
}

func (*SpecificationContext) IsSpecificationContext() {}

func NewSpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecificationContext {
	var p = new(SpecificationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_specification

	return p
}

func (s *SpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecificationContext) AllImport_decl() []IImport_declContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IImport_declContext)(nil)).Elem())
	var tst = make([]IImport_declContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IImport_declContext)
		}
	}

	return tst
}

func (s *SpecificationContext) Import_decl(i int) IImport_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImport_declContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IImport_declContext)
}

func (s *SpecificationContext) AllDefinition() []IDefinitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDefinitionContext)(nil)).Elem())
	var tst = make([]IDefinitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDefinitionContext)
		}
	}

	return tst
}

func (s *SpecificationContext) Definition(i int) IDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDefinitionContext)
}

func (s *SpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSpecification(s)
	}
}

func (s *SpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSpecification(s)
	}
}

func (p *IDLParser) Specification() (localctx ISpecificationContext) {
	localctx = NewSpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, IDLParserRULE_specification)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(277)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserKW_IMPORT {
		{
			p.SetState(274)
			p.Import_decl()
		}

		p.SetState(279)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(281)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(IDLParserKW_TYPEDEF-41))|(1<<(IDLParserKW_CUSTOM-41))|(1<<(IDLParserKW_STRUCT-41))|(1<<(IDLParserKW_NATIVE-41))|(1<<(IDLParserKW_EVENTTYPE-41))|(1<<(IDLParserKW_ENUM-41))|(1<<(IDLParserKW_HOME-41))|(1<<(IDLParserKW_EXCEPTION-41))|(1<<(IDLParserKW_CONST-41))|(1<<(IDLParserKW_VALUETYPE-41)))) != 0) || (((_la-73)&-(0x1f+1)) == 0 && ((1<<uint((_la-73)))&((1<<(IDLParserKW_MODULE-73))|(1<<(IDLParserKW_UNION-73))|(1<<(IDLParserKW_ABSTRACT-73))|(1<<(IDLParserKW_TYPEPREFIX-73))|(1<<(IDLParserKW_TYPEID-73))|(1<<(IDLParserKW_LOCAL-73))|(1<<(IDLParserKW_INTERFACE-73))|(1<<(IDLParserKW_COMPONENT-73)))) != 0) {
		{
			p.SetState(280)
			p.Definition()
		}

		p.SetState(283)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDefinitionContext is an interface to support dynamic dispatch.
type IDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefinitionContext differentiates from other interfaces.
	IsDefinitionContext()
}

type DefinitionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinitionContext() *DefinitionContext {
	var p = new(DefinitionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_definition
	return p
}

func (*DefinitionContext) IsDefinitionContext() {}

func NewDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinitionContext {
	var p = new(DefinitionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_definition

	return p
}

func (s *DefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinitionContext) Type_decl() IType_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declContext)
}

func (s *DefinitionContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(IDLParserSEMICOLON, 0)
}

func (s *DefinitionContext) Const_decl() IConst_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_declContext)
}

func (s *DefinitionContext) Except_decl() IExcept_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExcept_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExcept_declContext)
}

func (s *DefinitionContext) Interface_or_forward_decl() IInterface_or_forward_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_or_forward_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_or_forward_declContext)
}

func (s *DefinitionContext) Module() IModuleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IModuleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IModuleContext)
}

func (s *DefinitionContext) Value() IValueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValueContext)
}

func (s *DefinitionContext) Type_id_decl() IType_id_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_id_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_id_declContext)
}

func (s *DefinitionContext) Type_prefix_decl() IType_prefix_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_prefix_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_prefix_declContext)
}

func (s *DefinitionContext) Event() IEventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEventContext)
}

func (s *DefinitionContext) Component() IComponentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponentContext)
}

func (s *DefinitionContext) Home_decl() IHome_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHome_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHome_declContext)
}

func (s *DefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterDefinition(s)
	}
}

func (s *DefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitDefinition(s)
	}
}

func (p *IDLParser) Definition() (localctx IDefinitionContext) {
	localctx = NewDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, IDLParserRULE_definition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(318)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 2, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(285)
			p.Type_decl()
		}
		{
			p.SetState(286)
			p.Match(IDLParserSEMICOLON)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(288)
			p.Const_decl()
		}
		{
			p.SetState(289)
			p.Match(IDLParserSEMICOLON)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(291)
			p.Except_decl()
		}
		{
			p.SetState(292)
			p.Match(IDLParserSEMICOLON)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(294)
			p.Interface_or_forward_decl()
		}
		{
			p.SetState(295)
			p.Match(IDLParserSEMICOLON)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(297)
			p.Module()
		}
		{
			p.SetState(298)
			p.Match(IDLParserSEMICOLON)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(300)
			p.Value()
		}
		{
			p.SetState(301)
			p.Match(IDLParserSEMICOLON)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(303)
			p.Type_id_decl()
		}
		{
			p.SetState(304)
			p.Match(IDLParserSEMICOLON)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(306)
			p.Type_prefix_decl()
		}
		{
			p.SetState(307)
			p.Match(IDLParserSEMICOLON)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(309)
			p.Event()
		}
		{
			p.SetState(310)
			p.Match(IDLParserSEMICOLON)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(312)
			p.Component()
		}
		{
			p.SetState(313)
			p.Match(IDLParserSEMICOLON)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(315)
			p.Home_decl()
		}
		{
			p.SetState(316)
			p.Match(IDLParserSEMICOLON)
		}

	}

	return localctx
}

// IModuleContext is an interface to support dynamic dispatch.
type IModuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModuleContext differentiates from other interfaces.
	IsModuleContext()
}

type ModuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModuleContext() *ModuleContext {
	var p = new(ModuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_module
	return p
}

func (*ModuleContext) IsModuleContext() {}

func NewModuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModuleContext {
	var p = new(ModuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_module

	return p
}

func (s *ModuleContext) GetParser() antlr.Parser { return s.parser }

func (s *ModuleContext) KW_MODULE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_MODULE, 0)
}

func (s *ModuleContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *ModuleContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *ModuleContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *ModuleContext) AllDefinition() []IDefinitionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDefinitionContext)(nil)).Elem())
	var tst = make([]IDefinitionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDefinitionContext)
		}
	}

	return tst
}

func (s *ModuleContext) Definition(i int) IDefinitionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDefinitionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDefinitionContext)
}

func (s *ModuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterModule(s)
	}
}

func (s *ModuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitModule(s)
	}
}

func (p *IDLParser) Module() (localctx IModuleContext) {
	localctx = NewModuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, IDLParserRULE_module)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(320)
		p.Match(IDLParserKW_MODULE)
	}
	{
		p.SetState(321)
		p.Match(IDLParserID)
	}
	{
		p.SetState(322)
		p.Match(IDLParserLEFT_BRACE)
	}
	p.SetState(324)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-41)&-(0x1f+1)) == 0 && ((1<<uint((_la-41)))&((1<<(IDLParserKW_TYPEDEF-41))|(1<<(IDLParserKW_CUSTOM-41))|(1<<(IDLParserKW_STRUCT-41))|(1<<(IDLParserKW_NATIVE-41))|(1<<(IDLParserKW_EVENTTYPE-41))|(1<<(IDLParserKW_ENUM-41))|(1<<(IDLParserKW_HOME-41))|(1<<(IDLParserKW_EXCEPTION-41))|(1<<(IDLParserKW_CONST-41))|(1<<(IDLParserKW_VALUETYPE-41)))) != 0) || (((_la-73)&-(0x1f+1)) == 0 && ((1<<uint((_la-73)))&((1<<(IDLParserKW_MODULE-73))|(1<<(IDLParserKW_UNION-73))|(1<<(IDLParserKW_ABSTRACT-73))|(1<<(IDLParserKW_TYPEPREFIX-73))|(1<<(IDLParserKW_TYPEID-73))|(1<<(IDLParserKW_LOCAL-73))|(1<<(IDLParserKW_INTERFACE-73))|(1<<(IDLParserKW_COMPONENT-73)))) != 0) {
		{
			p.SetState(323)
			p.Definition()
		}

		p.SetState(326)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(328)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IInterface_or_forward_declContext is an interface to support dynamic dispatch.
type IInterface_or_forward_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_or_forward_declContext differentiates from other interfaces.
	IsInterface_or_forward_declContext()
}

type Interface_or_forward_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_or_forward_declContext() *Interface_or_forward_declContext {
	var p = new(Interface_or_forward_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_interface_or_forward_decl
	return p
}

func (*Interface_or_forward_declContext) IsInterface_or_forward_declContext() {}

func NewInterface_or_forward_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_or_forward_declContext {
	var p = new(Interface_or_forward_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_interface_or_forward_decl

	return p
}

func (s *Interface_or_forward_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_or_forward_declContext) Interface_decl() IInterface_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_declContext)
}

func (s *Interface_or_forward_declContext) Forward_decl() IForward_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForward_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForward_declContext)
}

func (s *Interface_or_forward_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_or_forward_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_or_forward_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInterface_or_forward_decl(s)
	}
}

func (s *Interface_or_forward_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInterface_or_forward_decl(s)
	}
}

func (p *IDLParser) Interface_or_forward_decl() (localctx IInterface_or_forward_declContext) {
	localctx = NewInterface_or_forward_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, IDLParserRULE_interface_or_forward_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(332)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(330)
			p.Interface_decl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(331)
			p.Forward_decl()
		}

	}

	return localctx
}

// IInterface_declContext is an interface to support dynamic dispatch.
type IInterface_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_declContext differentiates from other interfaces.
	IsInterface_declContext()
}

type Interface_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_declContext() *Interface_declContext {
	var p = new(Interface_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_interface_decl
	return p
}

func (*Interface_declContext) IsInterface_declContext() {}

func NewInterface_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_declContext {
	var p = new(Interface_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_interface_decl

	return p
}

func (s *Interface_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_declContext) Interface_header() IInterface_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_headerContext)
}

func (s *Interface_declContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Interface_declContext) Interface_body() IInterface_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_bodyContext)
}

func (s *Interface_declContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Interface_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInterface_decl(s)
	}
}

func (s *Interface_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInterface_decl(s)
	}
}

func (p *IDLParser) Interface_decl() (localctx IInterface_declContext) {
	localctx = NewInterface_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, IDLParserRULE_interface_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(334)
		p.Interface_header()
	}
	{
		p.SetState(335)
		p.Match(IDLParserLEFT_BRACE)
	}
	{
		p.SetState(336)
		p.Interface_body()
	}
	{
		p.SetState(337)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IForward_declContext is an interface to support dynamic dispatch.
type IForward_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForward_declContext differentiates from other interfaces.
	IsForward_declContext()
}

type Forward_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForward_declContext() *Forward_declContext {
	var p = new(Forward_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_forward_decl
	return p
}

func (*Forward_declContext) IsForward_declContext() {}

func NewForward_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Forward_declContext {
	var p = new(Forward_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_forward_decl

	return p
}

func (s *Forward_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Forward_declContext) KW_INTERFACE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_INTERFACE, 0)
}

func (s *Forward_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Forward_declContext) KW_ABSTRACT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_ABSTRACT, 0)
}

func (s *Forward_declContext) KW_LOCAL() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_LOCAL, 0)
}

func (s *Forward_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Forward_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Forward_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterForward_decl(s)
	}
}

func (s *Forward_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitForward_decl(s)
	}
}

func (p *IDLParser) Forward_decl() (localctx IForward_declContext) {
	localctx = NewForward_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, IDLParserRULE_forward_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(340)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_ABSTRACT || _la == IDLParserKW_LOCAL {
		{
			p.SetState(339)
			_la = p.GetTokenStream().LA(1)

			if !(_la == IDLParserKW_ABSTRACT || _la == IDLParserKW_LOCAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(342)
		p.Match(IDLParserKW_INTERFACE)
	}
	{
		p.SetState(343)
		p.Match(IDLParserID)
	}

	return localctx
}

// IInterface_headerContext is an interface to support dynamic dispatch.
type IInterface_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_headerContext differentiates from other interfaces.
	IsInterface_headerContext()
}

type Interface_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_headerContext() *Interface_headerContext {
	var p = new(Interface_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_interface_header
	return p
}

func (*Interface_headerContext) IsInterface_headerContext() {}

func NewInterface_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_headerContext {
	var p = new(Interface_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_interface_header

	return p
}

func (s *Interface_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_headerContext) KW_INTERFACE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_INTERFACE, 0)
}

func (s *Interface_headerContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Interface_headerContext) Interface_inheritance_spec() IInterface_inheritance_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_inheritance_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_inheritance_specContext)
}

func (s *Interface_headerContext) KW_ABSTRACT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_ABSTRACT, 0)
}

func (s *Interface_headerContext) KW_LOCAL() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_LOCAL, 0)
}

func (s *Interface_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInterface_header(s)
	}
}

func (s *Interface_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInterface_header(s)
	}
}

func (p *IDLParser) Interface_header() (localctx IInterface_headerContext) {
	localctx = NewInterface_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, IDLParserRULE_interface_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(346)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_ABSTRACT || _la == IDLParserKW_LOCAL {
		{
			p.SetState(345)
			_la = p.GetTokenStream().LA(1)

			if !(_la == IDLParserKW_ABSTRACT || _la == IDLParserKW_LOCAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(348)
		p.Match(IDLParserKW_INTERFACE)
	}
	{
		p.SetState(349)
		p.Match(IDLParserID)
	}
	p.SetState(351)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserCOLON {
		{
			p.SetState(350)
			p.Interface_inheritance_spec()
		}

	}

	return localctx
}

// IInterface_bodyContext is an interface to support dynamic dispatch.
type IInterface_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_bodyContext differentiates from other interfaces.
	IsInterface_bodyContext()
}

type Interface_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_bodyContext() *Interface_bodyContext {
	var p = new(Interface_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_interface_body
	return p
}

func (*Interface_bodyContext) IsInterface_bodyContext() {}

func NewInterface_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_bodyContext {
	var p = new(Interface_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_interface_body

	return p
}

func (s *Interface_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_bodyContext) AllExport() []IExportContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExportContext)(nil)).Elem())
	var tst = make([]IExportContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExportContext)
		}
	}

	return tst
}

func (s *Interface_bodyContext) Export(i int) IExportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExportContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExportContext)
}

func (s *Interface_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInterface_body(s)
	}
}

func (s *Interface_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInterface_body(s)
	}
}

func (p *IDLParser) Interface_body() (localctx IInterface_bodyContext) {
	localctx = NewInterface_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, IDLParserRULE_interface_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(356)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(IDLParserDOUBLE_COLON-32))|(1<<(IDLParserKW_STRING-32))|(1<<(IDLParserKW_TYPEDEF-32))|(1<<(IDLParserKW_OCTET-32))|(1<<(IDLParserKW_STRUCT-32))|(1<<(IDLParserKW_NATIVE-32))|(1<<(IDLParserKW_READONLY-32))|(1<<(IDLParserKW_VOID-32))|(1<<(IDLParserKW_WCHAR-32))|(1<<(IDLParserKW_SHORT-32))|(1<<(IDLParserKW_LONG-32))|(1<<(IDLParserKW_ENUM-32))|(1<<(IDLParserKW_WSTRING-32)))) != 0) || (((_la-67)&-(0x1f+1)) == 0 && ((1<<uint((_la-67)))&((1<<(IDLParserKW_EXCEPTION-67))|(1<<(IDLParserKW_CONST-67))|(1<<(IDLParserKW_VALUEBASE-67))|(1<<(IDLParserKW_OBJECT-67))|(1<<(IDLParserKW_UNSIGNED-67))|(1<<(IDLParserKW_UNION-67))|(1<<(IDLParserKW_ONEWAY-67))|(1<<(IDLParserKW_ANY-67))|(1<<(IDLParserKW_CHAR-67))|(1<<(IDLParserKW_FLOAT-67))|(1<<(IDLParserKW_BOOLEAN-67))|(1<<(IDLParserKW_DOUBLE-67))|(1<<(IDLParserKW_TYPEPREFIX-67))|(1<<(IDLParserKW_TYPEID-67))|(1<<(IDLParserKW_ATTRIBUTE-67))|(1<<(IDLParserID-67)))) != 0) {
		{
			p.SetState(353)
			p.Export()
		}

		p.SetState(358)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExportContext is an interface to support dynamic dispatch.
type IExportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExportContext differentiates from other interfaces.
	IsExportContext()
}

type ExportContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExportContext() *ExportContext {
	var p = new(ExportContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_export
	return p
}

func (*ExportContext) IsExportContext() {}

func NewExportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExportContext {
	var p = new(ExportContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_export

	return p
}

func (s *ExportContext) GetParser() antlr.Parser { return s.parser }

func (s *ExportContext) Type_decl() IType_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declContext)
}

func (s *ExportContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(IDLParserSEMICOLON, 0)
}

func (s *ExportContext) Const_decl() IConst_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_declContext)
}

func (s *ExportContext) Except_decl() IExcept_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExcept_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExcept_declContext)
}

func (s *ExportContext) Attr_decl() IAttr_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_declContext)
}

func (s *ExportContext) Op_decl() IOp_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOp_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOp_declContext)
}

func (s *ExportContext) Type_id_decl() IType_id_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_id_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_id_declContext)
}

func (s *ExportContext) Type_prefix_decl() IType_prefix_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_prefix_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_prefix_declContext)
}

func (s *ExportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterExport(s)
	}
}

func (s *ExportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitExport(s)
	}
}

func (p *IDLParser) Export() (localctx IExportContext) {
	localctx = NewExportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, IDLParserRULE_export)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(380)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_TYPEDEF, IDLParserKW_STRUCT, IDLParserKW_NATIVE, IDLParserKW_ENUM, IDLParserKW_UNION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(359)
			p.Type_decl()
		}
		{
			p.SetState(360)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserKW_CONST:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(362)
			p.Const_decl()
		}
		{
			p.SetState(363)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserKW_EXCEPTION:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(365)
			p.Except_decl()
		}
		{
			p.SetState(366)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserKW_READONLY, IDLParserKW_ATTRIBUTE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(368)
			p.Attr_decl()
		}
		{
			p.SetState(369)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserDOUBLE_COLON, IDLParserKW_STRING, IDLParserKW_OCTET, IDLParserKW_VOID, IDLParserKW_WCHAR, IDLParserKW_SHORT, IDLParserKW_LONG, IDLParserKW_WSTRING, IDLParserKW_VALUEBASE, IDLParserKW_OBJECT, IDLParserKW_UNSIGNED, IDLParserKW_ONEWAY, IDLParserKW_ANY, IDLParserKW_CHAR, IDLParserKW_FLOAT, IDLParserKW_BOOLEAN, IDLParserKW_DOUBLE, IDLParserID:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(371)
			p.Op_decl()
		}
		{
			p.SetState(372)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserKW_TYPEID:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(374)
			p.Type_id_decl()
		}
		{
			p.SetState(375)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserKW_TYPEPREFIX:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(377)
			p.Type_prefix_decl()
		}
		{
			p.SetState(378)
			p.Match(IDLParserSEMICOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInterface_inheritance_specContext is an interface to support dynamic dispatch.
type IInterface_inheritance_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_inheritance_specContext differentiates from other interfaces.
	IsInterface_inheritance_specContext()
}

type Interface_inheritance_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_inheritance_specContext() *Interface_inheritance_specContext {
	var p = new(Interface_inheritance_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_interface_inheritance_spec
	return p
}

func (*Interface_inheritance_specContext) IsInterface_inheritance_specContext() {}

func NewInterface_inheritance_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_inheritance_specContext {
	var p = new(Interface_inheritance_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_interface_inheritance_spec

	return p
}

func (s *Interface_inheritance_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_inheritance_specContext) COLON() antlr.TerminalNode {
	return s.GetToken(IDLParserCOLON, 0)
}

func (s *Interface_inheritance_specContext) AllInterface_name() []IInterface_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterface_nameContext)(nil)).Elem())
	var tst = make([]IInterface_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterface_nameContext)
		}
	}

	return tst
}

func (s *Interface_inheritance_specContext) Interface_name(i int) IInterface_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterface_nameContext)
}

func (s *Interface_inheritance_specContext) AllCOMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMA)
}

func (s *Interface_inheritance_specContext) COMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMA, i)
}

func (s *Interface_inheritance_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_inheritance_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_inheritance_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInterface_inheritance_spec(s)
	}
}

func (s *Interface_inheritance_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInterface_inheritance_spec(s)
	}
}

func (p *IDLParser) Interface_inheritance_spec() (localctx IInterface_inheritance_specContext) {
	localctx = NewInterface_inheritance_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, IDLParserRULE_interface_inheritance_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(382)
		p.Match(IDLParserCOLON)
	}
	{
		p.SetState(383)
		p.Interface_name()
	}
	p.SetState(388)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserCOMA {
		{
			p.SetState(384)
			p.Match(IDLParserCOMA)
		}
		{
			p.SetState(385)
			p.Interface_name()
		}

		p.SetState(390)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInterface_nameContext is an interface to support dynamic dispatch.
type IInterface_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_nameContext differentiates from other interfaces.
	IsInterface_nameContext()
}

type Interface_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_nameContext() *Interface_nameContext {
	var p = new(Interface_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_interface_name
	return p
}

func (*Interface_nameContext) IsInterface_nameContext() {}

func NewInterface_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_nameContext {
	var p = new(Interface_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_interface_name

	return p
}

func (s *Interface_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_nameContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Interface_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInterface_name(s)
	}
}

func (s *Interface_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInterface_name(s)
	}
}

func (p *IDLParser) Interface_name() (localctx IInterface_nameContext) {
	localctx = NewInterface_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, IDLParserRULE_interface_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(391)
		p.Scoped_name()
	}

	return localctx
}

// IScoped_nameContext is an interface to support dynamic dispatch.
type IScoped_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScoped_nameContext differentiates from other interfaces.
	IsScoped_nameContext()
}

type Scoped_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScoped_nameContext() *Scoped_nameContext {
	var p = new(Scoped_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_scoped_name
	return p
}

func (*Scoped_nameContext) IsScoped_nameContext() {}

func NewScoped_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Scoped_nameContext {
	var p = new(Scoped_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_scoped_name

	return p
}

func (s *Scoped_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Scoped_nameContext) AllID() []antlr.TerminalNode {
	return s.GetTokens(IDLParserID)
}

func (s *Scoped_nameContext) ID(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserID, i)
}

func (s *Scoped_nameContext) AllDOUBLE_COLON() []antlr.TerminalNode {
	return s.GetTokens(IDLParserDOUBLE_COLON)
}

func (s *Scoped_nameContext) DOUBLE_COLON(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserDOUBLE_COLON, i)
}

func (s *Scoped_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Scoped_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Scoped_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterScoped_name(s)
	}
}

func (s *Scoped_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitScoped_name(s)
	}
}

func (p *IDLParser) Scoped_name() (localctx IScoped_nameContext) {
	localctx = NewScoped_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, IDLParserRULE_scoped_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(394)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserDOUBLE_COLON {
		{
			p.SetState(393)
			p.Match(IDLParserDOUBLE_COLON)
		}

	}
	{
		p.SetState(396)
		p.Match(IDLParserID)
	}
	p.SetState(401)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserDOUBLE_COLON {
		{
			p.SetState(397)
			p.Match(IDLParserDOUBLE_COLON)
		}
		{
			p.SetState(398)
			p.Match(IDLParserID)
		}

		p.SetState(403)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IValueContext is an interface to support dynamic dispatch.
type IValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueContext differentiates from other interfaces.
	IsValueContext()
}

type ValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueContext() *ValueContext {
	var p = new(ValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_value
	return p
}

func (*ValueContext) IsValueContext() {}

func NewValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueContext {
	var p = new(ValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_value

	return p
}

func (s *ValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueContext) Value_decl() IValue_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_declContext)
}

func (s *ValueContext) Value_abs_decl() IValue_abs_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_abs_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_abs_declContext)
}

func (s *ValueContext) Value_box_decl() IValue_box_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_box_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_box_declContext)
}

func (s *ValueContext) Value_forward_decl() IValue_forward_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_forward_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_forward_declContext)
}

func (s *ValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterValue(s)
	}
}

func (s *ValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitValue(s)
	}
}

func (p *IDLParser) Value() (localctx IValueContext) {
	localctx = NewValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, IDLParserRULE_value)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(408)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(404)
			p.Value_decl()
		}

	case 2:
		{
			p.SetState(405)
			p.Value_abs_decl()
		}

	case 3:
		{
			p.SetState(406)
			p.Value_box_decl()
		}

	case 4:
		{
			p.SetState(407)
			p.Value_forward_decl()
		}

	}

	return localctx
}

// IValue_forward_declContext is an interface to support dynamic dispatch.
type IValue_forward_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValue_forward_declContext differentiates from other interfaces.
	IsValue_forward_declContext()
}

type Value_forward_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_forward_declContext() *Value_forward_declContext {
	var p = new(Value_forward_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_value_forward_decl
	return p
}

func (*Value_forward_declContext) IsValue_forward_declContext() {}

func NewValue_forward_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_forward_declContext {
	var p = new(Value_forward_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_value_forward_decl

	return p
}

func (s *Value_forward_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_forward_declContext) KW_VALUETYPE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_VALUETYPE, 0)
}

func (s *Value_forward_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Value_forward_declContext) KW_ABSTRACT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_ABSTRACT, 0)
}

func (s *Value_forward_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_forward_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_forward_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterValue_forward_decl(s)
	}
}

func (s *Value_forward_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitValue_forward_decl(s)
	}
}

func (p *IDLParser) Value_forward_decl() (localctx IValue_forward_declContext) {
	localctx = NewValue_forward_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, IDLParserRULE_value_forward_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(411)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_ABSTRACT {
		{
			p.SetState(410)
			p.Match(IDLParserKW_ABSTRACT)
		}

	}
	{
		p.SetState(413)
		p.Match(IDLParserKW_VALUETYPE)
	}
	{
		p.SetState(414)
		p.Match(IDLParserID)
	}

	return localctx
}

// IValue_box_declContext is an interface to support dynamic dispatch.
type IValue_box_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValue_box_declContext differentiates from other interfaces.
	IsValue_box_declContext()
}

type Value_box_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_box_declContext() *Value_box_declContext {
	var p = new(Value_box_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_value_box_decl
	return p
}

func (*Value_box_declContext) IsValue_box_declContext() {}

func NewValue_box_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_box_declContext {
	var p = new(Value_box_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_value_box_decl

	return p
}

func (s *Value_box_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_box_declContext) KW_VALUETYPE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_VALUETYPE, 0)
}

func (s *Value_box_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Value_box_declContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Value_box_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_box_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_box_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterValue_box_decl(s)
	}
}

func (s *Value_box_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitValue_box_decl(s)
	}
}

func (p *IDLParser) Value_box_decl() (localctx IValue_box_declContext) {
	localctx = NewValue_box_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, IDLParserRULE_value_box_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(416)
		p.Match(IDLParserKW_VALUETYPE)
	}
	{
		p.SetState(417)
		p.Match(IDLParserID)
	}
	{
		p.SetState(418)
		p.Type_spec()
	}

	return localctx
}

// IValue_abs_declContext is an interface to support dynamic dispatch.
type IValue_abs_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValue_abs_declContext differentiates from other interfaces.
	IsValue_abs_declContext()
}

type Value_abs_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_abs_declContext() *Value_abs_declContext {
	var p = new(Value_abs_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_value_abs_decl
	return p
}

func (*Value_abs_declContext) IsValue_abs_declContext() {}

func NewValue_abs_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_abs_declContext {
	var p = new(Value_abs_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_value_abs_decl

	return p
}

func (s *Value_abs_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_abs_declContext) KW_ABSTRACT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_ABSTRACT, 0)
}

func (s *Value_abs_declContext) KW_VALUETYPE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_VALUETYPE, 0)
}

func (s *Value_abs_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Value_abs_declContext) Value_inheritance_spec() IValue_inheritance_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_inheritance_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_inheritance_specContext)
}

func (s *Value_abs_declContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Value_abs_declContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Value_abs_declContext) AllExport() []IExportContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExportContext)(nil)).Elem())
	var tst = make([]IExportContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExportContext)
		}
	}

	return tst
}

func (s *Value_abs_declContext) Export(i int) IExportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExportContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExportContext)
}

func (s *Value_abs_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_abs_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_abs_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterValue_abs_decl(s)
	}
}

func (s *Value_abs_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitValue_abs_decl(s)
	}
}

func (p *IDLParser) Value_abs_decl() (localctx IValue_abs_declContext) {
	localctx = NewValue_abs_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, IDLParserRULE_value_abs_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(420)
		p.Match(IDLParserKW_ABSTRACT)
	}
	{
		p.SetState(421)
		p.Match(IDLParserKW_VALUETYPE)
	}
	{
		p.SetState(422)
		p.Match(IDLParserID)
	}
	{
		p.SetState(423)
		p.Value_inheritance_spec()
	}
	{
		p.SetState(424)
		p.Match(IDLParserLEFT_BRACE)
	}
	p.SetState(428)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(IDLParserDOUBLE_COLON-32))|(1<<(IDLParserKW_STRING-32))|(1<<(IDLParserKW_TYPEDEF-32))|(1<<(IDLParserKW_OCTET-32))|(1<<(IDLParserKW_STRUCT-32))|(1<<(IDLParserKW_NATIVE-32))|(1<<(IDLParserKW_READONLY-32))|(1<<(IDLParserKW_VOID-32))|(1<<(IDLParserKW_WCHAR-32))|(1<<(IDLParserKW_SHORT-32))|(1<<(IDLParserKW_LONG-32))|(1<<(IDLParserKW_ENUM-32))|(1<<(IDLParserKW_WSTRING-32)))) != 0) || (((_la-67)&-(0x1f+1)) == 0 && ((1<<uint((_la-67)))&((1<<(IDLParserKW_EXCEPTION-67))|(1<<(IDLParserKW_CONST-67))|(1<<(IDLParserKW_VALUEBASE-67))|(1<<(IDLParserKW_OBJECT-67))|(1<<(IDLParserKW_UNSIGNED-67))|(1<<(IDLParserKW_UNION-67))|(1<<(IDLParserKW_ONEWAY-67))|(1<<(IDLParserKW_ANY-67))|(1<<(IDLParserKW_CHAR-67))|(1<<(IDLParserKW_FLOAT-67))|(1<<(IDLParserKW_BOOLEAN-67))|(1<<(IDLParserKW_DOUBLE-67))|(1<<(IDLParserKW_TYPEPREFIX-67))|(1<<(IDLParserKW_TYPEID-67))|(1<<(IDLParserKW_ATTRIBUTE-67))|(1<<(IDLParserID-67)))) != 0) {
		{
			p.SetState(425)
			p.Export()
		}

		p.SetState(430)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(431)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IValue_declContext is an interface to support dynamic dispatch.
type IValue_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValue_declContext differentiates from other interfaces.
	IsValue_declContext()
}

type Value_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_declContext() *Value_declContext {
	var p = new(Value_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_value_decl
	return p
}

func (*Value_declContext) IsValue_declContext() {}

func NewValue_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_declContext {
	var p = new(Value_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_value_decl

	return p
}

func (s *Value_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_declContext) Value_header() IValue_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_headerContext)
}

func (s *Value_declContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Value_declContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Value_declContext) AllValue_element() []IValue_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValue_elementContext)(nil)).Elem())
	var tst = make([]IValue_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValue_elementContext)
		}
	}

	return tst
}

func (s *Value_declContext) Value_element(i int) IValue_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValue_elementContext)
}

func (s *Value_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterValue_decl(s)
	}
}

func (s *Value_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitValue_decl(s)
	}
}

func (p *IDLParser) Value_decl() (localctx IValue_declContext) {
	localctx = NewValue_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, IDLParserRULE_value_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(433)
		p.Value_header()
	}
	{
		p.SetState(434)
		p.Match(IDLParserLEFT_BRACE)
	}
	p.SetState(438)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(IDLParserDOUBLE_COLON-32))|(1<<(IDLParserKW_STRING-32))|(1<<(IDLParserKW_TYPEDEF-32))|(1<<(IDLParserKW_OCTET-32))|(1<<(IDLParserKW_STRUCT-32))|(1<<(IDLParserKW_NATIVE-32))|(1<<(IDLParserKW_READONLY-32))|(1<<(IDLParserKW_VOID-32))|(1<<(IDLParserKW_PRIVATE-32))|(1<<(IDLParserKW_WCHAR-32))|(1<<(IDLParserKW_PUBLIC-32))|(1<<(IDLParserKW_SHORT-32))|(1<<(IDLParserKW_LONG-32))|(1<<(IDLParserKW_ENUM-32))|(1<<(IDLParserKW_WSTRING-32)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(IDLParserKW_FACTORY-66))|(1<<(IDLParserKW_EXCEPTION-66))|(1<<(IDLParserKW_CONST-66))|(1<<(IDLParserKW_VALUEBASE-66))|(1<<(IDLParserKW_OBJECT-66))|(1<<(IDLParserKW_UNSIGNED-66))|(1<<(IDLParserKW_UNION-66))|(1<<(IDLParserKW_ONEWAY-66))|(1<<(IDLParserKW_ANY-66))|(1<<(IDLParserKW_CHAR-66))|(1<<(IDLParserKW_FLOAT-66))|(1<<(IDLParserKW_BOOLEAN-66))|(1<<(IDLParserKW_DOUBLE-66))|(1<<(IDLParserKW_TYPEPREFIX-66))|(1<<(IDLParserKW_TYPEID-66))|(1<<(IDLParserKW_ATTRIBUTE-66)))) != 0) || _la == IDLParserID {
		{
			p.SetState(435)
			p.Value_element()
		}

		p.SetState(440)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(441)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IValue_headerContext is an interface to support dynamic dispatch.
type IValue_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValue_headerContext differentiates from other interfaces.
	IsValue_headerContext()
}

type Value_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_headerContext() *Value_headerContext {
	var p = new(Value_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_value_header
	return p
}

func (*Value_headerContext) IsValue_headerContext() {}

func NewValue_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_headerContext {
	var p = new(Value_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_value_header

	return p
}

func (s *Value_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_headerContext) KW_VALUETYPE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_VALUETYPE, 0)
}

func (s *Value_headerContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Value_headerContext) Value_inheritance_spec() IValue_inheritance_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_inheritance_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_inheritance_specContext)
}

func (s *Value_headerContext) KW_CUSTOM() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_CUSTOM, 0)
}

func (s *Value_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterValue_header(s)
	}
}

func (s *Value_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitValue_header(s)
	}
}

func (p *IDLParser) Value_header() (localctx IValue_headerContext) {
	localctx = NewValue_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, IDLParserRULE_value_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(444)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_CUSTOM {
		{
			p.SetState(443)
			p.Match(IDLParserKW_CUSTOM)
		}

	}
	{
		p.SetState(446)
		p.Match(IDLParserKW_VALUETYPE)
	}
	{
		p.SetState(447)
		p.Match(IDLParserID)
	}
	{
		p.SetState(448)
		p.Value_inheritance_spec()
	}

	return localctx
}

// IValue_inheritance_specContext is an interface to support dynamic dispatch.
type IValue_inheritance_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValue_inheritance_specContext differentiates from other interfaces.
	IsValue_inheritance_specContext()
}

type Value_inheritance_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_inheritance_specContext() *Value_inheritance_specContext {
	var p = new(Value_inheritance_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_value_inheritance_spec
	return p
}

func (*Value_inheritance_specContext) IsValue_inheritance_specContext() {}

func NewValue_inheritance_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_inheritance_specContext {
	var p = new(Value_inheritance_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_value_inheritance_spec

	return p
}

func (s *Value_inheritance_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_inheritance_specContext) COLON() antlr.TerminalNode {
	return s.GetToken(IDLParserCOLON, 0)
}

func (s *Value_inheritance_specContext) AllValue_name() []IValue_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValue_nameContext)(nil)).Elem())
	var tst = make([]IValue_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValue_nameContext)
		}
	}

	return tst
}

func (s *Value_inheritance_specContext) Value_name(i int) IValue_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValue_nameContext)
}

func (s *Value_inheritance_specContext) KW_SUPPORTS() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_SUPPORTS, 0)
}

func (s *Value_inheritance_specContext) AllInterface_name() []IInterface_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInterface_nameContext)(nil)).Elem())
	var tst = make([]IInterface_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInterface_nameContext)
		}
	}

	return tst
}

func (s *Value_inheritance_specContext) Interface_name(i int) IInterface_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInterface_nameContext)
}

func (s *Value_inheritance_specContext) KW_TRUNCATABLE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_TRUNCATABLE, 0)
}

func (s *Value_inheritance_specContext) AllCOMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMA)
}

func (s *Value_inheritance_specContext) COMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMA, i)
}

func (s *Value_inheritance_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_inheritance_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_inheritance_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterValue_inheritance_spec(s)
	}
}

func (s *Value_inheritance_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitValue_inheritance_spec(s)
	}
}

func (p *IDLParser) Value_inheritance_spec() (localctx IValue_inheritance_specContext) {
	localctx = NewValue_inheritance_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, IDLParserRULE_value_inheritance_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(462)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserCOLON {
		{
			p.SetState(450)
			p.Match(IDLParserCOLON)
		}
		p.SetState(452)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == IDLParserKW_TRUNCATABLE {
			{
				p.SetState(451)
				p.Match(IDLParserKW_TRUNCATABLE)
			}

		}
		{
			p.SetState(454)
			p.Value_name()
		}
		p.SetState(459)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == IDLParserCOMA {
			{
				p.SetState(455)
				p.Match(IDLParserCOMA)
			}
			{
				p.SetState(456)
				p.Value_name()
			}

			p.SetState(461)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	p.SetState(473)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_SUPPORTS {
		{
			p.SetState(464)
			p.Match(IDLParserKW_SUPPORTS)
		}
		{
			p.SetState(465)
			p.Interface_name()
		}
		p.SetState(470)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == IDLParserCOMA {
			{
				p.SetState(466)
				p.Match(IDLParserCOMA)
			}
			{
				p.SetState(467)
				p.Interface_name()
			}

			p.SetState(472)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IValue_nameContext is an interface to support dynamic dispatch.
type IValue_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValue_nameContext differentiates from other interfaces.
	IsValue_nameContext()
}

type Value_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_nameContext() *Value_nameContext {
	var p = new(Value_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_value_name
	return p
}

func (*Value_nameContext) IsValue_nameContext() {}

func NewValue_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_nameContext {
	var p = new(Value_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_value_name

	return p
}

func (s *Value_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_nameContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Value_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterValue_name(s)
	}
}

func (s *Value_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitValue_name(s)
	}
}

func (p *IDLParser) Value_name() (localctx IValue_nameContext) {
	localctx = NewValue_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, IDLParserRULE_value_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(475)
		p.Scoped_name()
	}

	return localctx
}

// IValue_elementContext is an interface to support dynamic dispatch.
type IValue_elementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValue_elementContext differentiates from other interfaces.
	IsValue_elementContext()
}

type Value_elementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_elementContext() *Value_elementContext {
	var p = new(Value_elementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_value_element
	return p
}

func (*Value_elementContext) IsValue_elementContext() {}

func NewValue_elementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_elementContext {
	var p = new(Value_elementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_value_element

	return p
}

func (s *Value_elementContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_elementContext) Export() IExportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExportContext)
}

func (s *Value_elementContext) State_member() IState_memberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IState_memberContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IState_memberContext)
}

func (s *Value_elementContext) Init_decl() IInit_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_declContext)
}

func (s *Value_elementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_elementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_elementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterValue_element(s)
	}
}

func (s *Value_elementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitValue_element(s)
	}
}

func (p *IDLParser) Value_element() (localctx IValue_elementContext) {
	localctx = NewValue_elementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, IDLParserRULE_value_element)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(480)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserDOUBLE_COLON, IDLParserKW_STRING, IDLParserKW_TYPEDEF, IDLParserKW_OCTET, IDLParserKW_STRUCT, IDLParserKW_NATIVE, IDLParserKW_READONLY, IDLParserKW_VOID, IDLParserKW_WCHAR, IDLParserKW_SHORT, IDLParserKW_LONG, IDLParserKW_ENUM, IDLParserKW_WSTRING, IDLParserKW_EXCEPTION, IDLParserKW_CONST, IDLParserKW_VALUEBASE, IDLParserKW_OBJECT, IDLParserKW_UNSIGNED, IDLParserKW_UNION, IDLParserKW_ONEWAY, IDLParserKW_ANY, IDLParserKW_CHAR, IDLParserKW_FLOAT, IDLParserKW_BOOLEAN, IDLParserKW_DOUBLE, IDLParserKW_TYPEPREFIX, IDLParserKW_TYPEID, IDLParserKW_ATTRIBUTE, IDLParserID:
		{
			p.SetState(477)
			p.Export()
		}

	case IDLParserKW_PRIVATE, IDLParserKW_PUBLIC:
		{
			p.SetState(478)
			p.State_member()
		}

	case IDLParserKW_FACTORY:
		{
			p.SetState(479)
			p.Init_decl()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IState_memberContext is an interface to support dynamic dispatch.
type IState_memberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsState_memberContext differentiates from other interfaces.
	IsState_memberContext()
}

type State_memberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyState_memberContext() *State_memberContext {
	var p = new(State_memberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_state_member
	return p
}

func (*State_memberContext) IsState_memberContext() {}

func NewState_memberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *State_memberContext {
	var p = new(State_memberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_state_member

	return p
}

func (s *State_memberContext) GetParser() antlr.Parser { return s.parser }

func (s *State_memberContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *State_memberContext) Declarators() IDeclaratorsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorsContext)
}

func (s *State_memberContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(IDLParserSEMICOLON, 0)
}

func (s *State_memberContext) KW_PUBLIC() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_PUBLIC, 0)
}

func (s *State_memberContext) KW_PRIVATE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_PRIVATE, 0)
}

func (s *State_memberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *State_memberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *State_memberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterState_member(s)
	}
}

func (s *State_memberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitState_member(s)
	}
}

func (p *IDLParser) State_member() (localctx IState_memberContext) {
	localctx = NewState_memberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, IDLParserRULE_state_member)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(482)
		_la = p.GetTokenStream().LA(1)

		if !(_la == IDLParserKW_PRIVATE || _la == IDLParserKW_PUBLIC) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(483)
		p.Type_spec()
	}
	{
		p.SetState(484)
		p.Declarators()
	}
	{
		p.SetState(485)
		p.Match(IDLParserSEMICOLON)
	}

	return localctx
}

// IInit_declContext is an interface to support dynamic dispatch.
type IInit_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInit_declContext differentiates from other interfaces.
	IsInit_declContext()
}

type Init_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInit_declContext() *Init_declContext {
	var p = new(Init_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_init_decl
	return p
}

func (*Init_declContext) IsInit_declContext() {}

func NewInit_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Init_declContext {
	var p = new(Init_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_init_decl

	return p
}

func (s *Init_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Init_declContext) KW_FACTORY() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_FACTORY, 0)
}

func (s *Init_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Init_declContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACKET, 0)
}

func (s *Init_declContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACKET, 0)
}

func (s *Init_declContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(IDLParserSEMICOLON, 0)
}

func (s *Init_declContext) Init_param_decls() IInit_param_declsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_param_declsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_param_declsContext)
}

func (s *Init_declContext) Raises_expr() IRaises_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRaises_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRaises_exprContext)
}

func (s *Init_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Init_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Init_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInit_decl(s)
	}
}

func (s *Init_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInit_decl(s)
	}
}

func (p *IDLParser) Init_decl() (localctx IInit_declContext) {
	localctx = NewInit_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, IDLParserRULE_init_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(487)
		p.Match(IDLParserKW_FACTORY)
	}
	{
		p.SetState(488)
		p.Match(IDLParserID)
	}
	{
		p.SetState(489)
		p.Match(IDLParserLEFT_BRACKET)
	}
	p.SetState(491)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_IN {
		{
			p.SetState(490)
			p.Init_param_decls()
		}

	}
	{
		p.SetState(493)
		p.Match(IDLParserRIGHT_BRACKET)
	}
	p.SetState(495)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_RAISES {
		{
			p.SetState(494)
			p.Raises_expr()
		}

	}
	{
		p.SetState(497)
		p.Match(IDLParserSEMICOLON)
	}

	return localctx
}

// IInit_param_declsContext is an interface to support dynamic dispatch.
type IInit_param_declsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInit_param_declsContext differentiates from other interfaces.
	IsInit_param_declsContext()
}

type Init_param_declsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInit_param_declsContext() *Init_param_declsContext {
	var p = new(Init_param_declsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_init_param_decls
	return p
}

func (*Init_param_declsContext) IsInit_param_declsContext() {}

func NewInit_param_declsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Init_param_declsContext {
	var p = new(Init_param_declsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_init_param_decls

	return p
}

func (s *Init_param_declsContext) GetParser() antlr.Parser { return s.parser }

func (s *Init_param_declsContext) AllInit_param_decl() []IInit_param_declContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IInit_param_declContext)(nil)).Elem())
	var tst = make([]IInit_param_declContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IInit_param_declContext)
		}
	}

	return tst
}

func (s *Init_param_declsContext) Init_param_decl(i int) IInit_param_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_param_declContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IInit_param_declContext)
}

func (s *Init_param_declsContext) AllCOMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMA)
}

func (s *Init_param_declsContext) COMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMA, i)
}

func (s *Init_param_declsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Init_param_declsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Init_param_declsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInit_param_decls(s)
	}
}

func (s *Init_param_declsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInit_param_decls(s)
	}
}

func (p *IDLParser) Init_param_decls() (localctx IInit_param_declsContext) {
	localctx = NewInit_param_declsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, IDLParserRULE_init_param_decls)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(499)
		p.Init_param_decl()
	}
	p.SetState(504)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserCOMA {
		{
			p.SetState(500)
			p.Match(IDLParserCOMA)
		}
		{
			p.SetState(501)
			p.Init_param_decl()
		}

		p.SetState(506)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInit_param_declContext is an interface to support dynamic dispatch.
type IInit_param_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInit_param_declContext differentiates from other interfaces.
	IsInit_param_declContext()
}

type Init_param_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInit_param_declContext() *Init_param_declContext {
	var p = new(Init_param_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_init_param_decl
	return p
}

func (*Init_param_declContext) IsInit_param_declContext() {}

func NewInit_param_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Init_param_declContext {
	var p = new(Init_param_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_init_param_decl

	return p
}

func (s *Init_param_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Init_param_declContext) Init_param_attribute() IInit_param_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_param_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_param_attributeContext)
}

func (s *Init_param_declContext) Param_type_spec() IParam_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_type_specContext)
}

func (s *Init_param_declContext) Simple_declarator() ISimple_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_declaratorContext)
}

func (s *Init_param_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Init_param_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Init_param_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInit_param_decl(s)
	}
}

func (s *Init_param_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInit_param_decl(s)
	}
}

func (p *IDLParser) Init_param_decl() (localctx IInit_param_declContext) {
	localctx = NewInit_param_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, IDLParserRULE_init_param_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(507)
		p.Init_param_attribute()
	}
	{
		p.SetState(508)
		p.Param_type_spec()
	}
	{
		p.SetState(509)
		p.Simple_declarator()
	}

	return localctx
}

// IInit_param_attributeContext is an interface to support dynamic dispatch.
type IInit_param_attributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInit_param_attributeContext differentiates from other interfaces.
	IsInit_param_attributeContext()
}

type Init_param_attributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInit_param_attributeContext() *Init_param_attributeContext {
	var p = new(Init_param_attributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_init_param_attribute
	return p
}

func (*Init_param_attributeContext) IsInit_param_attributeContext() {}

func NewInit_param_attributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Init_param_attributeContext {
	var p = new(Init_param_attributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_init_param_attribute

	return p
}

func (s *Init_param_attributeContext) GetParser() antlr.Parser { return s.parser }

func (s *Init_param_attributeContext) KW_IN() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_IN, 0)
}

func (s *Init_param_attributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Init_param_attributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Init_param_attributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInit_param_attribute(s)
	}
}

func (s *Init_param_attributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInit_param_attribute(s)
	}
}

func (p *IDLParser) Init_param_attribute() (localctx IInit_param_attributeContext) {
	localctx = NewInit_param_attributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, IDLParserRULE_init_param_attribute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(511)
		p.Match(IDLParserKW_IN)
	}

	return localctx
}

// IConst_declContext is an interface to support dynamic dispatch.
type IConst_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConst_declContext differentiates from other interfaces.
	IsConst_declContext()
}

type Const_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConst_declContext() *Const_declContext {
	var p = new(Const_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_const_decl
	return p
}

func (*Const_declContext) IsConst_declContext() {}

func NewConst_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Const_declContext {
	var p = new(Const_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_const_decl

	return p
}

func (s *Const_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Const_declContext) KW_CONST() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_CONST, 0)
}

func (s *Const_declContext) Const_type() IConst_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_typeContext)
}

func (s *Const_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Const_declContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(IDLParserEQUAL, 0)
}

func (s *Const_declContext) Const_exp() IConst_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_expContext)
}

func (s *Const_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Const_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Const_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterConst_decl(s)
	}
}

func (s *Const_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitConst_decl(s)
	}
}

func (p *IDLParser) Const_decl() (localctx IConst_declContext) {
	localctx = NewConst_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, IDLParserRULE_const_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(513)
		p.Match(IDLParserKW_CONST)
	}
	{
		p.SetState(514)
		p.Const_type()
	}
	{
		p.SetState(515)
		p.Match(IDLParserID)
	}
	{
		p.SetState(516)
		p.Match(IDLParserEQUAL)
	}
	{
		p.SetState(517)
		p.Const_exp()
	}

	return localctx
}

// IConst_typeContext is an interface to support dynamic dispatch.
type IConst_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConst_typeContext differentiates from other interfaces.
	IsConst_typeContext()
}

type Const_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConst_typeContext() *Const_typeContext {
	var p = new(Const_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_const_type
	return p
}

func (*Const_typeContext) IsConst_typeContext() {}

func NewConst_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Const_typeContext {
	var p = new(Const_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_const_type

	return p
}

func (s *Const_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Const_typeContext) Integer_type() IInteger_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_typeContext)
}

func (s *Const_typeContext) Char_type() IChar_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChar_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChar_typeContext)
}

func (s *Const_typeContext) Wide_char_type() IWide_char_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWide_char_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWide_char_typeContext)
}

func (s *Const_typeContext) Boolean_type() IBoolean_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBoolean_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBoolean_typeContext)
}

func (s *Const_typeContext) Floating_pt_type() IFloating_pt_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloating_pt_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFloating_pt_typeContext)
}

func (s *Const_typeContext) String_type() IString_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_typeContext)
}

func (s *Const_typeContext) Wide_string_type() IWide_string_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWide_string_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWide_string_typeContext)
}

func (s *Const_typeContext) Fixed_pt_const_type() IFixed_pt_const_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFixed_pt_const_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFixed_pt_const_typeContext)
}

func (s *Const_typeContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Const_typeContext) Octet_type() IOctet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOctet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOctet_typeContext)
}

func (s *Const_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Const_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Const_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterConst_type(s)
	}
}

func (s *Const_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitConst_type(s)
	}
}

func (p *IDLParser) Const_type() (localctx IConst_typeContext) {
	localctx = NewConst_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, IDLParserRULE_const_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(529)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 27, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(519)
			p.Integer_type()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(520)
			p.Char_type()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(521)
			p.Wide_char_type()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(522)
			p.Boolean_type()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(523)
			p.Floating_pt_type()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(524)
			p.String_type()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(525)
			p.Wide_string_type()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(526)
			p.Fixed_pt_const_type()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(527)
			p.Scoped_name()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(528)
			p.Octet_type()
		}

	}

	return localctx
}

// IConst_expContext is an interface to support dynamic dispatch.
type IConst_expContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConst_expContext differentiates from other interfaces.
	IsConst_expContext()
}

type Const_expContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConst_expContext() *Const_expContext {
	var p = new(Const_expContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_const_exp
	return p
}

func (*Const_expContext) IsConst_expContext() {}

func NewConst_expContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Const_expContext {
	var p = new(Const_expContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_const_exp

	return p
}

func (s *Const_expContext) GetParser() antlr.Parser { return s.parser }

func (s *Const_expContext) Or_expr() IOr_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOr_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOr_exprContext)
}

func (s *Const_expContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Const_expContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Const_expContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterConst_exp(s)
	}
}

func (s *Const_expContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitConst_exp(s)
	}
}

func (p *IDLParser) Const_exp() (localctx IConst_expContext) {
	localctx = NewConst_expContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, IDLParserRULE_const_exp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(531)
		p.Or_expr()
	}

	return localctx
}

// IOr_exprContext is an interface to support dynamic dispatch.
type IOr_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOr_exprContext differentiates from other interfaces.
	IsOr_exprContext()
}

type Or_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOr_exprContext() *Or_exprContext {
	var p = new(Or_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_or_expr
	return p
}

func (*Or_exprContext) IsOr_exprContext() {}

func NewOr_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Or_exprContext {
	var p = new(Or_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_or_expr

	return p
}

func (s *Or_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Or_exprContext) AllXor_expr() []IXor_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IXor_exprContext)(nil)).Elem())
	var tst = make([]IXor_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IXor_exprContext)
		}
	}

	return tst
}

func (s *Or_exprContext) Xor_expr(i int) IXor_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IXor_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IXor_exprContext)
}

func (s *Or_exprContext) AllPIPE() []antlr.TerminalNode {
	return s.GetTokens(IDLParserPIPE)
}

func (s *Or_exprContext) PIPE(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserPIPE, i)
}

func (s *Or_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Or_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Or_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterOr_expr(s)
	}
}

func (s *Or_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitOr_expr(s)
	}
}

func (p *IDLParser) Or_expr() (localctx IOr_exprContext) {
	localctx = NewOr_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, IDLParserRULE_or_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(533)
		p.Xor_expr()
	}
	p.SetState(538)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserPIPE {
		{
			p.SetState(534)
			p.Match(IDLParserPIPE)
		}
		{
			p.SetState(535)
			p.Xor_expr()
		}

		p.SetState(540)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IXor_exprContext is an interface to support dynamic dispatch.
type IXor_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsXor_exprContext differentiates from other interfaces.
	IsXor_exprContext()
}

type Xor_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXor_exprContext() *Xor_exprContext {
	var p = new(Xor_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_xor_expr
	return p
}

func (*Xor_exprContext) IsXor_exprContext() {}

func NewXor_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Xor_exprContext {
	var p = new(Xor_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_xor_expr

	return p
}

func (s *Xor_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Xor_exprContext) AllAnd_expr() []IAnd_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnd_exprContext)(nil)).Elem())
	var tst = make([]IAnd_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnd_exprContext)
		}
	}

	return tst
}

func (s *Xor_exprContext) And_expr(i int) IAnd_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnd_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnd_exprContext)
}

func (s *Xor_exprContext) AllCARET() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCARET)
}

func (s *Xor_exprContext) CARET(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCARET, i)
}

func (s *Xor_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Xor_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Xor_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterXor_expr(s)
	}
}

func (s *Xor_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitXor_expr(s)
	}
}

func (p *IDLParser) Xor_expr() (localctx IXor_exprContext) {
	localctx = NewXor_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, IDLParserRULE_xor_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(541)
		p.And_expr()
	}
	p.SetState(546)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserCARET {
		{
			p.SetState(542)
			p.Match(IDLParserCARET)
		}
		{
			p.SetState(543)
			p.And_expr()
		}

		p.SetState(548)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAnd_exprContext is an interface to support dynamic dispatch.
type IAnd_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnd_exprContext differentiates from other interfaces.
	IsAnd_exprContext()
}

type And_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnd_exprContext() *And_exprContext {
	var p = new(And_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_and_expr
	return p
}

func (*And_exprContext) IsAnd_exprContext() {}

func NewAnd_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *And_exprContext {
	var p = new(And_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_and_expr

	return p
}

func (s *And_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *And_exprContext) AllShift_expr() []IShift_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IShift_exprContext)(nil)).Elem())
	var tst = make([]IShift_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IShift_exprContext)
		}
	}

	return tst
}

func (s *And_exprContext) Shift_expr(i int) IShift_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IShift_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IShift_exprContext)
}

func (s *And_exprContext) AllAMPERSAND() []antlr.TerminalNode {
	return s.GetTokens(IDLParserAMPERSAND)
}

func (s *And_exprContext) AMPERSAND(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserAMPERSAND, i)
}

func (s *And_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *And_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *And_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAnd_expr(s)
	}
}

func (s *And_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAnd_expr(s)
	}
}

func (p *IDLParser) And_expr() (localctx IAnd_exprContext) {
	localctx = NewAnd_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, IDLParserRULE_and_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(549)
		p.Shift_expr()
	}
	p.SetState(554)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserAMPERSAND {
		{
			p.SetState(550)
			p.Match(IDLParserAMPERSAND)
		}
		{
			p.SetState(551)
			p.Shift_expr()
		}

		p.SetState(556)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IShift_exprContext is an interface to support dynamic dispatch.
type IShift_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsShift_exprContext differentiates from other interfaces.
	IsShift_exprContext()
}

type Shift_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShift_exprContext() *Shift_exprContext {
	var p = new(Shift_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_shift_expr
	return p
}

func (*Shift_exprContext) IsShift_exprContext() {}

func NewShift_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Shift_exprContext {
	var p = new(Shift_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_shift_expr

	return p
}

func (s *Shift_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Shift_exprContext) AllAdd_expr() []IAdd_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAdd_exprContext)(nil)).Elem())
	var tst = make([]IAdd_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAdd_exprContext)
		}
	}

	return tst
}

func (s *Shift_exprContext) Add_expr(i int) IAdd_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdd_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAdd_exprContext)
}

func (s *Shift_exprContext) AllRIGHT_SHIFT() []antlr.TerminalNode {
	return s.GetTokens(IDLParserRIGHT_SHIFT)
}

func (s *Shift_exprContext) RIGHT_SHIFT(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_SHIFT, i)
}

func (s *Shift_exprContext) AllLEFT_SHIFT() []antlr.TerminalNode {
	return s.GetTokens(IDLParserLEFT_SHIFT)
}

func (s *Shift_exprContext) LEFT_SHIFT(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_SHIFT, i)
}

func (s *Shift_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Shift_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Shift_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterShift_expr(s)
	}
}

func (s *Shift_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitShift_expr(s)
	}
}

func (p *IDLParser) Shift_expr() (localctx IShift_exprContext) {
	localctx = NewShift_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, IDLParserRULE_shift_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(557)
		p.Add_expr()
	}
	p.SetState(562)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserRIGHT_SHIFT || _la == IDLParserLEFT_SHIFT {
		{
			p.SetState(558)
			_la = p.GetTokenStream().LA(1)

			if !(_la == IDLParserRIGHT_SHIFT || _la == IDLParserLEFT_SHIFT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(559)
			p.Add_expr()
		}

		p.SetState(564)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAdd_exprContext is an interface to support dynamic dispatch.
type IAdd_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdd_exprContext differentiates from other interfaces.
	IsAdd_exprContext()
}

type Add_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdd_exprContext() *Add_exprContext {
	var p = new(Add_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_add_expr
	return p
}

func (*Add_exprContext) IsAdd_exprContext() {}

func NewAdd_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Add_exprContext {
	var p = new(Add_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_add_expr

	return p
}

func (s *Add_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Add_exprContext) AllMult_expr() []IMult_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMult_exprContext)(nil)).Elem())
	var tst = make([]IMult_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMult_exprContext)
		}
	}

	return tst
}

func (s *Add_exprContext) Mult_expr(i int) IMult_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMult_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMult_exprContext)
}

func (s *Add_exprContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(IDLParserPLUS)
}

func (s *Add_exprContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserPLUS, i)
}

func (s *Add_exprContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(IDLParserMINUS)
}

func (s *Add_exprContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserMINUS, i)
}

func (s *Add_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Add_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Add_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAdd_expr(s)
	}
}

func (s *Add_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAdd_expr(s)
	}
}

func (p *IDLParser) Add_expr() (localctx IAdd_exprContext) {
	localctx = NewAdd_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, IDLParserRULE_add_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(565)
		p.Mult_expr()
	}
	p.SetState(570)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserPLUS || _la == IDLParserMINUS {
		{
			p.SetState(566)
			_la = p.GetTokenStream().LA(1)

			if !(_la == IDLParserPLUS || _la == IDLParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(567)
			p.Mult_expr()
		}

		p.SetState(572)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMult_exprContext is an interface to support dynamic dispatch.
type IMult_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMult_exprContext differentiates from other interfaces.
	IsMult_exprContext()
}

type Mult_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMult_exprContext() *Mult_exprContext {
	var p = new(Mult_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_mult_expr
	return p
}

func (*Mult_exprContext) IsMult_exprContext() {}

func NewMult_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mult_exprContext {
	var p = new(Mult_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_mult_expr

	return p
}

func (s *Mult_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Mult_exprContext) AllUnary_expr() []IUnary_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnary_exprContext)(nil)).Elem())
	var tst = make([]IUnary_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnary_exprContext)
		}
	}

	return tst
}

func (s *Mult_exprContext) Unary_expr(i int) IUnary_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnary_exprContext)
}

func (s *Mult_exprContext) AllSTAR() []antlr.TerminalNode {
	return s.GetTokens(IDLParserSTAR)
}

func (s *Mult_exprContext) STAR(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserSTAR, i)
}

func (s *Mult_exprContext) AllSLASH() []antlr.TerminalNode {
	return s.GetTokens(IDLParserSLASH)
}

func (s *Mult_exprContext) SLASH(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserSLASH, i)
}

func (s *Mult_exprContext) AllPERCENT() []antlr.TerminalNode {
	return s.GetTokens(IDLParserPERCENT)
}

func (s *Mult_exprContext) PERCENT(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserPERCENT, i)
}

func (s *Mult_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mult_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mult_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterMult_expr(s)
	}
}

func (s *Mult_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitMult_expr(s)
	}
}

func (p *IDLParser) Mult_expr() (localctx IMult_exprContext) {
	localctx = NewMult_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, IDLParserRULE_mult_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(573)
		p.Unary_expr()
	}
	p.SetState(578)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<IDLParserSLASH)|(1<<IDLParserSTAR)|(1<<IDLParserPERCENT))) != 0 {
		{
			p.SetState(574)
			_la = p.GetTokenStream().LA(1)

			if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<IDLParserSLASH)|(1<<IDLParserSTAR)|(1<<IDLParserPERCENT))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(575)
			p.Unary_expr()
		}

		p.SetState(580)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUnary_exprContext is an interface to support dynamic dispatch.
type IUnary_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_exprContext differentiates from other interfaces.
	IsUnary_exprContext()
}

type Unary_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_exprContext() *Unary_exprContext {
	var p = new(Unary_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_unary_expr
	return p
}

func (*Unary_exprContext) IsUnary_exprContext() {}

func NewUnary_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_exprContext {
	var p = new(Unary_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_unary_expr

	return p
}

func (s *Unary_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_exprContext) Unary_operator() IUnary_operatorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_operatorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnary_operatorContext)
}

func (s *Unary_exprContext) Primary_expr() IPrimary_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_exprContext)
}

func (s *Unary_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterUnary_expr(s)
	}
}

func (s *Unary_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitUnary_expr(s)
	}
}

func (p *IDLParser) Unary_expr() (localctx IUnary_exprContext) {
	localctx = NewUnary_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, IDLParserRULE_unary_expr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(585)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserTILDE, IDLParserPLUS, IDLParserMINUS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(581)
			p.Unary_operator()
		}
		{
			p.SetState(582)
			p.Primary_expr()
		}

	case IDLParserINTEGER_LITERAL, IDLParserHEX_LITERAL, IDLParserFLOATING_PT_LITERAL, IDLParserFIXED_PT_LITERAL, IDLParserWIDE_CHARACTER_LITERAL, IDLParserCHARACTER_LITERAL, IDLParserWIDE_STRING_LITERAL, IDLParserSTRING_LITERAL, IDLParserBOOLEAN_LITERAL, IDLParserLEFT_BRACKET, IDLParserDOUBLE_COLON, IDLParserID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(584)
			p.Primary_expr()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUnary_operatorContext is an interface to support dynamic dispatch.
type IUnary_operatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_operatorContext differentiates from other interfaces.
	IsUnary_operatorContext()
}

type Unary_operatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_operatorContext() *Unary_operatorContext {
	var p = new(Unary_operatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_unary_operator
	return p
}

func (*Unary_operatorContext) IsUnary_operatorContext() {}

func NewUnary_operatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_operatorContext {
	var p = new(Unary_operatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_unary_operator

	return p
}

func (s *Unary_operatorContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_operatorContext) MINUS() antlr.TerminalNode {
	return s.GetToken(IDLParserMINUS, 0)
}

func (s *Unary_operatorContext) PLUS() antlr.TerminalNode {
	return s.GetToken(IDLParserPLUS, 0)
}

func (s *Unary_operatorContext) TILDE() antlr.TerminalNode {
	return s.GetToken(IDLParserTILDE, 0)
}

func (s *Unary_operatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_operatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_operatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterUnary_operator(s)
	}
}

func (s *Unary_operatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitUnary_operator(s)
	}
}

func (p *IDLParser) Unary_operator() (localctx IUnary_operatorContext) {
	localctx = NewUnary_operatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, IDLParserRULE_unary_operator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(587)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<IDLParserTILDE)|(1<<IDLParserPLUS)|(1<<IDLParserMINUS))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPrimary_exprContext is an interface to support dynamic dispatch.
type IPrimary_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimary_exprContext differentiates from other interfaces.
	IsPrimary_exprContext()
}

type Primary_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimary_exprContext() *Primary_exprContext {
	var p = new(Primary_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_primary_expr
	return p
}

func (*Primary_exprContext) IsPrimary_exprContext() {}

func NewPrimary_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Primary_exprContext {
	var p = new(Primary_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_primary_expr

	return p
}

func (s *Primary_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Primary_exprContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Primary_exprContext) Literal() ILiteralContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILiteralContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *Primary_exprContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACKET, 0)
}

func (s *Primary_exprContext) Const_exp() IConst_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_expContext)
}

func (s *Primary_exprContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACKET, 0)
}

func (s *Primary_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Primary_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Primary_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterPrimary_expr(s)
	}
}

func (s *Primary_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitPrimary_expr(s)
	}
}

func (p *IDLParser) Primary_expr() (localctx IPrimary_exprContext) {
	localctx = NewPrimary_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, IDLParserRULE_primary_expr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(595)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserDOUBLE_COLON, IDLParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(589)
			p.Scoped_name()
		}

	case IDLParserINTEGER_LITERAL, IDLParserHEX_LITERAL, IDLParserFLOATING_PT_LITERAL, IDLParserFIXED_PT_LITERAL, IDLParserWIDE_CHARACTER_LITERAL, IDLParserCHARACTER_LITERAL, IDLParserWIDE_STRING_LITERAL, IDLParserSTRING_LITERAL, IDLParserBOOLEAN_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(590)
			p.Literal()
		}

	case IDLParserLEFT_BRACKET:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(591)
			p.Match(IDLParserLEFT_BRACKET)
		}
		{
			p.SetState(592)
			p.Const_exp()
		}
		{
			p.SetState(593)
			p.Match(IDLParserRIGHT_BRACKET)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) HEX_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserHEX_LITERAL, 0)
}

func (s *LiteralContext) INTEGER_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserINTEGER_LITERAL, 0)
}

func (s *LiteralContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserSTRING_LITERAL, 0)
}

func (s *LiteralContext) WIDE_STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserWIDE_STRING_LITERAL, 0)
}

func (s *LiteralContext) CHARACTER_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserCHARACTER_LITERAL, 0)
}

func (s *LiteralContext) WIDE_CHARACTER_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserWIDE_CHARACTER_LITERAL, 0)
}

func (s *LiteralContext) FIXED_PT_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserFIXED_PT_LITERAL, 0)
}

func (s *LiteralContext) FLOATING_PT_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserFLOATING_PT_LITERAL, 0)
}

func (s *LiteralContext) BOOLEAN_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserBOOLEAN_LITERAL, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (p *IDLParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, IDLParserRULE_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(597)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<IDLParserINTEGER_LITERAL)|(1<<IDLParserHEX_LITERAL)|(1<<IDLParserFLOATING_PT_LITERAL)|(1<<IDLParserFIXED_PT_LITERAL)|(1<<IDLParserWIDE_CHARACTER_LITERAL)|(1<<IDLParserCHARACTER_LITERAL)|(1<<IDLParserWIDE_STRING_LITERAL)|(1<<IDLParserSTRING_LITERAL)|(1<<IDLParserBOOLEAN_LITERAL))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPositive_int_constContext is an interface to support dynamic dispatch.
type IPositive_int_constContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPositive_int_constContext differentiates from other interfaces.
	IsPositive_int_constContext()
}

type Positive_int_constContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPositive_int_constContext() *Positive_int_constContext {
	var p = new(Positive_int_constContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_positive_int_const
	return p
}

func (*Positive_int_constContext) IsPositive_int_constContext() {}

func NewPositive_int_constContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Positive_int_constContext {
	var p = new(Positive_int_constContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_positive_int_const

	return p
}

func (s *Positive_int_constContext) GetParser() antlr.Parser { return s.parser }

func (s *Positive_int_constContext) Const_exp() IConst_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_expContext)
}

func (s *Positive_int_constContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Positive_int_constContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Positive_int_constContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterPositive_int_const(s)
	}
}

func (s *Positive_int_constContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitPositive_int_const(s)
	}
}

func (p *IDLParser) Positive_int_const() (localctx IPositive_int_constContext) {
	localctx = NewPositive_int_constContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, IDLParserRULE_positive_int_const)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(599)
		p.Const_exp()
	}

	return localctx
}

// IType_declContext is an interface to support dynamic dispatch.
type IType_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_declContext differentiates from other interfaces.
	IsType_declContext()
}

type Type_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_declContext() *Type_declContext {
	var p = new(Type_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_type_decl
	return p
}

func (*Type_declContext) IsType_declContext() {}

func NewType_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_declContext {
	var p = new(Type_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_type_decl

	return p
}

func (s *Type_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_declContext) KW_TYPEDEF() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_TYPEDEF, 0)
}

func (s *Type_declContext) Type_declarator() IType_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_declaratorContext)
}

func (s *Type_declContext) Struct_type() IStruct_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_typeContext)
}

func (s *Type_declContext) Union_type() IUnion_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnion_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnion_typeContext)
}

func (s *Type_declContext) Enum_type() IEnum_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_typeContext)
}

func (s *Type_declContext) KW_NATIVE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_NATIVE, 0)
}

func (s *Type_declContext) Simple_declarator() ISimple_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_declaratorContext)
}

func (s *Type_declContext) Constr_forward_decl() IConstr_forward_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstr_forward_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstr_forward_declContext)
}

func (s *Type_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterType_decl(s)
	}
}

func (s *Type_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitType_decl(s)
	}
}

func (p *IDLParser) Type_decl() (localctx IType_declContext) {
	localctx = NewType_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, IDLParserRULE_type_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(609)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 36, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(601)
			p.Match(IDLParserKW_TYPEDEF)
		}
		{
			p.SetState(602)
			p.Type_declarator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(603)
			p.Struct_type()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(604)
			p.Union_type()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(605)
			p.Enum_type()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(606)
			p.Match(IDLParserKW_NATIVE)
		}
		{
			p.SetState(607)
			p.Simple_declarator()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(608)
			p.Constr_forward_decl()
		}

	}

	return localctx
}

// IType_declaratorContext is an interface to support dynamic dispatch.
type IType_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_declaratorContext differentiates from other interfaces.
	IsType_declaratorContext()
}

type Type_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_declaratorContext() *Type_declaratorContext {
	var p = new(Type_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_type_declarator
	return p
}

func (*Type_declaratorContext) IsType_declaratorContext() {}

func NewType_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_declaratorContext {
	var p = new(Type_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_type_declarator

	return p
}

func (s *Type_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_declaratorContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Type_declaratorContext) Declarators() IDeclaratorsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorsContext)
}

func (s *Type_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterType_declarator(s)
	}
}

func (s *Type_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitType_declarator(s)
	}
}

func (p *IDLParser) Type_declarator() (localctx IType_declaratorContext) {
	localctx = NewType_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, IDLParserRULE_type_declarator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(611)
		p.Type_spec()
	}
	{
		p.SetState(612)
		p.Declarators()
	}

	return localctx
}

// IType_specContext is an interface to support dynamic dispatch.
type IType_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_specContext differentiates from other interfaces.
	IsType_specContext()
}

type Type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_specContext() *Type_specContext {
	var p = new(Type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_type_spec
	return p
}

func (*Type_specContext) IsType_specContext() {}

func NewType_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_specContext {
	var p = new(Type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_type_spec

	return p
}

func (s *Type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_specContext) Simple_type_spec() ISimple_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_type_specContext)
}

func (s *Type_specContext) Constr_type_spec() IConstr_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstr_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstr_type_specContext)
}

func (s *Type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterType_spec(s)
	}
}

func (s *Type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitType_spec(s)
	}
}

func (p *IDLParser) Type_spec() (localctx IType_specContext) {
	localctx = NewType_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, IDLParserRULE_type_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(616)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserDOUBLE_COLON, IDLParserKW_STRING, IDLParserKW_OCTET, IDLParserKW_SEQUENCE, IDLParserKW_WCHAR, IDLParserKW_SHORT, IDLParserKW_LONG, IDLParserKW_WSTRING, IDLParserKW_VALUEBASE, IDLParserKW_OBJECT, IDLParserKW_UNSIGNED, IDLParserKW_FIXED, IDLParserKW_ANY, IDLParserKW_CHAR, IDLParserKW_FLOAT, IDLParserKW_BOOLEAN, IDLParserKW_DOUBLE, IDLParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(614)
			p.Simple_type_spec()
		}

	case IDLParserKW_STRUCT, IDLParserKW_ENUM, IDLParserKW_UNION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(615)
			p.Constr_type_spec()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISimple_type_specContext is an interface to support dynamic dispatch.
type ISimple_type_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_type_specContext differentiates from other interfaces.
	IsSimple_type_specContext()
}

type Simple_type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_type_specContext() *Simple_type_specContext {
	var p = new(Simple_type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_simple_type_spec
	return p
}

func (*Simple_type_specContext) IsSimple_type_specContext() {}

func NewSimple_type_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_type_specContext {
	var p = new(Simple_type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_simple_type_spec

	return p
}

func (s *Simple_type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_type_specContext) Base_type_spec() IBase_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_type_specContext)
}

func (s *Simple_type_specContext) Template_type_spec() ITemplate_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITemplate_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITemplate_type_specContext)
}

func (s *Simple_type_specContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Simple_type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSimple_type_spec(s)
	}
}

func (s *Simple_type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSimple_type_spec(s)
	}
}

func (p *IDLParser) Simple_type_spec() (localctx ISimple_type_specContext) {
	localctx = NewSimple_type_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, IDLParserRULE_simple_type_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(621)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_OCTET, IDLParserKW_WCHAR, IDLParserKW_SHORT, IDLParserKW_LONG, IDLParserKW_VALUEBASE, IDLParserKW_OBJECT, IDLParserKW_UNSIGNED, IDLParserKW_ANY, IDLParserKW_CHAR, IDLParserKW_FLOAT, IDLParserKW_BOOLEAN, IDLParserKW_DOUBLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(618)
			p.Base_type_spec()
		}

	case IDLParserKW_STRING, IDLParserKW_SEQUENCE, IDLParserKW_WSTRING, IDLParserKW_FIXED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(619)
			p.Template_type_spec()
		}

	case IDLParserDOUBLE_COLON, IDLParserID:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(620)
			p.Scoped_name()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBase_type_specContext is an interface to support dynamic dispatch.
type IBase_type_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBase_type_specContext differentiates from other interfaces.
	IsBase_type_specContext()
}

type Base_type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBase_type_specContext() *Base_type_specContext {
	var p = new(Base_type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_base_type_spec
	return p
}

func (*Base_type_specContext) IsBase_type_specContext() {}

func NewBase_type_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Base_type_specContext {
	var p = new(Base_type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_base_type_spec

	return p
}

func (s *Base_type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Base_type_specContext) Floating_pt_type() IFloating_pt_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFloating_pt_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFloating_pt_typeContext)
}

func (s *Base_type_specContext) Integer_type() IInteger_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_typeContext)
}

func (s *Base_type_specContext) Char_type() IChar_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChar_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChar_typeContext)
}

func (s *Base_type_specContext) Wide_char_type() IWide_char_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWide_char_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWide_char_typeContext)
}

func (s *Base_type_specContext) Boolean_type() IBoolean_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBoolean_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBoolean_typeContext)
}

func (s *Base_type_specContext) Octet_type() IOctet_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOctet_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOctet_typeContext)
}

func (s *Base_type_specContext) Any_type() IAny_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAny_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAny_typeContext)
}

func (s *Base_type_specContext) Object_type() IObject_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObject_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObject_typeContext)
}

func (s *Base_type_specContext) Value_base_type() IValue_base_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_base_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_base_typeContext)
}

func (s *Base_type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Base_type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Base_type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterBase_type_spec(s)
	}
}

func (s *Base_type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitBase_type_spec(s)
	}
}

func (p *IDLParser) Base_type_spec() (localctx IBase_type_specContext) {
	localctx = NewBase_type_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, IDLParserRULE_base_type_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(632)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(623)
			p.Floating_pt_type()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(624)
			p.Integer_type()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(625)
			p.Char_type()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(626)
			p.Wide_char_type()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(627)
			p.Boolean_type()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(628)
			p.Octet_type()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(629)
			p.Any_type()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(630)
			p.Object_type()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(631)
			p.Value_base_type()
		}

	}

	return localctx
}

// ITemplate_type_specContext is an interface to support dynamic dispatch.
type ITemplate_type_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTemplate_type_specContext differentiates from other interfaces.
	IsTemplate_type_specContext()
}

type Template_type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemplate_type_specContext() *Template_type_specContext {
	var p = new(Template_type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_template_type_spec
	return p
}

func (*Template_type_specContext) IsTemplate_type_specContext() {}

func NewTemplate_type_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Template_type_specContext {
	var p = new(Template_type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_template_type_spec

	return p
}

func (s *Template_type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Template_type_specContext) Sequence_type() ISequence_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISequence_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISequence_typeContext)
}

func (s *Template_type_specContext) String_type() IString_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_typeContext)
}

func (s *Template_type_specContext) Wide_string_type() IWide_string_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWide_string_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWide_string_typeContext)
}

func (s *Template_type_specContext) Fixed_pt_type() IFixed_pt_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFixed_pt_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFixed_pt_typeContext)
}

func (s *Template_type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Template_type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Template_type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterTemplate_type_spec(s)
	}
}

func (s *Template_type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitTemplate_type_spec(s)
	}
}

func (p *IDLParser) Template_type_spec() (localctx ITemplate_type_specContext) {
	localctx = NewTemplate_type_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, IDLParserRULE_template_type_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(638)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_SEQUENCE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(634)
			p.Sequence_type()
		}

	case IDLParserKW_STRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(635)
			p.String_type()
		}

	case IDLParserKW_WSTRING:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(636)
			p.Wide_string_type()
		}

	case IDLParserKW_FIXED:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(637)
			p.Fixed_pt_type()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConstr_type_specContext is an interface to support dynamic dispatch.
type IConstr_type_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstr_type_specContext differentiates from other interfaces.
	IsConstr_type_specContext()
}

type Constr_type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstr_type_specContext() *Constr_type_specContext {
	var p = new(Constr_type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_constr_type_spec
	return p
}

func (*Constr_type_specContext) IsConstr_type_specContext() {}

func NewConstr_type_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constr_type_specContext {
	var p = new(Constr_type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_constr_type_spec

	return p
}

func (s *Constr_type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Constr_type_specContext) Struct_type() IStruct_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStruct_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStruct_typeContext)
}

func (s *Constr_type_specContext) Union_type() IUnion_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnion_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnion_typeContext)
}

func (s *Constr_type_specContext) Enum_type() IEnum_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_typeContext)
}

func (s *Constr_type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constr_type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constr_type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterConstr_type_spec(s)
	}
}

func (s *Constr_type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitConstr_type_spec(s)
	}
}

func (p *IDLParser) Constr_type_spec() (localctx IConstr_type_specContext) {
	localctx = NewConstr_type_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, IDLParserRULE_constr_type_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(643)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_STRUCT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(640)
			p.Struct_type()
		}

	case IDLParserKW_UNION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(641)
			p.Union_type()
		}

	case IDLParserKW_ENUM:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(642)
			p.Enum_type()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDeclaratorsContext is an interface to support dynamic dispatch.
type IDeclaratorsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaratorsContext differentiates from other interfaces.
	IsDeclaratorsContext()
}

type DeclaratorsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaratorsContext() *DeclaratorsContext {
	var p = new(DeclaratorsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_declarators
	return p
}

func (*DeclaratorsContext) IsDeclaratorsContext() {}

func NewDeclaratorsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclaratorsContext {
	var p = new(DeclaratorsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_declarators

	return p
}

func (s *DeclaratorsContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclaratorsContext) AllDeclarator() []IDeclaratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem())
	var tst = make([]IDeclaratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDeclaratorContext)
		}
	}

	return tst
}

func (s *DeclaratorsContext) Declarator(i int) IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *DeclaratorsContext) AllCOMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMA)
}

func (s *DeclaratorsContext) COMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMA, i)
}

func (s *DeclaratorsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclaratorsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclaratorsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterDeclarators(s)
	}
}

func (s *DeclaratorsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitDeclarators(s)
	}
}

func (p *IDLParser) Declarators() (localctx IDeclaratorsContext) {
	localctx = NewDeclaratorsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, IDLParserRULE_declarators)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(645)
		p.Declarator()
	}
	p.SetState(650)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserCOMA {
		{
			p.SetState(646)
			p.Match(IDLParserCOMA)
		}
		{
			p.SetState(647)
			p.Declarator()
		}

		p.SetState(652)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDeclaratorContext is an interface to support dynamic dispatch.
type IDeclaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeclaratorContext differentiates from other interfaces.
	IsDeclaratorContext()
}

type DeclaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeclaratorContext() *DeclaratorContext {
	var p = new(DeclaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_declarator
	return p
}

func (*DeclaratorContext) IsDeclaratorContext() {}

func NewDeclaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeclaratorContext {
	var p = new(DeclaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_declarator

	return p
}

func (s *DeclaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *DeclaratorContext) Simple_declarator() ISimple_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_declaratorContext)
}

func (s *DeclaratorContext) Complex_declarator() IComplex_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComplex_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComplex_declaratorContext)
}

func (s *DeclaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeclaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeclaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterDeclarator(s)
	}
}

func (s *DeclaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitDeclarator(s)
	}
}

func (p *IDLParser) Declarator() (localctx IDeclaratorContext) {
	localctx = NewDeclaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, IDLParserRULE_declarator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(655)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(653)
			p.Simple_declarator()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(654)
			p.Complex_declarator()
		}

	}

	return localctx
}

// ISimple_declaratorContext is an interface to support dynamic dispatch.
type ISimple_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimple_declaratorContext differentiates from other interfaces.
	IsSimple_declaratorContext()
}

type Simple_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimple_declaratorContext() *Simple_declaratorContext {
	var p = new(Simple_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_simple_declarator
	return p
}

func (*Simple_declaratorContext) IsSimple_declaratorContext() {}

func NewSimple_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Simple_declaratorContext {
	var p = new(Simple_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_simple_declarator

	return p
}

func (s *Simple_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Simple_declaratorContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Simple_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Simple_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Simple_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSimple_declarator(s)
	}
}

func (s *Simple_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSimple_declarator(s)
	}
}

func (p *IDLParser) Simple_declarator() (localctx ISimple_declaratorContext) {
	localctx = NewSimple_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, IDLParserRULE_simple_declarator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(657)
		p.Match(IDLParserID)
	}

	return localctx
}

// IComplex_declaratorContext is an interface to support dynamic dispatch.
type IComplex_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComplex_declaratorContext differentiates from other interfaces.
	IsComplex_declaratorContext()
}

type Complex_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComplex_declaratorContext() *Complex_declaratorContext {
	var p = new(Complex_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_complex_declarator
	return p
}

func (*Complex_declaratorContext) IsComplex_declaratorContext() {}

func NewComplex_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Complex_declaratorContext {
	var p = new(Complex_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_complex_declarator

	return p
}

func (s *Complex_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Complex_declaratorContext) Array_declarator() IArray_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_declaratorContext)
}

func (s *Complex_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Complex_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Complex_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterComplex_declarator(s)
	}
}

func (s *Complex_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitComplex_declarator(s)
	}
}

func (p *IDLParser) Complex_declarator() (localctx IComplex_declaratorContext) {
	localctx = NewComplex_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, IDLParserRULE_complex_declarator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(659)
		p.Array_declarator()
	}

	return localctx
}

// IFloating_pt_typeContext is an interface to support dynamic dispatch.
type IFloating_pt_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFloating_pt_typeContext differentiates from other interfaces.
	IsFloating_pt_typeContext()
}

type Floating_pt_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloating_pt_typeContext() *Floating_pt_typeContext {
	var p = new(Floating_pt_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_floating_pt_type
	return p
}

func (*Floating_pt_typeContext) IsFloating_pt_typeContext() {}

func NewFloating_pt_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Floating_pt_typeContext {
	var p = new(Floating_pt_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_floating_pt_type

	return p
}

func (s *Floating_pt_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Floating_pt_typeContext) KW_FLOAT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_FLOAT, 0)
}

func (s *Floating_pt_typeContext) KW_DOUBLE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_DOUBLE, 0)
}

func (s *Floating_pt_typeContext) KW_LONG() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_LONG, 0)
}

func (s *Floating_pt_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Floating_pt_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Floating_pt_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterFloating_pt_type(s)
	}
}

func (s *Floating_pt_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitFloating_pt_type(s)
	}
}

func (p *IDLParser) Floating_pt_type() (localctx IFloating_pt_typeContext) {
	localctx = NewFloating_pt_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, IDLParserRULE_floating_pt_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(665)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_FLOAT:
		{
			p.SetState(661)
			p.Match(IDLParserKW_FLOAT)
		}

	case IDLParserKW_DOUBLE:
		{
			p.SetState(662)
			p.Match(IDLParserKW_DOUBLE)
		}

	case IDLParserKW_LONG:
		{
			p.SetState(663)
			p.Match(IDLParserKW_LONG)
		}
		{
			p.SetState(664)
			p.Match(IDLParserKW_DOUBLE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInteger_typeContext is an interface to support dynamic dispatch.
type IInteger_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInteger_typeContext differentiates from other interfaces.
	IsInteger_typeContext()
}

type Integer_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInteger_typeContext() *Integer_typeContext {
	var p = new(Integer_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_integer_type
	return p
}

func (*Integer_typeContext) IsInteger_typeContext() {}

func NewInteger_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Integer_typeContext {
	var p = new(Integer_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_integer_type

	return p
}

func (s *Integer_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Integer_typeContext) Signed_int() ISigned_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISigned_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISigned_intContext)
}

func (s *Integer_typeContext) Unsigned_int() IUnsigned_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnsigned_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnsigned_intContext)
}

func (s *Integer_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Integer_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Integer_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInteger_type(s)
	}
}

func (s *Integer_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInteger_type(s)
	}
}

func (p *IDLParser) Integer_type() (localctx IInteger_typeContext) {
	localctx = NewInteger_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, IDLParserRULE_integer_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(669)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_SHORT, IDLParserKW_LONG:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(667)
			p.Signed_int()
		}

	case IDLParserKW_UNSIGNED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(668)
			p.Unsigned_int()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISigned_intContext is an interface to support dynamic dispatch.
type ISigned_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSigned_intContext differentiates from other interfaces.
	IsSigned_intContext()
}

type Signed_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySigned_intContext() *Signed_intContext {
	var p = new(Signed_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_signed_int
	return p
}

func (*Signed_intContext) IsSigned_intContext() {}

func NewSigned_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signed_intContext {
	var p = new(Signed_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_signed_int

	return p
}

func (s *Signed_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Signed_intContext) Signed_short_int() ISigned_short_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISigned_short_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISigned_short_intContext)
}

func (s *Signed_intContext) Signed_long_int() ISigned_long_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISigned_long_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISigned_long_intContext)
}

func (s *Signed_intContext) Signed_longlong_int() ISigned_longlong_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISigned_longlong_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISigned_longlong_intContext)
}

func (s *Signed_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signed_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signed_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSigned_int(s)
	}
}

func (s *Signed_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSigned_int(s)
	}
}

func (p *IDLParser) Signed_int() (localctx ISigned_intContext) {
	localctx = NewSigned_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, IDLParserRULE_signed_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(674)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(671)
			p.Signed_short_int()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(672)
			p.Signed_long_int()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(673)
			p.Signed_longlong_int()
		}

	}

	return localctx
}

// ISigned_short_intContext is an interface to support dynamic dispatch.
type ISigned_short_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSigned_short_intContext differentiates from other interfaces.
	IsSigned_short_intContext()
}

type Signed_short_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySigned_short_intContext() *Signed_short_intContext {
	var p = new(Signed_short_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_signed_short_int
	return p
}

func (*Signed_short_intContext) IsSigned_short_intContext() {}

func NewSigned_short_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signed_short_intContext {
	var p = new(Signed_short_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_signed_short_int

	return p
}

func (s *Signed_short_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Signed_short_intContext) KW_SHORT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_SHORT, 0)
}

func (s *Signed_short_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signed_short_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signed_short_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSigned_short_int(s)
	}
}

func (s *Signed_short_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSigned_short_int(s)
	}
}

func (p *IDLParser) Signed_short_int() (localctx ISigned_short_intContext) {
	localctx = NewSigned_short_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, IDLParserRULE_signed_short_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(676)
		p.Match(IDLParserKW_SHORT)
	}

	return localctx
}

// ISigned_long_intContext is an interface to support dynamic dispatch.
type ISigned_long_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSigned_long_intContext differentiates from other interfaces.
	IsSigned_long_intContext()
}

type Signed_long_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySigned_long_intContext() *Signed_long_intContext {
	var p = new(Signed_long_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_signed_long_int
	return p
}

func (*Signed_long_intContext) IsSigned_long_intContext() {}

func NewSigned_long_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signed_long_intContext {
	var p = new(Signed_long_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_signed_long_int

	return p
}

func (s *Signed_long_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Signed_long_intContext) KW_LONG() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_LONG, 0)
}

func (s *Signed_long_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signed_long_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signed_long_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSigned_long_int(s)
	}
}

func (s *Signed_long_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSigned_long_int(s)
	}
}

func (p *IDLParser) Signed_long_int() (localctx ISigned_long_intContext) {
	localctx = NewSigned_long_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, IDLParserRULE_signed_long_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(678)
		p.Match(IDLParserKW_LONG)
	}

	return localctx
}

// ISigned_longlong_intContext is an interface to support dynamic dispatch.
type ISigned_longlong_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSigned_longlong_intContext differentiates from other interfaces.
	IsSigned_longlong_intContext()
}

type Signed_longlong_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySigned_longlong_intContext() *Signed_longlong_intContext {
	var p = new(Signed_longlong_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_signed_longlong_int
	return p
}

func (*Signed_longlong_intContext) IsSigned_longlong_intContext() {}

func NewSigned_longlong_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Signed_longlong_intContext {
	var p = new(Signed_longlong_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_signed_longlong_int

	return p
}

func (s *Signed_longlong_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Signed_longlong_intContext) AllKW_LONG() []antlr.TerminalNode {
	return s.GetTokens(IDLParserKW_LONG)
}

func (s *Signed_longlong_intContext) KW_LONG(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserKW_LONG, i)
}

func (s *Signed_longlong_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Signed_longlong_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Signed_longlong_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSigned_longlong_int(s)
	}
}

func (s *Signed_longlong_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSigned_longlong_int(s)
	}
}

func (p *IDLParser) Signed_longlong_int() (localctx ISigned_longlong_intContext) {
	localctx = NewSigned_longlong_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, IDLParserRULE_signed_longlong_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(680)
		p.Match(IDLParserKW_LONG)
	}
	{
		p.SetState(681)
		p.Match(IDLParserKW_LONG)
	}

	return localctx
}

// IUnsigned_intContext is an interface to support dynamic dispatch.
type IUnsigned_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnsigned_intContext differentiates from other interfaces.
	IsUnsigned_intContext()
}

type Unsigned_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsigned_intContext() *Unsigned_intContext {
	var p = new(Unsigned_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_unsigned_int
	return p
}

func (*Unsigned_intContext) IsUnsigned_intContext() {}

func NewUnsigned_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unsigned_intContext {
	var p = new(Unsigned_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_unsigned_int

	return p
}

func (s *Unsigned_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Unsigned_intContext) Unsigned_short_int() IUnsigned_short_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnsigned_short_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnsigned_short_intContext)
}

func (s *Unsigned_intContext) Unsigned_long_int() IUnsigned_long_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnsigned_long_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnsigned_long_intContext)
}

func (s *Unsigned_intContext) Unsigned_longlong_int() IUnsigned_longlong_intContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnsigned_longlong_intContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUnsigned_longlong_intContext)
}

func (s *Unsigned_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unsigned_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unsigned_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterUnsigned_int(s)
	}
}

func (s *Unsigned_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitUnsigned_int(s)
	}
}

func (p *IDLParser) Unsigned_int() (localctx IUnsigned_intContext) {
	localctx = NewUnsigned_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, IDLParserRULE_unsigned_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(686)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(683)
			p.Unsigned_short_int()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(684)
			p.Unsigned_long_int()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(685)
			p.Unsigned_longlong_int()
		}

	}

	return localctx
}

// IUnsigned_short_intContext is an interface to support dynamic dispatch.
type IUnsigned_short_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnsigned_short_intContext differentiates from other interfaces.
	IsUnsigned_short_intContext()
}

type Unsigned_short_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsigned_short_intContext() *Unsigned_short_intContext {
	var p = new(Unsigned_short_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_unsigned_short_int
	return p
}

func (*Unsigned_short_intContext) IsUnsigned_short_intContext() {}

func NewUnsigned_short_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unsigned_short_intContext {
	var p = new(Unsigned_short_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_unsigned_short_int

	return p
}

func (s *Unsigned_short_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Unsigned_short_intContext) KW_UNSIGNED() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_UNSIGNED, 0)
}

func (s *Unsigned_short_intContext) KW_SHORT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_SHORT, 0)
}

func (s *Unsigned_short_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unsigned_short_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unsigned_short_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterUnsigned_short_int(s)
	}
}

func (s *Unsigned_short_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitUnsigned_short_int(s)
	}
}

func (p *IDLParser) Unsigned_short_int() (localctx IUnsigned_short_intContext) {
	localctx = NewUnsigned_short_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, IDLParserRULE_unsigned_short_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(688)
		p.Match(IDLParserKW_UNSIGNED)
	}
	{
		p.SetState(689)
		p.Match(IDLParserKW_SHORT)
	}

	return localctx
}

// IUnsigned_long_intContext is an interface to support dynamic dispatch.
type IUnsigned_long_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnsigned_long_intContext differentiates from other interfaces.
	IsUnsigned_long_intContext()
}

type Unsigned_long_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsigned_long_intContext() *Unsigned_long_intContext {
	var p = new(Unsigned_long_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_unsigned_long_int
	return p
}

func (*Unsigned_long_intContext) IsUnsigned_long_intContext() {}

func NewUnsigned_long_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unsigned_long_intContext {
	var p = new(Unsigned_long_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_unsigned_long_int

	return p
}

func (s *Unsigned_long_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Unsigned_long_intContext) KW_UNSIGNED() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_UNSIGNED, 0)
}

func (s *Unsigned_long_intContext) KW_LONG() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_LONG, 0)
}

func (s *Unsigned_long_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unsigned_long_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unsigned_long_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterUnsigned_long_int(s)
	}
}

func (s *Unsigned_long_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitUnsigned_long_int(s)
	}
}

func (p *IDLParser) Unsigned_long_int() (localctx IUnsigned_long_intContext) {
	localctx = NewUnsigned_long_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, IDLParserRULE_unsigned_long_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(691)
		p.Match(IDLParserKW_UNSIGNED)
	}
	{
		p.SetState(692)
		p.Match(IDLParserKW_LONG)
	}

	return localctx
}

// IUnsigned_longlong_intContext is an interface to support dynamic dispatch.
type IUnsigned_longlong_intContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnsigned_longlong_intContext differentiates from other interfaces.
	IsUnsigned_longlong_intContext()
}

type Unsigned_longlong_intContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnsigned_longlong_intContext() *Unsigned_longlong_intContext {
	var p = new(Unsigned_longlong_intContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_unsigned_longlong_int
	return p
}

func (*Unsigned_longlong_intContext) IsUnsigned_longlong_intContext() {}

func NewUnsigned_longlong_intContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unsigned_longlong_intContext {
	var p = new(Unsigned_longlong_intContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_unsigned_longlong_int

	return p
}

func (s *Unsigned_longlong_intContext) GetParser() antlr.Parser { return s.parser }

func (s *Unsigned_longlong_intContext) KW_UNSIGNED() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_UNSIGNED, 0)
}

func (s *Unsigned_longlong_intContext) AllKW_LONG() []antlr.TerminalNode {
	return s.GetTokens(IDLParserKW_LONG)
}

func (s *Unsigned_longlong_intContext) KW_LONG(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserKW_LONG, i)
}

func (s *Unsigned_longlong_intContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unsigned_longlong_intContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unsigned_longlong_intContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterUnsigned_longlong_int(s)
	}
}

func (s *Unsigned_longlong_intContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitUnsigned_longlong_int(s)
	}
}

func (p *IDLParser) Unsigned_longlong_int() (localctx IUnsigned_longlong_intContext) {
	localctx = NewUnsigned_longlong_intContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, IDLParserRULE_unsigned_longlong_int)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(694)
		p.Match(IDLParserKW_UNSIGNED)
	}
	{
		p.SetState(695)
		p.Match(IDLParserKW_LONG)
	}
	{
		p.SetState(696)
		p.Match(IDLParserKW_LONG)
	}

	return localctx
}

// IChar_typeContext is an interface to support dynamic dispatch.
type IChar_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChar_typeContext differentiates from other interfaces.
	IsChar_typeContext()
}

type Char_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChar_typeContext() *Char_typeContext {
	var p = new(Char_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_char_type
	return p
}

func (*Char_typeContext) IsChar_typeContext() {}

func NewChar_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Char_typeContext {
	var p = new(Char_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_char_type

	return p
}

func (s *Char_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Char_typeContext) KW_CHAR() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_CHAR, 0)
}

func (s *Char_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Char_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Char_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterChar_type(s)
	}
}

func (s *Char_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitChar_type(s)
	}
}

func (p *IDLParser) Char_type() (localctx IChar_typeContext) {
	localctx = NewChar_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, IDLParserRULE_char_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(698)
		p.Match(IDLParserKW_CHAR)
	}

	return localctx
}

// IWide_char_typeContext is an interface to support dynamic dispatch.
type IWide_char_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWide_char_typeContext differentiates from other interfaces.
	IsWide_char_typeContext()
}

type Wide_char_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWide_char_typeContext() *Wide_char_typeContext {
	var p = new(Wide_char_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_wide_char_type
	return p
}

func (*Wide_char_typeContext) IsWide_char_typeContext() {}

func NewWide_char_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Wide_char_typeContext {
	var p = new(Wide_char_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_wide_char_type

	return p
}

func (s *Wide_char_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Wide_char_typeContext) KW_WCHAR() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_WCHAR, 0)
}

func (s *Wide_char_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Wide_char_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Wide_char_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterWide_char_type(s)
	}
}

func (s *Wide_char_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitWide_char_type(s)
	}
}

func (p *IDLParser) Wide_char_type() (localctx IWide_char_typeContext) {
	localctx = NewWide_char_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, IDLParserRULE_wide_char_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(700)
		p.Match(IDLParserKW_WCHAR)
	}

	return localctx
}

// IBoolean_typeContext is an interface to support dynamic dispatch.
type IBoolean_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBoolean_typeContext differentiates from other interfaces.
	IsBoolean_typeContext()
}

type Boolean_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoolean_typeContext() *Boolean_typeContext {
	var p = new(Boolean_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_boolean_type
	return p
}

func (*Boolean_typeContext) IsBoolean_typeContext() {}

func NewBoolean_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Boolean_typeContext {
	var p = new(Boolean_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_boolean_type

	return p
}

func (s *Boolean_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Boolean_typeContext) KW_BOOLEAN() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_BOOLEAN, 0)
}

func (s *Boolean_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Boolean_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Boolean_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterBoolean_type(s)
	}
}

func (s *Boolean_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitBoolean_type(s)
	}
}

func (p *IDLParser) Boolean_type() (localctx IBoolean_typeContext) {
	localctx = NewBoolean_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, IDLParserRULE_boolean_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.Match(IDLParserKW_BOOLEAN)
	}

	return localctx
}

// IOctet_typeContext is an interface to support dynamic dispatch.
type IOctet_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOctet_typeContext differentiates from other interfaces.
	IsOctet_typeContext()
}

type Octet_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOctet_typeContext() *Octet_typeContext {
	var p = new(Octet_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_octet_type
	return p
}

func (*Octet_typeContext) IsOctet_typeContext() {}

func NewOctet_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Octet_typeContext {
	var p = new(Octet_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_octet_type

	return p
}

func (s *Octet_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Octet_typeContext) KW_OCTET() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_OCTET, 0)
}

func (s *Octet_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Octet_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Octet_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterOctet_type(s)
	}
}

func (s *Octet_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitOctet_type(s)
	}
}

func (p *IDLParser) Octet_type() (localctx IOctet_typeContext) {
	localctx = NewOctet_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, IDLParserRULE_octet_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(704)
		p.Match(IDLParserKW_OCTET)
	}

	return localctx
}

// IAny_typeContext is an interface to support dynamic dispatch.
type IAny_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAny_typeContext differentiates from other interfaces.
	IsAny_typeContext()
}

type Any_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAny_typeContext() *Any_typeContext {
	var p = new(Any_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_any_type
	return p
}

func (*Any_typeContext) IsAny_typeContext() {}

func NewAny_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Any_typeContext {
	var p = new(Any_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_any_type

	return p
}

func (s *Any_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Any_typeContext) KW_ANY() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_ANY, 0)
}

func (s *Any_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Any_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Any_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAny_type(s)
	}
}

func (s *Any_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAny_type(s)
	}
}

func (p *IDLParser) Any_type() (localctx IAny_typeContext) {
	localctx = NewAny_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, IDLParserRULE_any_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(706)
		p.Match(IDLParserKW_ANY)
	}

	return localctx
}

// IObject_typeContext is an interface to support dynamic dispatch.
type IObject_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObject_typeContext differentiates from other interfaces.
	IsObject_typeContext()
}

type Object_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObject_typeContext() *Object_typeContext {
	var p = new(Object_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_object_type
	return p
}

func (*Object_typeContext) IsObject_typeContext() {}

func NewObject_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Object_typeContext {
	var p = new(Object_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_object_type

	return p
}

func (s *Object_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Object_typeContext) KW_OBJECT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_OBJECT, 0)
}

func (s *Object_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Object_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Object_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterObject_type(s)
	}
}

func (s *Object_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitObject_type(s)
	}
}

func (p *IDLParser) Object_type() (localctx IObject_typeContext) {
	localctx = NewObject_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, IDLParserRULE_object_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(708)
		p.Match(IDLParserKW_OBJECT)
	}

	return localctx
}

// IStruct_typeContext is an interface to support dynamic dispatch.
type IStruct_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStruct_typeContext differentiates from other interfaces.
	IsStruct_typeContext()
}

type Struct_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStruct_typeContext() *Struct_typeContext {
	var p = new(Struct_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_struct_type
	return p
}

func (*Struct_typeContext) IsStruct_typeContext() {}

func NewStruct_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Struct_typeContext {
	var p = new(Struct_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_struct_type

	return p
}

func (s *Struct_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Struct_typeContext) KW_STRUCT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_STRUCT, 0)
}

func (s *Struct_typeContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Struct_typeContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Struct_typeContext) Member_list() IMember_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMember_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMember_listContext)
}

func (s *Struct_typeContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Struct_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Struct_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Struct_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterStruct_type(s)
	}
}

func (s *Struct_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitStruct_type(s)
	}
}

func (p *IDLParser) Struct_type() (localctx IStruct_typeContext) {
	localctx = NewStruct_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, IDLParserRULE_struct_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(710)
		p.Match(IDLParserKW_STRUCT)
	}
	{
		p.SetState(711)
		p.Match(IDLParserID)
	}
	{
		p.SetState(712)
		p.Match(IDLParserLEFT_BRACE)
	}
	{
		p.SetState(713)
		p.Member_list()
	}
	{
		p.SetState(714)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IMember_listContext is an interface to support dynamic dispatch.
type IMember_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMember_listContext differentiates from other interfaces.
	IsMember_listContext()
}

type Member_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMember_listContext() *Member_listContext {
	var p = new(Member_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_member_list
	return p
}

func (*Member_listContext) IsMember_listContext() {}

func NewMember_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Member_listContext {
	var p = new(Member_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_member_list

	return p
}

func (s *Member_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Member_listContext) AllMember() []IMemberContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMemberContext)(nil)).Elem())
	var tst = make([]IMemberContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMemberContext)
		}
	}

	return tst
}

func (s *Member_listContext) Member(i int) IMemberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemberContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMemberContext)
}

func (s *Member_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Member_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Member_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterMember_list(s)
	}
}

func (s *Member_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitMember_list(s)
	}
}

func (p *IDLParser) Member_list() (localctx IMember_listContext) {
	localctx = NewMember_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, IDLParserRULE_member_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(717)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(IDLParserDOUBLE_COLON-32))|(1<<(IDLParserKW_STRING-32))|(1<<(IDLParserKW_OCTET-32))|(1<<(IDLParserKW_SEQUENCE-32))|(1<<(IDLParserKW_STRUCT-32))|(1<<(IDLParserKW_WCHAR-32))|(1<<(IDLParserKW_SHORT-32))|(1<<(IDLParserKW_LONG-32))|(1<<(IDLParserKW_ENUM-32))|(1<<(IDLParserKW_WSTRING-32)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(IDLParserKW_VALUEBASE-70))|(1<<(IDLParserKW_OBJECT-70))|(1<<(IDLParserKW_UNSIGNED-70))|(1<<(IDLParserKW_FIXED-70))|(1<<(IDLParserKW_UNION-70))|(1<<(IDLParserKW_ANY-70))|(1<<(IDLParserKW_CHAR-70))|(1<<(IDLParserKW_FLOAT-70))|(1<<(IDLParserKW_BOOLEAN-70))|(1<<(IDLParserKW_DOUBLE-70))|(1<<(IDLParserID-70)))) != 0) {
		{
			p.SetState(716)
			p.Member()
		}

		p.SetState(719)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMemberContext is an interface to support dynamic dispatch.
type IMemberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemberContext differentiates from other interfaces.
	IsMemberContext()
}

type MemberContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemberContext() *MemberContext {
	var p = new(MemberContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_member
	return p
}

func (*MemberContext) IsMemberContext() {}

func NewMemberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemberContext {
	var p = new(MemberContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_member

	return p
}

func (s *MemberContext) GetParser() antlr.Parser { return s.parser }

func (s *MemberContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *MemberContext) Declarators() IDeclaratorsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorsContext)
}

func (s *MemberContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(IDLParserSEMICOLON, 0)
}

func (s *MemberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterMember(s)
	}
}

func (s *MemberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitMember(s)
	}
}

func (p *IDLParser) Member() (localctx IMemberContext) {
	localctx = NewMemberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, IDLParserRULE_member)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(721)
		p.Type_spec()
	}
	{
		p.SetState(722)
		p.Declarators()
	}
	{
		p.SetState(723)
		p.Match(IDLParserSEMICOLON)
	}

	return localctx
}

// IUnion_typeContext is an interface to support dynamic dispatch.
type IUnion_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnion_typeContext differentiates from other interfaces.
	IsUnion_typeContext()
}

type Union_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnion_typeContext() *Union_typeContext {
	var p = new(Union_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_union_type
	return p
}

func (*Union_typeContext) IsUnion_typeContext() {}

func NewUnion_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Union_typeContext {
	var p = new(Union_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_union_type

	return p
}

func (s *Union_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Union_typeContext) KW_UNION() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_UNION, 0)
}

func (s *Union_typeContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Union_typeContext) KW_SWITCH() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_SWITCH, 0)
}

func (s *Union_typeContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACKET, 0)
}

func (s *Union_typeContext) Switch_type_spec() ISwitch_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitch_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISwitch_type_specContext)
}

func (s *Union_typeContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACKET, 0)
}

func (s *Union_typeContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Union_typeContext) Switch_body() ISwitch_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISwitch_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISwitch_bodyContext)
}

func (s *Union_typeContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Union_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Union_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Union_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterUnion_type(s)
	}
}

func (s *Union_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitUnion_type(s)
	}
}

func (p *IDLParser) Union_type() (localctx IUnion_typeContext) {
	localctx = NewUnion_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, IDLParserRULE_union_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(725)
		p.Match(IDLParserKW_UNION)
	}
	{
		p.SetState(726)
		p.Match(IDLParserID)
	}
	{
		p.SetState(727)
		p.Match(IDLParserKW_SWITCH)
	}
	{
		p.SetState(728)
		p.Match(IDLParserLEFT_BRACKET)
	}
	{
		p.SetState(729)
		p.Switch_type_spec()
	}
	{
		p.SetState(730)
		p.Match(IDLParserRIGHT_BRACKET)
	}
	{
		p.SetState(731)
		p.Match(IDLParserLEFT_BRACE)
	}
	{
		p.SetState(732)
		p.Switch_body()
	}
	{
		p.SetState(733)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// ISwitch_type_specContext is an interface to support dynamic dispatch.
type ISwitch_type_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitch_type_specContext differentiates from other interfaces.
	IsSwitch_type_specContext()
}

type Switch_type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitch_type_specContext() *Switch_type_specContext {
	var p = new(Switch_type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_switch_type_spec
	return p
}

func (*Switch_type_specContext) IsSwitch_type_specContext() {}

func NewSwitch_type_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Switch_type_specContext {
	var p = new(Switch_type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_switch_type_spec

	return p
}

func (s *Switch_type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Switch_type_specContext) Integer_type() IInteger_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInteger_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInteger_typeContext)
}

func (s *Switch_type_specContext) Char_type() IChar_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChar_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChar_typeContext)
}

func (s *Switch_type_specContext) Boolean_type() IBoolean_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBoolean_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBoolean_typeContext)
}

func (s *Switch_type_specContext) Enum_type() IEnum_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnum_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEnum_typeContext)
}

func (s *Switch_type_specContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Switch_type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Switch_type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Switch_type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSwitch_type_spec(s)
	}
}

func (s *Switch_type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSwitch_type_spec(s)
	}
}

func (p *IDLParser) Switch_type_spec() (localctx ISwitch_type_specContext) {
	localctx = NewSwitch_type_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, IDLParserRULE_switch_type_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(740)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_SHORT, IDLParserKW_LONG, IDLParserKW_UNSIGNED:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(735)
			p.Integer_type()
		}

	case IDLParserKW_CHAR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(736)
			p.Char_type()
		}

	case IDLParserKW_BOOLEAN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(737)
			p.Boolean_type()
		}

	case IDLParserKW_ENUM:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(738)
			p.Enum_type()
		}

	case IDLParserDOUBLE_COLON, IDLParserID:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(739)
			p.Scoped_name()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISwitch_bodyContext is an interface to support dynamic dispatch.
type ISwitch_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSwitch_bodyContext differentiates from other interfaces.
	IsSwitch_bodyContext()
}

type Switch_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySwitch_bodyContext() *Switch_bodyContext {
	var p = new(Switch_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_switch_body
	return p
}

func (*Switch_bodyContext) IsSwitch_bodyContext() {}

func NewSwitch_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Switch_bodyContext {
	var p = new(Switch_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_switch_body

	return p
}

func (s *Switch_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Switch_bodyContext) AllCase_stmt() []ICase_stmtContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICase_stmtContext)(nil)).Elem())
	var tst = make([]ICase_stmtContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICase_stmtContext)
		}
	}

	return tst
}

func (s *Switch_bodyContext) Case_stmt(i int) ICase_stmtContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_stmtContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICase_stmtContext)
}

func (s *Switch_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Switch_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Switch_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSwitch_body(s)
	}
}

func (s *Switch_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSwitch_body(s)
	}
}

func (p *IDLParser) Switch_body() (localctx ISwitch_bodyContext) {
	localctx = NewSwitch_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, IDLParserRULE_switch_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(743)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == IDLParserKW_DEFAULT || _la == IDLParserKW_CASE {
		{
			p.SetState(742)
			p.Case_stmt()
		}

		p.SetState(745)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICase_stmtContext is an interface to support dynamic dispatch.
type ICase_stmtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_stmtContext differentiates from other interfaces.
	IsCase_stmtContext()
}

type Case_stmtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_stmtContext() *Case_stmtContext {
	var p = new(Case_stmtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_case_stmt
	return p
}

func (*Case_stmtContext) IsCase_stmtContext() {}

func NewCase_stmtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_stmtContext {
	var p = new(Case_stmtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_case_stmt

	return p
}

func (s *Case_stmtContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_stmtContext) Element_spec() IElement_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IElement_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IElement_specContext)
}

func (s *Case_stmtContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(IDLParserSEMICOLON, 0)
}

func (s *Case_stmtContext) AllCase_label() []ICase_labelContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICase_labelContext)(nil)).Elem())
	var tst = make([]ICase_labelContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICase_labelContext)
		}
	}

	return tst
}

func (s *Case_stmtContext) Case_label(i int) ICase_labelContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICase_labelContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICase_labelContext)
}

func (s *Case_stmtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_stmtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_stmtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterCase_stmt(s)
	}
}

func (s *Case_stmtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitCase_stmt(s)
	}
}

func (p *IDLParser) Case_stmt() (localctx ICase_stmtContext) {
	localctx = NewCase_stmtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, IDLParserRULE_case_stmt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(748)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == IDLParserKW_DEFAULT || _la == IDLParserKW_CASE {
		{
			p.SetState(747)
			p.Case_label()
		}

		p.SetState(750)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(752)
		p.Element_spec()
	}
	{
		p.SetState(753)
		p.Match(IDLParserSEMICOLON)
	}

	return localctx
}

// ICase_labelContext is an interface to support dynamic dispatch.
type ICase_labelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCase_labelContext differentiates from other interfaces.
	IsCase_labelContext()
}

type Case_labelContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCase_labelContext() *Case_labelContext {
	var p = new(Case_labelContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_case_label
	return p
}

func (*Case_labelContext) IsCase_labelContext() {}

func NewCase_labelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Case_labelContext {
	var p = new(Case_labelContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_case_label

	return p
}

func (s *Case_labelContext) GetParser() antlr.Parser { return s.parser }

func (s *Case_labelContext) KW_CASE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_CASE, 0)
}

func (s *Case_labelContext) Const_exp() IConst_expContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConst_expContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConst_expContext)
}

func (s *Case_labelContext) COLON() antlr.TerminalNode {
	return s.GetToken(IDLParserCOLON, 0)
}

func (s *Case_labelContext) KW_DEFAULT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_DEFAULT, 0)
}

func (s *Case_labelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Case_labelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Case_labelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterCase_label(s)
	}
}

func (s *Case_labelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitCase_label(s)
	}
}

func (p *IDLParser) Case_label() (localctx ICase_labelContext) {
	localctx = NewCase_labelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, IDLParserRULE_case_label)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(761)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_CASE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(755)
			p.Match(IDLParserKW_CASE)
		}
		{
			p.SetState(756)
			p.Const_exp()
		}
		{
			p.SetState(757)
			p.Match(IDLParserCOLON)
		}

	case IDLParserKW_DEFAULT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(759)
			p.Match(IDLParserKW_DEFAULT)
		}
		{
			p.SetState(760)
			p.Match(IDLParserCOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IElement_specContext is an interface to support dynamic dispatch.
type IElement_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsElement_specContext differentiates from other interfaces.
	IsElement_specContext()
}

type Element_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElement_specContext() *Element_specContext {
	var p = new(Element_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_element_spec
	return p
}

func (*Element_specContext) IsElement_specContext() {}

func NewElement_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Element_specContext {
	var p = new(Element_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_element_spec

	return p
}

func (s *Element_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Element_specContext) Type_spec() IType_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_specContext)
}

func (s *Element_specContext) Declarator() IDeclaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDeclaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDeclaratorContext)
}

func (s *Element_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Element_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Element_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterElement_spec(s)
	}
}

func (s *Element_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitElement_spec(s)
	}
}

func (p *IDLParser) Element_spec() (localctx IElement_specContext) {
	localctx = NewElement_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, IDLParserRULE_element_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(763)
		p.Type_spec()
	}
	{
		p.SetState(764)
		p.Declarator()
	}

	return localctx
}

// IEnum_typeContext is an interface to support dynamic dispatch.
type IEnum_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnum_typeContext differentiates from other interfaces.
	IsEnum_typeContext()
}

type Enum_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnum_typeContext() *Enum_typeContext {
	var p = new(Enum_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_enum_type
	return p
}

func (*Enum_typeContext) IsEnum_typeContext() {}

func NewEnum_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Enum_typeContext {
	var p = new(Enum_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_enum_type

	return p
}

func (s *Enum_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Enum_typeContext) KW_ENUM() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_ENUM, 0)
}

func (s *Enum_typeContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Enum_typeContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Enum_typeContext) AllEnumerator() []IEnumeratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEnumeratorContext)(nil)).Elem())
	var tst = make([]IEnumeratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEnumeratorContext)
		}
	}

	return tst
}

func (s *Enum_typeContext) Enumerator(i int) IEnumeratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEnumeratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEnumeratorContext)
}

func (s *Enum_typeContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Enum_typeContext) AllCOMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMA)
}

func (s *Enum_typeContext) COMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMA, i)
}

func (s *Enum_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Enum_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Enum_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterEnum_type(s)
	}
}

func (s *Enum_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitEnum_type(s)
	}
}

func (p *IDLParser) Enum_type() (localctx IEnum_typeContext) {
	localctx = NewEnum_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, IDLParserRULE_enum_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(766)
		p.Match(IDLParserKW_ENUM)
	}
	{
		p.SetState(767)
		p.Match(IDLParserID)
	}
	{
		p.SetState(768)
		p.Match(IDLParserLEFT_BRACE)
	}
	{
		p.SetState(769)
		p.Enumerator()
	}
	p.SetState(774)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserCOMA {
		{
			p.SetState(770)
			p.Match(IDLParserCOMA)
		}
		{
			p.SetState(771)
			p.Enumerator()
		}

		p.SetState(776)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(777)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IEnumeratorContext is an interface to support dynamic dispatch.
type IEnumeratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnumeratorContext differentiates from other interfaces.
	IsEnumeratorContext()
}

type EnumeratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnumeratorContext() *EnumeratorContext {
	var p = new(EnumeratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_enumerator
	return p
}

func (*EnumeratorContext) IsEnumeratorContext() {}

func NewEnumeratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnumeratorContext {
	var p = new(EnumeratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_enumerator

	return p
}

func (s *EnumeratorContext) GetParser() antlr.Parser { return s.parser }

func (s *EnumeratorContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *EnumeratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnumeratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnumeratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterEnumerator(s)
	}
}

func (s *EnumeratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitEnumerator(s)
	}
}

func (p *IDLParser) Enumerator() (localctx IEnumeratorContext) {
	localctx = NewEnumeratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, IDLParserRULE_enumerator)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(779)
		p.Match(IDLParserID)
	}

	return localctx
}

// ISequence_typeContext is an interface to support dynamic dispatch.
type ISequence_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSequence_typeContext differentiates from other interfaces.
	IsSequence_typeContext()
}

type Sequence_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySequence_typeContext() *Sequence_typeContext {
	var p = new(Sequence_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_sequence_type
	return p
}

func (*Sequence_typeContext) IsSequence_typeContext() {}

func NewSequence_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Sequence_typeContext {
	var p = new(Sequence_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_sequence_type

	return p
}

func (s *Sequence_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Sequence_typeContext) KW_SEQUENCE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_SEQUENCE, 0)
}

func (s *Sequence_typeContext) LEFT_ANG_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_ANG_BRACKET, 0)
}

func (s *Sequence_typeContext) Simple_type_spec() ISimple_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_type_specContext)
}

func (s *Sequence_typeContext) COMA() antlr.TerminalNode {
	return s.GetToken(IDLParserCOMA, 0)
}

func (s *Sequence_typeContext) Positive_int_const() IPositive_int_constContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPositive_int_constContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPositive_int_constContext)
}

func (s *Sequence_typeContext) RIGHT_ANG_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_ANG_BRACKET, 0)
}

func (s *Sequence_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Sequence_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Sequence_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSequence_type(s)
	}
}

func (s *Sequence_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSequence_type(s)
	}
}

func (p *IDLParser) Sequence_type() (localctx ISequence_typeContext) {
	localctx = NewSequence_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, IDLParserRULE_sequence_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(793)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 54, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(781)
			p.Match(IDLParserKW_SEQUENCE)
		}
		{
			p.SetState(782)
			p.Match(IDLParserLEFT_ANG_BRACKET)
		}
		{
			p.SetState(783)
			p.Simple_type_spec()
		}
		{
			p.SetState(784)
			p.Match(IDLParserCOMA)
		}
		{
			p.SetState(785)
			p.Positive_int_const()
		}
		{
			p.SetState(786)
			p.Match(IDLParserRIGHT_ANG_BRACKET)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(788)
			p.Match(IDLParserKW_SEQUENCE)
		}
		{
			p.SetState(789)
			p.Match(IDLParserLEFT_ANG_BRACKET)
		}
		{
			p.SetState(790)
			p.Simple_type_spec()
		}
		{
			p.SetState(791)
			p.Match(IDLParserRIGHT_ANG_BRACKET)
		}

	}

	return localctx
}

// IString_typeContext is an interface to support dynamic dispatch.
type IString_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsString_typeContext differentiates from other interfaces.
	IsString_typeContext()
}

type String_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyString_typeContext() *String_typeContext {
	var p = new(String_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_string_type
	return p
}

func (*String_typeContext) IsString_typeContext() {}

func NewString_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *String_typeContext {
	var p = new(String_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_string_type

	return p
}

func (s *String_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *String_typeContext) KW_STRING() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_STRING, 0)
}

func (s *String_typeContext) LEFT_ANG_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_ANG_BRACKET, 0)
}

func (s *String_typeContext) Positive_int_const() IPositive_int_constContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPositive_int_constContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPositive_int_constContext)
}

func (s *String_typeContext) RIGHT_ANG_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_ANG_BRACKET, 0)
}

func (s *String_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *String_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *String_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterString_type(s)
	}
}

func (s *String_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitString_type(s)
	}
}

func (p *IDLParser) String_type() (localctx IString_typeContext) {
	localctx = NewString_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, IDLParserRULE_string_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(801)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(795)
			p.Match(IDLParserKW_STRING)
		}
		{
			p.SetState(796)
			p.Match(IDLParserLEFT_ANG_BRACKET)
		}
		{
			p.SetState(797)
			p.Positive_int_const()
		}
		{
			p.SetState(798)
			p.Match(IDLParserRIGHT_ANG_BRACKET)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(800)
			p.Match(IDLParserKW_STRING)
		}

	}

	return localctx
}

// IWide_string_typeContext is an interface to support dynamic dispatch.
type IWide_string_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWide_string_typeContext differentiates from other interfaces.
	IsWide_string_typeContext()
}

type Wide_string_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWide_string_typeContext() *Wide_string_typeContext {
	var p = new(Wide_string_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_wide_string_type
	return p
}

func (*Wide_string_typeContext) IsWide_string_typeContext() {}

func NewWide_string_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Wide_string_typeContext {
	var p = new(Wide_string_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_wide_string_type

	return p
}

func (s *Wide_string_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Wide_string_typeContext) KW_WSTRING() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_WSTRING, 0)
}

func (s *Wide_string_typeContext) LEFT_ANG_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_ANG_BRACKET, 0)
}

func (s *Wide_string_typeContext) Positive_int_const() IPositive_int_constContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPositive_int_constContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPositive_int_constContext)
}

func (s *Wide_string_typeContext) RIGHT_ANG_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_ANG_BRACKET, 0)
}

func (s *Wide_string_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Wide_string_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Wide_string_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterWide_string_type(s)
	}
}

func (s *Wide_string_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitWide_string_type(s)
	}
}

func (p *IDLParser) Wide_string_type() (localctx IWide_string_typeContext) {
	localctx = NewWide_string_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, IDLParserRULE_wide_string_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(809)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(803)
			p.Match(IDLParserKW_WSTRING)
		}
		{
			p.SetState(804)
			p.Match(IDLParserLEFT_ANG_BRACKET)
		}
		{
			p.SetState(805)
			p.Positive_int_const()
		}
		{
			p.SetState(806)
			p.Match(IDLParserRIGHT_ANG_BRACKET)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(808)
			p.Match(IDLParserKW_WSTRING)
		}

	}

	return localctx
}

// IArray_declaratorContext is an interface to support dynamic dispatch.
type IArray_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_declaratorContext differentiates from other interfaces.
	IsArray_declaratorContext()
}

type Array_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_declaratorContext() *Array_declaratorContext {
	var p = new(Array_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_array_declarator
	return p
}

func (*Array_declaratorContext) IsArray_declaratorContext() {}

func NewArray_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_declaratorContext {
	var p = new(Array_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_array_declarator

	return p
}

func (s *Array_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_declaratorContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Array_declaratorContext) AllFixed_array_size() []IFixed_array_sizeContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFixed_array_sizeContext)(nil)).Elem())
	var tst = make([]IFixed_array_sizeContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFixed_array_sizeContext)
		}
	}

	return tst
}

func (s *Array_declaratorContext) Fixed_array_size(i int) IFixed_array_sizeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFixed_array_sizeContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFixed_array_sizeContext)
}

func (s *Array_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterArray_declarator(s)
	}
}

func (s *Array_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitArray_declarator(s)
	}
}

func (p *IDLParser) Array_declarator() (localctx IArray_declaratorContext) {
	localctx = NewArray_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, IDLParserRULE_array_declarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(811)
		p.Match(IDLParserID)
	}
	p.SetState(813)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == IDLParserLEFT_SQUARE_BRACKET {
		{
			p.SetState(812)
			p.Fixed_array_size()
		}

		p.SetState(815)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFixed_array_sizeContext is an interface to support dynamic dispatch.
type IFixed_array_sizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFixed_array_sizeContext differentiates from other interfaces.
	IsFixed_array_sizeContext()
}

type Fixed_array_sizeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFixed_array_sizeContext() *Fixed_array_sizeContext {
	var p = new(Fixed_array_sizeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_fixed_array_size
	return p
}

func (*Fixed_array_sizeContext) IsFixed_array_sizeContext() {}

func NewFixed_array_sizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fixed_array_sizeContext {
	var p = new(Fixed_array_sizeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_fixed_array_size

	return p
}

func (s *Fixed_array_sizeContext) GetParser() antlr.Parser { return s.parser }

func (s *Fixed_array_sizeContext) LEFT_SQUARE_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_SQUARE_BRACKET, 0)
}

func (s *Fixed_array_sizeContext) Positive_int_const() IPositive_int_constContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPositive_int_constContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPositive_int_constContext)
}

func (s *Fixed_array_sizeContext) RIGHT_SQUARE_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_SQUARE_BRACKET, 0)
}

func (s *Fixed_array_sizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fixed_array_sizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fixed_array_sizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterFixed_array_size(s)
	}
}

func (s *Fixed_array_sizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitFixed_array_size(s)
	}
}

func (p *IDLParser) Fixed_array_size() (localctx IFixed_array_sizeContext) {
	localctx = NewFixed_array_sizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, IDLParserRULE_fixed_array_size)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(817)
		p.Match(IDLParserLEFT_SQUARE_BRACKET)
	}
	{
		p.SetState(818)
		p.Positive_int_const()
	}
	{
		p.SetState(819)
		p.Match(IDLParserRIGHT_SQUARE_BRACKET)
	}

	return localctx
}

// IAttr_declContext is an interface to support dynamic dispatch.
type IAttr_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_declContext differentiates from other interfaces.
	IsAttr_declContext()
}

type Attr_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_declContext() *Attr_declContext {
	var p = new(Attr_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_attr_decl
	return p
}

func (*Attr_declContext) IsAttr_declContext() {}

func NewAttr_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_declContext {
	var p = new(Attr_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_attr_decl

	return p
}

func (s *Attr_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_declContext) Readonly_attr_spec() IReadonly_attr_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadonly_attr_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadonly_attr_specContext)
}

func (s *Attr_declContext) Attr_spec() IAttr_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_specContext)
}

func (s *Attr_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAttr_decl(s)
	}
}

func (s *Attr_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAttr_decl(s)
	}
}

func (p *IDLParser) Attr_decl() (localctx IAttr_declContext) {
	localctx = NewAttr_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, IDLParserRULE_attr_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(823)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_READONLY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(821)
			p.Readonly_attr_spec()
		}

	case IDLParserKW_ATTRIBUTE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(822)
			p.Attr_spec()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExcept_declContext is an interface to support dynamic dispatch.
type IExcept_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExcept_declContext differentiates from other interfaces.
	IsExcept_declContext()
}

type Except_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExcept_declContext() *Except_declContext {
	var p = new(Except_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_except_decl
	return p
}

func (*Except_declContext) IsExcept_declContext() {}

func NewExcept_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Except_declContext {
	var p = new(Except_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_except_decl

	return p
}

func (s *Except_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Except_declContext) KW_EXCEPTION() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_EXCEPTION, 0)
}

func (s *Except_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Except_declContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Except_declContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Except_declContext) AllMember() []IMemberContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMemberContext)(nil)).Elem())
	var tst = make([]IMemberContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMemberContext)
		}
	}

	return tst
}

func (s *Except_declContext) Member(i int) IMemberContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMemberContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMemberContext)
}

func (s *Except_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Except_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Except_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterExcept_decl(s)
	}
}

func (s *Except_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitExcept_decl(s)
	}
}

func (p *IDLParser) Except_decl() (localctx IExcept_declContext) {
	localctx = NewExcept_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, IDLParserRULE_except_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(825)
		p.Match(IDLParserKW_EXCEPTION)
	}
	{
		p.SetState(826)
		p.Match(IDLParserID)
	}
	{
		p.SetState(827)
		p.Match(IDLParserLEFT_BRACE)
	}
	p.SetState(831)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(IDLParserDOUBLE_COLON-32))|(1<<(IDLParserKW_STRING-32))|(1<<(IDLParserKW_OCTET-32))|(1<<(IDLParserKW_SEQUENCE-32))|(1<<(IDLParserKW_STRUCT-32))|(1<<(IDLParserKW_WCHAR-32))|(1<<(IDLParserKW_SHORT-32))|(1<<(IDLParserKW_LONG-32))|(1<<(IDLParserKW_ENUM-32))|(1<<(IDLParserKW_WSTRING-32)))) != 0) || (((_la-70)&-(0x1f+1)) == 0 && ((1<<uint((_la-70)))&((1<<(IDLParserKW_VALUEBASE-70))|(1<<(IDLParserKW_OBJECT-70))|(1<<(IDLParserKW_UNSIGNED-70))|(1<<(IDLParserKW_FIXED-70))|(1<<(IDLParserKW_UNION-70))|(1<<(IDLParserKW_ANY-70))|(1<<(IDLParserKW_CHAR-70))|(1<<(IDLParserKW_FLOAT-70))|(1<<(IDLParserKW_BOOLEAN-70))|(1<<(IDLParserKW_DOUBLE-70))|(1<<(IDLParserID-70)))) != 0) {
		{
			p.SetState(828)
			p.Member()
		}

		p.SetState(833)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(834)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IOp_declContext is an interface to support dynamic dispatch.
type IOp_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOp_declContext differentiates from other interfaces.
	IsOp_declContext()
}

type Op_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOp_declContext() *Op_declContext {
	var p = new(Op_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_op_decl
	return p
}

func (*Op_declContext) IsOp_declContext() {}

func NewOp_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Op_declContext {
	var p = new(Op_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_op_decl

	return p
}

func (s *Op_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Op_declContext) Op_type_spec() IOp_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOp_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOp_type_specContext)
}

func (s *Op_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Op_declContext) Parameter_decls() IParameter_declsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_declsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameter_declsContext)
}

func (s *Op_declContext) Op_attribute() IOp_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOp_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOp_attributeContext)
}

func (s *Op_declContext) Raises_expr() IRaises_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRaises_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRaises_exprContext)
}

func (s *Op_declContext) Context_expr() IContext_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContext_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContext_exprContext)
}

func (s *Op_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Op_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Op_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterOp_decl(s)
	}
}

func (s *Op_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitOp_decl(s)
	}
}

func (p *IDLParser) Op_decl() (localctx IOp_declContext) {
	localctx = NewOp_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, IDLParserRULE_op_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(837)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_ONEWAY {
		{
			p.SetState(836)
			p.Op_attribute()
		}

	}
	{
		p.SetState(839)
		p.Op_type_spec()
	}
	{
		p.SetState(840)
		p.Match(IDLParserID)
	}
	{
		p.SetState(841)
		p.Parameter_decls()
	}
	p.SetState(843)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_RAISES {
		{
			p.SetState(842)
			p.Raises_expr()
		}

	}
	p.SetState(846)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_CONTEXT {
		{
			p.SetState(845)
			p.Context_expr()
		}

	}

	return localctx
}

// IOp_attributeContext is an interface to support dynamic dispatch.
type IOp_attributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOp_attributeContext differentiates from other interfaces.
	IsOp_attributeContext()
}

type Op_attributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOp_attributeContext() *Op_attributeContext {
	var p = new(Op_attributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_op_attribute
	return p
}

func (*Op_attributeContext) IsOp_attributeContext() {}

func NewOp_attributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Op_attributeContext {
	var p = new(Op_attributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_op_attribute

	return p
}

func (s *Op_attributeContext) GetParser() antlr.Parser { return s.parser }

func (s *Op_attributeContext) KW_ONEWAY() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_ONEWAY, 0)
}

func (s *Op_attributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Op_attributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Op_attributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterOp_attribute(s)
	}
}

func (s *Op_attributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitOp_attribute(s)
	}
}

func (p *IDLParser) Op_attribute() (localctx IOp_attributeContext) {
	localctx = NewOp_attributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, IDLParserRULE_op_attribute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(848)
		p.Match(IDLParserKW_ONEWAY)
	}

	return localctx
}

// IOp_type_specContext is an interface to support dynamic dispatch.
type IOp_type_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOp_type_specContext differentiates from other interfaces.
	IsOp_type_specContext()
}

type Op_type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOp_type_specContext() *Op_type_specContext {
	var p = new(Op_type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_op_type_spec
	return p
}

func (*Op_type_specContext) IsOp_type_specContext() {}

func NewOp_type_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Op_type_specContext {
	var p = new(Op_type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_op_type_spec

	return p
}

func (s *Op_type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Op_type_specContext) Param_type_spec() IParam_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_type_specContext)
}

func (s *Op_type_specContext) KW_VOID() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_VOID, 0)
}

func (s *Op_type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Op_type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Op_type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterOp_type_spec(s)
	}
}

func (s *Op_type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitOp_type_spec(s)
	}
}

func (p *IDLParser) Op_type_spec() (localctx IOp_type_specContext) {
	localctx = NewOp_type_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, IDLParserRULE_op_type_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(852)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserDOUBLE_COLON, IDLParserKW_STRING, IDLParserKW_OCTET, IDLParserKW_WCHAR, IDLParserKW_SHORT, IDLParserKW_LONG, IDLParserKW_WSTRING, IDLParserKW_VALUEBASE, IDLParserKW_OBJECT, IDLParserKW_UNSIGNED, IDLParserKW_ANY, IDLParserKW_CHAR, IDLParserKW_FLOAT, IDLParserKW_BOOLEAN, IDLParserKW_DOUBLE, IDLParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(850)
			p.Param_type_spec()
		}

	case IDLParserKW_VOID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(851)
			p.Match(IDLParserKW_VOID)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IParameter_declsContext is an interface to support dynamic dispatch.
type IParameter_declsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_declsContext differentiates from other interfaces.
	IsParameter_declsContext()
}

type Parameter_declsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_declsContext() *Parameter_declsContext {
	var p = new(Parameter_declsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_parameter_decls
	return p
}

func (*Parameter_declsContext) IsParameter_declsContext() {}

func NewParameter_declsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_declsContext {
	var p = new(Parameter_declsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_parameter_decls

	return p
}

func (s *Parameter_declsContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_declsContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACKET, 0)
}

func (s *Parameter_declsContext) AllParam_decl() []IParam_declContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParam_declContext)(nil)).Elem())
	var tst = make([]IParam_declContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParam_declContext)
		}
	}

	return tst
}

func (s *Parameter_declsContext) Param_decl(i int) IParam_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_declContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParam_declContext)
}

func (s *Parameter_declsContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACKET, 0)
}

func (s *Parameter_declsContext) AllCOMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMA)
}

func (s *Parameter_declsContext) COMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMA, i)
}

func (s *Parameter_declsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_declsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_declsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterParameter_decls(s)
	}
}

func (s *Parameter_declsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitParameter_decls(s)
	}
}

func (p *IDLParser) Parameter_decls() (localctx IParameter_declsContext) {
	localctx = NewParameter_declsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, IDLParserRULE_parameter_decls)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(867)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(854)
			p.Match(IDLParserLEFT_BRACKET)
		}
		{
			p.SetState(855)
			p.Param_decl()
		}
		p.SetState(860)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == IDLParserCOMA {
			{
				p.SetState(856)
				p.Match(IDLParserCOMA)
			}
			{
				p.SetState(857)
				p.Param_decl()
			}

			p.SetState(862)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(863)
			p.Match(IDLParserRIGHT_BRACKET)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(865)
			p.Match(IDLParserLEFT_BRACKET)
		}
		{
			p.SetState(866)
			p.Match(IDLParserRIGHT_BRACKET)
		}

	}

	return localctx
}

// IParam_declContext is an interface to support dynamic dispatch.
type IParam_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParam_declContext differentiates from other interfaces.
	IsParam_declContext()
}

type Param_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParam_declContext() *Param_declContext {
	var p = new(Param_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_param_decl
	return p
}

func (*Param_declContext) IsParam_declContext() {}

func NewParam_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Param_declContext {
	var p = new(Param_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_param_decl

	return p
}

func (s *Param_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Param_declContext) Param_attribute() IParam_attributeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_attributeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_attributeContext)
}

func (s *Param_declContext) Param_type_spec() IParam_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_type_specContext)
}

func (s *Param_declContext) Simple_declarator() ISimple_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISimple_declaratorContext)
}

func (s *Param_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Param_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Param_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterParam_decl(s)
	}
}

func (s *Param_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitParam_decl(s)
	}
}

func (p *IDLParser) Param_decl() (localctx IParam_declContext) {
	localctx = NewParam_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, IDLParserRULE_param_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(869)
		p.Param_attribute()
	}
	{
		p.SetState(870)
		p.Param_type_spec()
	}
	{
		p.SetState(871)
		p.Simple_declarator()
	}

	return localctx
}

// IParam_attributeContext is an interface to support dynamic dispatch.
type IParam_attributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParam_attributeContext differentiates from other interfaces.
	IsParam_attributeContext()
}

type Param_attributeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParam_attributeContext() *Param_attributeContext {
	var p = new(Param_attributeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_param_attribute
	return p
}

func (*Param_attributeContext) IsParam_attributeContext() {}

func NewParam_attributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Param_attributeContext {
	var p = new(Param_attributeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_param_attribute

	return p
}

func (s *Param_attributeContext) GetParser() antlr.Parser { return s.parser }

func (s *Param_attributeContext) KW_IN() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_IN, 0)
}

func (s *Param_attributeContext) KW_OUT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_OUT, 0)
}

func (s *Param_attributeContext) KW_INOUT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_INOUT, 0)
}

func (s *Param_attributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Param_attributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Param_attributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterParam_attribute(s)
	}
}

func (s *Param_attributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitParam_attribute(s)
	}
}

func (p *IDLParser) Param_attribute() (localctx IParam_attributeContext) {
	localctx = NewParam_attributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, IDLParserRULE_param_attribute)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(873)
		_la = p.GetTokenStream().LA(1)

		if !(_la == IDLParserKW_OUT || _la == IDLParserKW_IN || _la == IDLParserKW_INOUT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRaises_exprContext is an interface to support dynamic dispatch.
type IRaises_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRaises_exprContext differentiates from other interfaces.
	IsRaises_exprContext()
}

type Raises_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRaises_exprContext() *Raises_exprContext {
	var p = new(Raises_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_raises_expr
	return p
}

func (*Raises_exprContext) IsRaises_exprContext() {}

func NewRaises_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Raises_exprContext {
	var p = new(Raises_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_raises_expr

	return p
}

func (s *Raises_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Raises_exprContext) KW_RAISES() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_RAISES, 0)
}

func (s *Raises_exprContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACKET, 0)
}

func (s *Raises_exprContext) AllScoped_name() []IScoped_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem())
	var tst = make([]IScoped_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScoped_nameContext)
		}
	}

	return tst
}

func (s *Raises_exprContext) Scoped_name(i int) IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Raises_exprContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACKET, 0)
}

func (s *Raises_exprContext) AllCOMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMA)
}

func (s *Raises_exprContext) COMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMA, i)
}

func (s *Raises_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Raises_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Raises_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterRaises_expr(s)
	}
}

func (s *Raises_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitRaises_expr(s)
	}
}

func (p *IDLParser) Raises_expr() (localctx IRaises_exprContext) {
	localctx = NewRaises_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, IDLParserRULE_raises_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(875)
		p.Match(IDLParserKW_RAISES)
	}
	{
		p.SetState(876)
		p.Match(IDLParserLEFT_BRACKET)
	}
	{
		p.SetState(877)
		p.Scoped_name()
	}
	p.SetState(882)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserCOMA {
		{
			p.SetState(878)
			p.Match(IDLParserCOMA)
		}
		{
			p.SetState(879)
			p.Scoped_name()
		}

		p.SetState(884)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(885)
		p.Match(IDLParserRIGHT_BRACKET)
	}

	return localctx
}

// IContext_exprContext is an interface to support dynamic dispatch.
type IContext_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContext_exprContext differentiates from other interfaces.
	IsContext_exprContext()
}

type Context_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContext_exprContext() *Context_exprContext {
	var p = new(Context_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_context_expr
	return p
}

func (*Context_exprContext) IsContext_exprContext() {}

func NewContext_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Context_exprContext {
	var p = new(Context_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_context_expr

	return p
}

func (s *Context_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Context_exprContext) KW_CONTEXT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_CONTEXT, 0)
}

func (s *Context_exprContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACKET, 0)
}

func (s *Context_exprContext) AllSTRING_LITERAL() []antlr.TerminalNode {
	return s.GetTokens(IDLParserSTRING_LITERAL)
}

func (s *Context_exprContext) STRING_LITERAL(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserSTRING_LITERAL, i)
}

func (s *Context_exprContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACKET, 0)
}

func (s *Context_exprContext) AllCOMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMA)
}

func (s *Context_exprContext) COMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMA, i)
}

func (s *Context_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Context_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Context_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterContext_expr(s)
	}
}

func (s *Context_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitContext_expr(s)
	}
}

func (p *IDLParser) Context_expr() (localctx IContext_exprContext) {
	localctx = NewContext_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, IDLParserRULE_context_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(887)
		p.Match(IDLParserKW_CONTEXT)
	}
	{
		p.SetState(888)
		p.Match(IDLParserLEFT_BRACKET)
	}
	{
		p.SetState(889)
		p.Match(IDLParserSTRING_LITERAL)
	}
	p.SetState(894)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserCOMA {
		{
			p.SetState(890)
			p.Match(IDLParserCOMA)
		}
		{
			p.SetState(891)
			p.Match(IDLParserSTRING_LITERAL)
		}

		p.SetState(896)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(897)
		p.Match(IDLParserRIGHT_BRACKET)
	}

	return localctx
}

// IParam_type_specContext is an interface to support dynamic dispatch.
type IParam_type_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParam_type_specContext differentiates from other interfaces.
	IsParam_type_specContext()
}

type Param_type_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParam_type_specContext() *Param_type_specContext {
	var p = new(Param_type_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_param_type_spec
	return p
}

func (*Param_type_specContext) IsParam_type_specContext() {}

func NewParam_type_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Param_type_specContext {
	var p = new(Param_type_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_param_type_spec

	return p
}

func (s *Param_type_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Param_type_specContext) Base_type_spec() IBase_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBase_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBase_type_specContext)
}

func (s *Param_type_specContext) String_type() IString_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IString_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IString_typeContext)
}

func (s *Param_type_specContext) Wide_string_type() IWide_string_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWide_string_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWide_string_typeContext)
}

func (s *Param_type_specContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Param_type_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Param_type_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Param_type_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterParam_type_spec(s)
	}
}

func (s *Param_type_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitParam_type_spec(s)
	}
}

func (p *IDLParser) Param_type_spec() (localctx IParam_type_specContext) {
	localctx = NewParam_type_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, IDLParserRULE_param_type_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(903)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_OCTET, IDLParserKW_WCHAR, IDLParserKW_SHORT, IDLParserKW_LONG, IDLParserKW_VALUEBASE, IDLParserKW_OBJECT, IDLParserKW_UNSIGNED, IDLParserKW_ANY, IDLParserKW_CHAR, IDLParserKW_FLOAT, IDLParserKW_BOOLEAN, IDLParserKW_DOUBLE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(899)
			p.Base_type_spec()
		}

	case IDLParserKW_STRING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(900)
			p.String_type()
		}

	case IDLParserKW_WSTRING:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(901)
			p.Wide_string_type()
		}

	case IDLParserDOUBLE_COLON, IDLParserID:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(902)
			p.Scoped_name()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFixed_pt_typeContext is an interface to support dynamic dispatch.
type IFixed_pt_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFixed_pt_typeContext differentiates from other interfaces.
	IsFixed_pt_typeContext()
}

type Fixed_pt_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFixed_pt_typeContext() *Fixed_pt_typeContext {
	var p = new(Fixed_pt_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_fixed_pt_type
	return p
}

func (*Fixed_pt_typeContext) IsFixed_pt_typeContext() {}

func NewFixed_pt_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fixed_pt_typeContext {
	var p = new(Fixed_pt_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_fixed_pt_type

	return p
}

func (s *Fixed_pt_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Fixed_pt_typeContext) KW_FIXED() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_FIXED, 0)
}

func (s *Fixed_pt_typeContext) LEFT_ANG_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_ANG_BRACKET, 0)
}

func (s *Fixed_pt_typeContext) AllPositive_int_const() []IPositive_int_constContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IPositive_int_constContext)(nil)).Elem())
	var tst = make([]IPositive_int_constContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IPositive_int_constContext)
		}
	}

	return tst
}

func (s *Fixed_pt_typeContext) Positive_int_const(i int) IPositive_int_constContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPositive_int_constContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IPositive_int_constContext)
}

func (s *Fixed_pt_typeContext) COMA() antlr.TerminalNode {
	return s.GetToken(IDLParserCOMA, 0)
}

func (s *Fixed_pt_typeContext) RIGHT_ANG_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_ANG_BRACKET, 0)
}

func (s *Fixed_pt_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fixed_pt_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fixed_pt_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterFixed_pt_type(s)
	}
}

func (s *Fixed_pt_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitFixed_pt_type(s)
	}
}

func (p *IDLParser) Fixed_pt_type() (localctx IFixed_pt_typeContext) {
	localctx = NewFixed_pt_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, IDLParserRULE_fixed_pt_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(905)
		p.Match(IDLParserKW_FIXED)
	}
	{
		p.SetState(906)
		p.Match(IDLParserLEFT_ANG_BRACKET)
	}
	{
		p.SetState(907)
		p.Positive_int_const()
	}
	{
		p.SetState(908)
		p.Match(IDLParserCOMA)
	}
	{
		p.SetState(909)
		p.Positive_int_const()
	}
	{
		p.SetState(910)
		p.Match(IDLParserRIGHT_ANG_BRACKET)
	}

	return localctx
}

// IFixed_pt_const_typeContext is an interface to support dynamic dispatch.
type IFixed_pt_const_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFixed_pt_const_typeContext differentiates from other interfaces.
	IsFixed_pt_const_typeContext()
}

type Fixed_pt_const_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFixed_pt_const_typeContext() *Fixed_pt_const_typeContext {
	var p = new(Fixed_pt_const_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_fixed_pt_const_type
	return p
}

func (*Fixed_pt_const_typeContext) IsFixed_pt_const_typeContext() {}

func NewFixed_pt_const_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Fixed_pt_const_typeContext {
	var p = new(Fixed_pt_const_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_fixed_pt_const_type

	return p
}

func (s *Fixed_pt_const_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Fixed_pt_const_typeContext) KW_FIXED() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_FIXED, 0)
}

func (s *Fixed_pt_const_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Fixed_pt_const_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Fixed_pt_const_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterFixed_pt_const_type(s)
	}
}

func (s *Fixed_pt_const_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitFixed_pt_const_type(s)
	}
}

func (p *IDLParser) Fixed_pt_const_type() (localctx IFixed_pt_const_typeContext) {
	localctx = NewFixed_pt_const_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, IDLParserRULE_fixed_pt_const_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(912)
		p.Match(IDLParserKW_FIXED)
	}

	return localctx
}

// IValue_base_typeContext is an interface to support dynamic dispatch.
type IValue_base_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValue_base_typeContext differentiates from other interfaces.
	IsValue_base_typeContext()
}

type Value_base_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValue_base_typeContext() *Value_base_typeContext {
	var p = new(Value_base_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_value_base_type
	return p
}

func (*Value_base_typeContext) IsValue_base_typeContext() {}

func NewValue_base_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Value_base_typeContext {
	var p = new(Value_base_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_value_base_type

	return p
}

func (s *Value_base_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Value_base_typeContext) KW_VALUEBASE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_VALUEBASE, 0)
}

func (s *Value_base_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Value_base_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Value_base_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterValue_base_type(s)
	}
}

func (s *Value_base_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitValue_base_type(s)
	}
}

func (p *IDLParser) Value_base_type() (localctx IValue_base_typeContext) {
	localctx = NewValue_base_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, IDLParserRULE_value_base_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(914)
		p.Match(IDLParserKW_VALUEBASE)
	}

	return localctx
}

// IConstr_forward_declContext is an interface to support dynamic dispatch.
type IConstr_forward_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstr_forward_declContext differentiates from other interfaces.
	IsConstr_forward_declContext()
}

type Constr_forward_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstr_forward_declContext() *Constr_forward_declContext {
	var p = new(Constr_forward_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_constr_forward_decl
	return p
}

func (*Constr_forward_declContext) IsConstr_forward_declContext() {}

func NewConstr_forward_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constr_forward_declContext {
	var p = new(Constr_forward_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_constr_forward_decl

	return p
}

func (s *Constr_forward_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Constr_forward_declContext) KW_STRUCT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_STRUCT, 0)
}

func (s *Constr_forward_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Constr_forward_declContext) KW_UNION() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_UNION, 0)
}

func (s *Constr_forward_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constr_forward_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constr_forward_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterConstr_forward_decl(s)
	}
}

func (s *Constr_forward_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitConstr_forward_decl(s)
	}
}

func (p *IDLParser) Constr_forward_decl() (localctx IConstr_forward_declContext) {
	localctx = NewConstr_forward_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, IDLParserRULE_constr_forward_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(920)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_STRUCT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(916)
			p.Match(IDLParserKW_STRUCT)
		}
		{
			p.SetState(917)
			p.Match(IDLParserID)
		}

	case IDLParserKW_UNION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(918)
			p.Match(IDLParserKW_UNION)
		}
		{
			p.SetState(919)
			p.Match(IDLParserID)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IImport_declContext is an interface to support dynamic dispatch.
type IImport_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImport_declContext differentiates from other interfaces.
	IsImport_declContext()
}

type Import_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImport_declContext() *Import_declContext {
	var p = new(Import_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_import_decl
	return p
}

func (*Import_declContext) IsImport_declContext() {}

func NewImport_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Import_declContext {
	var p = new(Import_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_import_decl

	return p
}

func (s *Import_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Import_declContext) KW_IMPORT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_IMPORT, 0)
}

func (s *Import_declContext) Imported_scope() IImported_scopeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IImported_scopeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IImported_scopeContext)
}

func (s *Import_declContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(IDLParserSEMICOLON, 0)
}

func (s *Import_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Import_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Import_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterImport_decl(s)
	}
}

func (s *Import_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitImport_decl(s)
	}
}

func (p *IDLParser) Import_decl() (localctx IImport_declContext) {
	localctx = NewImport_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, IDLParserRULE_import_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(922)
		p.Match(IDLParserKW_IMPORT)
	}
	{
		p.SetState(923)
		p.Imported_scope()
	}
	{
		p.SetState(924)
		p.Match(IDLParserSEMICOLON)
	}

	return localctx
}

// IImported_scopeContext is an interface to support dynamic dispatch.
type IImported_scopeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsImported_scopeContext differentiates from other interfaces.
	IsImported_scopeContext()
}

type Imported_scopeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyImported_scopeContext() *Imported_scopeContext {
	var p = new(Imported_scopeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_imported_scope
	return p
}

func (*Imported_scopeContext) IsImported_scopeContext() {}

func NewImported_scopeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Imported_scopeContext {
	var p = new(Imported_scopeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_imported_scope

	return p
}

func (s *Imported_scopeContext) GetParser() antlr.Parser { return s.parser }

func (s *Imported_scopeContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Imported_scopeContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserSTRING_LITERAL, 0)
}

func (s *Imported_scopeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Imported_scopeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Imported_scopeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterImported_scope(s)
	}
}

func (s *Imported_scopeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitImported_scope(s)
	}
}

func (p *IDLParser) Imported_scope() (localctx IImported_scopeContext) {
	localctx = NewImported_scopeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, IDLParserRULE_imported_scope)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(928)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserDOUBLE_COLON, IDLParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(926)
			p.Scoped_name()
		}

	case IDLParserSTRING_LITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(927)
			p.Match(IDLParserSTRING_LITERAL)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IType_id_declContext is an interface to support dynamic dispatch.
type IType_id_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_id_declContext differentiates from other interfaces.
	IsType_id_declContext()
}

type Type_id_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_id_declContext() *Type_id_declContext {
	var p = new(Type_id_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_type_id_decl
	return p
}

func (*Type_id_declContext) IsType_id_declContext() {}

func NewType_id_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_id_declContext {
	var p = new(Type_id_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_type_id_decl

	return p
}

func (s *Type_id_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_id_declContext) KW_TYPEID() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_TYPEID, 0)
}

func (s *Type_id_declContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Type_id_declContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserSTRING_LITERAL, 0)
}

func (s *Type_id_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_id_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_id_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterType_id_decl(s)
	}
}

func (s *Type_id_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitType_id_decl(s)
	}
}

func (p *IDLParser) Type_id_decl() (localctx IType_id_declContext) {
	localctx = NewType_id_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, IDLParserRULE_type_id_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(930)
		p.Match(IDLParserKW_TYPEID)
	}
	{
		p.SetState(931)
		p.Scoped_name()
	}
	{
		p.SetState(932)
		p.Match(IDLParserSTRING_LITERAL)
	}

	return localctx
}

// IType_prefix_declContext is an interface to support dynamic dispatch.
type IType_prefix_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_prefix_declContext differentiates from other interfaces.
	IsType_prefix_declContext()
}

type Type_prefix_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_prefix_declContext() *Type_prefix_declContext {
	var p = new(Type_prefix_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_type_prefix_decl
	return p
}

func (*Type_prefix_declContext) IsType_prefix_declContext() {}

func NewType_prefix_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_prefix_declContext {
	var p = new(Type_prefix_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_type_prefix_decl

	return p
}

func (s *Type_prefix_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_prefix_declContext) KW_TYPEPREFIX() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_TYPEPREFIX, 0)
}

func (s *Type_prefix_declContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Type_prefix_declContext) STRING_LITERAL() antlr.TerminalNode {
	return s.GetToken(IDLParserSTRING_LITERAL, 0)
}

func (s *Type_prefix_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_prefix_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_prefix_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterType_prefix_decl(s)
	}
}

func (s *Type_prefix_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitType_prefix_decl(s)
	}
}

func (p *IDLParser) Type_prefix_decl() (localctx IType_prefix_declContext) {
	localctx = NewType_prefix_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, IDLParserRULE_type_prefix_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(934)
		p.Match(IDLParserKW_TYPEPREFIX)
	}
	{
		p.SetState(935)
		p.Scoped_name()
	}
	{
		p.SetState(936)
		p.Match(IDLParserSTRING_LITERAL)
	}

	return localctx
}

// IReadonly_attr_specContext is an interface to support dynamic dispatch.
type IReadonly_attr_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadonly_attr_specContext differentiates from other interfaces.
	IsReadonly_attr_specContext()
}

type Readonly_attr_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadonly_attr_specContext() *Readonly_attr_specContext {
	var p = new(Readonly_attr_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_readonly_attr_spec
	return p
}

func (*Readonly_attr_specContext) IsReadonly_attr_specContext() {}

func NewReadonly_attr_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Readonly_attr_specContext {
	var p = new(Readonly_attr_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_readonly_attr_spec

	return p
}

func (s *Readonly_attr_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Readonly_attr_specContext) KW_READONLY() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_READONLY, 0)
}

func (s *Readonly_attr_specContext) KW_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_ATTRIBUTE, 0)
}

func (s *Readonly_attr_specContext) Param_type_spec() IParam_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_type_specContext)
}

func (s *Readonly_attr_specContext) Readonly_attr_declarator() IReadonly_attr_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReadonly_attr_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReadonly_attr_declaratorContext)
}

func (s *Readonly_attr_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Readonly_attr_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Readonly_attr_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterReadonly_attr_spec(s)
	}
}

func (s *Readonly_attr_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitReadonly_attr_spec(s)
	}
}

func (p *IDLParser) Readonly_attr_spec() (localctx IReadonly_attr_specContext) {
	localctx = NewReadonly_attr_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, IDLParserRULE_readonly_attr_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(938)
		p.Match(IDLParserKW_READONLY)
	}
	{
		p.SetState(939)
		p.Match(IDLParserKW_ATTRIBUTE)
	}
	{
		p.SetState(940)
		p.Param_type_spec()
	}
	{
		p.SetState(941)
		p.Readonly_attr_declarator()
	}

	return localctx
}

// IReadonly_attr_declaratorContext is an interface to support dynamic dispatch.
type IReadonly_attr_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadonly_attr_declaratorContext differentiates from other interfaces.
	IsReadonly_attr_declaratorContext()
}

type Readonly_attr_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadonly_attr_declaratorContext() *Readonly_attr_declaratorContext {
	var p = new(Readonly_attr_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_readonly_attr_declarator
	return p
}

func (*Readonly_attr_declaratorContext) IsReadonly_attr_declaratorContext() {}

func NewReadonly_attr_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Readonly_attr_declaratorContext {
	var p = new(Readonly_attr_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_readonly_attr_declarator

	return p
}

func (s *Readonly_attr_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Readonly_attr_declaratorContext) AllSimple_declarator() []ISimple_declaratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_declaratorContext)(nil)).Elem())
	var tst = make([]ISimple_declaratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_declaratorContext)
		}
	}

	return tst
}

func (s *Readonly_attr_declaratorContext) Simple_declarator(i int) ISimple_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_declaratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_declaratorContext)
}

func (s *Readonly_attr_declaratorContext) Raises_expr() IRaises_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRaises_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRaises_exprContext)
}

func (s *Readonly_attr_declaratorContext) AllCOMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMA)
}

func (s *Readonly_attr_declaratorContext) COMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMA, i)
}

func (s *Readonly_attr_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Readonly_attr_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Readonly_attr_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterReadonly_attr_declarator(s)
	}
}

func (s *Readonly_attr_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitReadonly_attr_declarator(s)
	}
}

func (p *IDLParser) Readonly_attr_declarator() (localctx IReadonly_attr_declaratorContext) {
	localctx = NewReadonly_attr_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, IDLParserRULE_readonly_attr_declarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(954)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(943)
			p.Simple_declarator()
		}
		{
			p.SetState(944)
			p.Raises_expr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(946)
			p.Simple_declarator()
		}
		p.SetState(951)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == IDLParserCOMA {
			{
				p.SetState(947)
				p.Match(IDLParserCOMA)
			}
			{
				p.SetState(948)
				p.Simple_declarator()
			}

			p.SetState(953)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IAttr_specContext is an interface to support dynamic dispatch.
type IAttr_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_specContext differentiates from other interfaces.
	IsAttr_specContext()
}

type Attr_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_specContext() *Attr_specContext {
	var p = new(Attr_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_attr_spec
	return p
}

func (*Attr_specContext) IsAttr_specContext() {}

func NewAttr_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_specContext {
	var p = new(Attr_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_attr_spec

	return p
}

func (s *Attr_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_specContext) KW_ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_ATTRIBUTE, 0)
}

func (s *Attr_specContext) Param_type_spec() IParam_type_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParam_type_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParam_type_specContext)
}

func (s *Attr_specContext) Attr_declarator() IAttr_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_declaratorContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_declaratorContext)
}

func (s *Attr_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAttr_spec(s)
	}
}

func (s *Attr_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAttr_spec(s)
	}
}

func (p *IDLParser) Attr_spec() (localctx IAttr_specContext) {
	localctx = NewAttr_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, IDLParserRULE_attr_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(956)
		p.Match(IDLParserKW_ATTRIBUTE)
	}
	{
		p.SetState(957)
		p.Param_type_spec()
	}
	{
		p.SetState(958)
		p.Attr_declarator()
	}

	return localctx
}

// IAttr_declaratorContext is an interface to support dynamic dispatch.
type IAttr_declaratorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_declaratorContext differentiates from other interfaces.
	IsAttr_declaratorContext()
}

type Attr_declaratorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_declaratorContext() *Attr_declaratorContext {
	var p = new(Attr_declaratorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_attr_declarator
	return p
}

func (*Attr_declaratorContext) IsAttr_declaratorContext() {}

func NewAttr_declaratorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_declaratorContext {
	var p = new(Attr_declaratorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_attr_declarator

	return p
}

func (s *Attr_declaratorContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_declaratorContext) AllSimple_declarator() []ISimple_declaratorContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ISimple_declaratorContext)(nil)).Elem())
	var tst = make([]ISimple_declaratorContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ISimple_declaratorContext)
		}
	}

	return tst
}

func (s *Attr_declaratorContext) Simple_declarator(i int) ISimple_declaratorContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISimple_declaratorContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ISimple_declaratorContext)
}

func (s *Attr_declaratorContext) Attr_raises_expr() IAttr_raises_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_raises_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_raises_exprContext)
}

func (s *Attr_declaratorContext) AllCOMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMA)
}

func (s *Attr_declaratorContext) COMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMA, i)
}

func (s *Attr_declaratorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_declaratorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_declaratorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAttr_declarator(s)
	}
}

func (s *Attr_declaratorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAttr_declarator(s)
	}
}

func (p *IDLParser) Attr_declarator() (localctx IAttr_declaratorContext) {
	localctx = NewAttr_declaratorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, IDLParserRULE_attr_declarator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(971)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(960)
			p.Simple_declarator()
		}
		{
			p.SetState(961)
			p.Attr_raises_expr()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(963)
			p.Simple_declarator()
		}
		p.SetState(968)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == IDLParserCOMA {
			{
				p.SetState(964)
				p.Match(IDLParserCOMA)
			}
			{
				p.SetState(965)
				p.Simple_declarator()
			}

			p.SetState(970)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IAttr_raises_exprContext is an interface to support dynamic dispatch.
type IAttr_raises_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttr_raises_exprContext differentiates from other interfaces.
	IsAttr_raises_exprContext()
}

type Attr_raises_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttr_raises_exprContext() *Attr_raises_exprContext {
	var p = new(Attr_raises_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_attr_raises_expr
	return p
}

func (*Attr_raises_exprContext) IsAttr_raises_exprContext() {}

func NewAttr_raises_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attr_raises_exprContext {
	var p = new(Attr_raises_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_attr_raises_expr

	return p
}

func (s *Attr_raises_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Attr_raises_exprContext) Get_excep_expr() IGet_excep_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGet_excep_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGet_excep_exprContext)
}

func (s *Attr_raises_exprContext) Set_excep_expr() ISet_excep_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISet_excep_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISet_excep_exprContext)
}

func (s *Attr_raises_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attr_raises_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attr_raises_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterAttr_raises_expr(s)
	}
}

func (s *Attr_raises_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitAttr_raises_expr(s)
	}
}

func (p *IDLParser) Attr_raises_expr() (localctx IAttr_raises_exprContext) {
	localctx = NewAttr_raises_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, IDLParserRULE_attr_raises_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(978)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_GETRAISES:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(973)
			p.Get_excep_expr()
		}
		p.SetState(975)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == IDLParserKW_SETRAISES {
			{
				p.SetState(974)
				p.Set_excep_expr()
			}

		}

	case IDLParserKW_SETRAISES:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(977)
			p.Set_excep_expr()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IGet_excep_exprContext is an interface to support dynamic dispatch.
type IGet_excep_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGet_excep_exprContext differentiates from other interfaces.
	IsGet_excep_exprContext()
}

type Get_excep_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGet_excep_exprContext() *Get_excep_exprContext {
	var p = new(Get_excep_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_get_excep_expr
	return p
}

func (*Get_excep_exprContext) IsGet_excep_exprContext() {}

func NewGet_excep_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Get_excep_exprContext {
	var p = new(Get_excep_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_get_excep_expr

	return p
}

func (s *Get_excep_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Get_excep_exprContext) KW_GETRAISES() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_GETRAISES, 0)
}

func (s *Get_excep_exprContext) Exception_list() IException_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IException_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IException_listContext)
}

func (s *Get_excep_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Get_excep_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Get_excep_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterGet_excep_expr(s)
	}
}

func (s *Get_excep_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitGet_excep_expr(s)
	}
}

func (p *IDLParser) Get_excep_expr() (localctx IGet_excep_exprContext) {
	localctx = NewGet_excep_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, IDLParserRULE_get_excep_expr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(980)
		p.Match(IDLParserKW_GETRAISES)
	}
	{
		p.SetState(981)
		p.Exception_list()
	}

	return localctx
}

// ISet_excep_exprContext is an interface to support dynamic dispatch.
type ISet_excep_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSet_excep_exprContext differentiates from other interfaces.
	IsSet_excep_exprContext()
}

type Set_excep_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySet_excep_exprContext() *Set_excep_exprContext {
	var p = new(Set_excep_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_set_excep_expr
	return p
}

func (*Set_excep_exprContext) IsSet_excep_exprContext() {}

func NewSet_excep_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Set_excep_exprContext {
	var p = new(Set_excep_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_set_excep_expr

	return p
}

func (s *Set_excep_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Set_excep_exprContext) KW_SETRAISES() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_SETRAISES, 0)
}

func (s *Set_excep_exprContext) Exception_list() IException_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IException_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IException_listContext)
}

func (s *Set_excep_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Set_excep_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Set_excep_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSet_excep_expr(s)
	}
}

func (s *Set_excep_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSet_excep_expr(s)
	}
}

func (p *IDLParser) Set_excep_expr() (localctx ISet_excep_exprContext) {
	localctx = NewSet_excep_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, IDLParserRULE_set_excep_expr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(983)
		p.Match(IDLParserKW_SETRAISES)
	}
	{
		p.SetState(984)
		p.Exception_list()
	}

	return localctx
}

// IException_listContext is an interface to support dynamic dispatch.
type IException_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsException_listContext differentiates from other interfaces.
	IsException_listContext()
}

type Exception_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyException_listContext() *Exception_listContext {
	var p = new(Exception_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_exception_list
	return p
}

func (*Exception_listContext) IsException_listContext() {}

func NewException_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exception_listContext {
	var p = new(Exception_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_exception_list

	return p
}

func (s *Exception_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Exception_listContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACKET, 0)
}

func (s *Exception_listContext) AllScoped_name() []IScoped_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem())
	var tst = make([]IScoped_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScoped_nameContext)
		}
	}

	return tst
}

func (s *Exception_listContext) Scoped_name(i int) IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Exception_listContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACKET, 0)
}

func (s *Exception_listContext) AllCOMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMA)
}

func (s *Exception_listContext) COMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMA, i)
}

func (s *Exception_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exception_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exception_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterException_list(s)
	}
}

func (s *Exception_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitException_list(s)
	}
}

func (p *IDLParser) Exception_list() (localctx IException_listContext) {
	localctx = NewException_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, IDLParserRULE_exception_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(986)
		p.Match(IDLParserLEFT_BRACKET)
	}
	{
		p.SetState(987)
		p.Scoped_name()
	}
	p.SetState(992)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserCOMA {
		{
			p.SetState(988)
			p.Match(IDLParserCOMA)
		}
		{
			p.SetState(989)
			p.Scoped_name()
		}

		p.SetState(994)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(995)
		p.Match(IDLParserRIGHT_BRACKET)
	}

	return localctx
}

// IComponentContext is an interface to support dynamic dispatch.
type IComponentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponentContext differentiates from other interfaces.
	IsComponentContext()
}

type ComponentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentContext() *ComponentContext {
	var p = new(ComponentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_component
	return p
}

func (*ComponentContext) IsComponentContext() {}

func NewComponentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentContext {
	var p = new(ComponentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_component

	return p
}

func (s *ComponentContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentContext) Component_decl() IComponent_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_declContext)
}

func (s *ComponentContext) Component_forward_decl() IComponent_forward_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_forward_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_forward_declContext)
}

func (s *ComponentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterComponent(s)
	}
}

func (s *ComponentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitComponent(s)
	}
}

func (p *IDLParser) Component() (localctx IComponentContext) {
	localctx = NewComponentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, IDLParserRULE_component)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(999)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 78, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(997)
			p.Component_decl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(998)
			p.Component_forward_decl()
		}

	}

	return localctx
}

// IComponent_forward_declContext is an interface to support dynamic dispatch.
type IComponent_forward_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponent_forward_declContext differentiates from other interfaces.
	IsComponent_forward_declContext()
}

type Component_forward_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponent_forward_declContext() *Component_forward_declContext {
	var p = new(Component_forward_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_component_forward_decl
	return p
}

func (*Component_forward_declContext) IsComponent_forward_declContext() {}

func NewComponent_forward_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Component_forward_declContext {
	var p = new(Component_forward_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_component_forward_decl

	return p
}

func (s *Component_forward_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Component_forward_declContext) KW_COMPONENT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_COMPONENT, 0)
}

func (s *Component_forward_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Component_forward_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Component_forward_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Component_forward_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterComponent_forward_decl(s)
	}
}

func (s *Component_forward_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitComponent_forward_decl(s)
	}
}

func (p *IDLParser) Component_forward_decl() (localctx IComponent_forward_declContext) {
	localctx = NewComponent_forward_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, IDLParserRULE_component_forward_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1001)
		p.Match(IDLParserKW_COMPONENT)
	}
	{
		p.SetState(1002)
		p.Match(IDLParserID)
	}

	return localctx
}

// IComponent_declContext is an interface to support dynamic dispatch.
type IComponent_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponent_declContext differentiates from other interfaces.
	IsComponent_declContext()
}

type Component_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponent_declContext() *Component_declContext {
	var p = new(Component_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_component_decl
	return p
}

func (*Component_declContext) IsComponent_declContext() {}

func NewComponent_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Component_declContext {
	var p = new(Component_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_component_decl

	return p
}

func (s *Component_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Component_declContext) Component_header() IComponent_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_headerContext)
}

func (s *Component_declContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Component_declContext) Component_body() IComponent_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_bodyContext)
}

func (s *Component_declContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Component_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Component_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Component_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterComponent_decl(s)
	}
}

func (s *Component_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitComponent_decl(s)
	}
}

func (p *IDLParser) Component_decl() (localctx IComponent_declContext) {
	localctx = NewComponent_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, IDLParserRULE_component_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1004)
		p.Component_header()
	}
	{
		p.SetState(1005)
		p.Match(IDLParserLEFT_BRACE)
	}
	{
		p.SetState(1006)
		p.Component_body()
	}
	{
		p.SetState(1007)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IComponent_headerContext is an interface to support dynamic dispatch.
type IComponent_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponent_headerContext differentiates from other interfaces.
	IsComponent_headerContext()
}

type Component_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponent_headerContext() *Component_headerContext {
	var p = new(Component_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_component_header
	return p
}

func (*Component_headerContext) IsComponent_headerContext() {}

func NewComponent_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Component_headerContext {
	var p = new(Component_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_component_header

	return p
}

func (s *Component_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Component_headerContext) KW_COMPONENT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_COMPONENT, 0)
}

func (s *Component_headerContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Component_headerContext) Component_inheritance_spec() IComponent_inheritance_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_inheritance_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IComponent_inheritance_specContext)
}

func (s *Component_headerContext) Supported_interface_spec() ISupported_interface_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISupported_interface_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISupported_interface_specContext)
}

func (s *Component_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Component_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Component_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterComponent_header(s)
	}
}

func (s *Component_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitComponent_header(s)
	}
}

func (p *IDLParser) Component_header() (localctx IComponent_headerContext) {
	localctx = NewComponent_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, IDLParserRULE_component_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1009)
		p.Match(IDLParserKW_COMPONENT)
	}
	{
		p.SetState(1010)
		p.Match(IDLParserID)
	}
	p.SetState(1012)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserCOLON {
		{
			p.SetState(1011)
			p.Component_inheritance_spec()
		}

	}
	p.SetState(1015)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_SUPPORTS {
		{
			p.SetState(1014)
			p.Supported_interface_spec()
		}

	}

	return localctx
}

// ISupported_interface_specContext is an interface to support dynamic dispatch.
type ISupported_interface_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSupported_interface_specContext differentiates from other interfaces.
	IsSupported_interface_specContext()
}

type Supported_interface_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySupported_interface_specContext() *Supported_interface_specContext {
	var p = new(Supported_interface_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_supported_interface_spec
	return p
}

func (*Supported_interface_specContext) IsSupported_interface_specContext() {}

func NewSupported_interface_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Supported_interface_specContext {
	var p = new(Supported_interface_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_supported_interface_spec

	return p
}

func (s *Supported_interface_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Supported_interface_specContext) KW_SUPPORTS() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_SUPPORTS, 0)
}

func (s *Supported_interface_specContext) AllScoped_name() []IScoped_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem())
	var tst = make([]IScoped_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IScoped_nameContext)
		}
	}

	return tst
}

func (s *Supported_interface_specContext) Scoped_name(i int) IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Supported_interface_specContext) AllCOMA() []antlr.TerminalNode {
	return s.GetTokens(IDLParserCOMA)
}

func (s *Supported_interface_specContext) COMA(i int) antlr.TerminalNode {
	return s.GetToken(IDLParserCOMA, i)
}

func (s *Supported_interface_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Supported_interface_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Supported_interface_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterSupported_interface_spec(s)
	}
}

func (s *Supported_interface_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitSupported_interface_spec(s)
	}
}

func (p *IDLParser) Supported_interface_spec() (localctx ISupported_interface_specContext) {
	localctx = NewSupported_interface_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, IDLParserRULE_supported_interface_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1017)
		p.Match(IDLParserKW_SUPPORTS)
	}
	{
		p.SetState(1018)
		p.Scoped_name()
	}
	p.SetState(1023)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == IDLParserCOMA {
		{
			p.SetState(1019)
			p.Match(IDLParserCOMA)
		}
		{
			p.SetState(1020)
			p.Scoped_name()
		}

		p.SetState(1025)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComponent_inheritance_specContext is an interface to support dynamic dispatch.
type IComponent_inheritance_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponent_inheritance_specContext differentiates from other interfaces.
	IsComponent_inheritance_specContext()
}

type Component_inheritance_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponent_inheritance_specContext() *Component_inheritance_specContext {
	var p = new(Component_inheritance_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_component_inheritance_spec
	return p
}

func (*Component_inheritance_specContext) IsComponent_inheritance_specContext() {}

func NewComponent_inheritance_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Component_inheritance_specContext {
	var p = new(Component_inheritance_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_component_inheritance_spec

	return p
}

func (s *Component_inheritance_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Component_inheritance_specContext) COLON() antlr.TerminalNode {
	return s.GetToken(IDLParserCOLON, 0)
}

func (s *Component_inheritance_specContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Component_inheritance_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Component_inheritance_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Component_inheritance_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterComponent_inheritance_spec(s)
	}
}

func (s *Component_inheritance_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitComponent_inheritance_spec(s)
	}
}

func (p *IDLParser) Component_inheritance_spec() (localctx IComponent_inheritance_specContext) {
	localctx = NewComponent_inheritance_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, IDLParserRULE_component_inheritance_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1026)
		p.Match(IDLParserCOLON)
	}
	{
		p.SetState(1027)
		p.Scoped_name()
	}

	return localctx
}

// IComponent_bodyContext is an interface to support dynamic dispatch.
type IComponent_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponent_bodyContext differentiates from other interfaces.
	IsComponent_bodyContext()
}

type Component_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponent_bodyContext() *Component_bodyContext {
	var p = new(Component_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_component_body
	return p
}

func (*Component_bodyContext) IsComponent_bodyContext() {}

func NewComponent_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Component_bodyContext {
	var p = new(Component_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_component_body

	return p
}

func (s *Component_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Component_bodyContext) AllComponent_export() []IComponent_exportContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IComponent_exportContext)(nil)).Elem())
	var tst = make([]IComponent_exportContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IComponent_exportContext)
		}
	}

	return tst
}

func (s *Component_bodyContext) Component_export(i int) IComponent_exportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IComponent_exportContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IComponent_exportContext)
}

func (s *Component_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Component_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Component_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterComponent_body(s)
	}
}

func (s *Component_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitComponent_body(s)
	}
}

func (p *IDLParser) Component_body() (localctx IComponent_bodyContext) {
	localctx = NewComponent_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, IDLParserRULE_component_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1032)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(IDLParserKW_EMITS-37))|(1<<(IDLParserKW_PUBLISHES-37))|(1<<(IDLParserKW_USES-37))|(1<<(IDLParserKW_READONLY-37)))) != 0) || (((_la-88)&-(0x1f+1)) == 0 && ((1<<uint((_la-88)))&((1<<(IDLParserKW_PROVIDES-88))|(1<<(IDLParserKW_CONSUMES-88))|(1<<(IDLParserKW_ATTRIBUTE-88)))) != 0) {
		{
			p.SetState(1029)
			p.Component_export()
		}

		p.SetState(1034)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IComponent_exportContext is an interface to support dynamic dispatch.
type IComponent_exportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComponent_exportContext differentiates from other interfaces.
	IsComponent_exportContext()
}

type Component_exportContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponent_exportContext() *Component_exportContext {
	var p = new(Component_exportContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_component_export
	return p
}

func (*Component_exportContext) IsComponent_exportContext() {}

func NewComponent_exportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Component_exportContext {
	var p = new(Component_exportContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_component_export

	return p
}

func (s *Component_exportContext) GetParser() antlr.Parser { return s.parser }

func (s *Component_exportContext) Provides_decl() IProvides_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IProvides_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IProvides_declContext)
}

func (s *Component_exportContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(IDLParserSEMICOLON, 0)
}

func (s *Component_exportContext) Uses_decl() IUses_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUses_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IUses_declContext)
}

func (s *Component_exportContext) Emits_decl() IEmits_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEmits_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEmits_declContext)
}

func (s *Component_exportContext) Publishes_decl() IPublishes_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPublishes_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPublishes_declContext)
}

func (s *Component_exportContext) Consumes_decl() IConsumes_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConsumes_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConsumes_declContext)
}

func (s *Component_exportContext) Attr_decl() IAttr_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttr_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttr_declContext)
}

func (s *Component_exportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Component_exportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Component_exportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterComponent_export(s)
	}
}

func (s *Component_exportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitComponent_export(s)
	}
}

func (p *IDLParser) Component_export() (localctx IComponent_exportContext) {
	localctx = NewComponent_exportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, IDLParserRULE_component_export)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1053)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserKW_PROVIDES:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1035)
			p.Provides_decl()
		}
		{
			p.SetState(1036)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserKW_USES:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1038)
			p.Uses_decl()
		}
		{
			p.SetState(1039)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserKW_EMITS:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1041)
			p.Emits_decl()
		}
		{
			p.SetState(1042)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserKW_PUBLISHES:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1044)
			p.Publishes_decl()
		}
		{
			p.SetState(1045)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserKW_CONSUMES:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1047)
			p.Consumes_decl()
		}
		{
			p.SetState(1048)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserKW_READONLY, IDLParserKW_ATTRIBUTE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1050)
			p.Attr_decl()
		}
		{
			p.SetState(1051)
			p.Match(IDLParserSEMICOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProvides_declContext is an interface to support dynamic dispatch.
type IProvides_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProvides_declContext differentiates from other interfaces.
	IsProvides_declContext()
}

type Provides_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProvides_declContext() *Provides_declContext {
	var p = new(Provides_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_provides_decl
	return p
}

func (*Provides_declContext) IsProvides_declContext() {}

func NewProvides_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Provides_declContext {
	var p = new(Provides_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_provides_decl

	return p
}

func (s *Provides_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Provides_declContext) KW_PROVIDES() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_PROVIDES, 0)
}

func (s *Provides_declContext) Interface_type() IInterface_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_typeContext)
}

func (s *Provides_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Provides_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Provides_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Provides_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterProvides_decl(s)
	}
}

func (s *Provides_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitProvides_decl(s)
	}
}

func (p *IDLParser) Provides_decl() (localctx IProvides_declContext) {
	localctx = NewProvides_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, IDLParserRULE_provides_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1055)
		p.Match(IDLParserKW_PROVIDES)
	}
	{
		p.SetState(1056)
		p.Interface_type()
	}
	{
		p.SetState(1057)
		p.Match(IDLParserID)
	}

	return localctx
}

// IInterface_typeContext is an interface to support dynamic dispatch.
type IInterface_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInterface_typeContext differentiates from other interfaces.
	IsInterface_typeContext()
}

type Interface_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInterface_typeContext() *Interface_typeContext {
	var p = new(Interface_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_interface_type
	return p
}

func (*Interface_typeContext) IsInterface_typeContext() {}

func NewInterface_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Interface_typeContext {
	var p = new(Interface_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_interface_type

	return p
}

func (s *Interface_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Interface_typeContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Interface_typeContext) KW_OBJECT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_OBJECT, 0)
}

func (s *Interface_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Interface_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Interface_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterInterface_type(s)
	}
}

func (s *Interface_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitInterface_type(s)
	}
}

func (p *IDLParser) Interface_type() (localctx IInterface_typeContext) {
	localctx = NewInterface_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, IDLParserRULE_interface_type)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1061)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserDOUBLE_COLON, IDLParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1059)
			p.Scoped_name()
		}

	case IDLParserKW_OBJECT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1060)
			p.Match(IDLParserKW_OBJECT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUses_declContext is an interface to support dynamic dispatch.
type IUses_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUses_declContext differentiates from other interfaces.
	IsUses_declContext()
}

type Uses_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUses_declContext() *Uses_declContext {
	var p = new(Uses_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_uses_decl
	return p
}

func (*Uses_declContext) IsUses_declContext() {}

func NewUses_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Uses_declContext {
	var p = new(Uses_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_uses_decl

	return p
}

func (s *Uses_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Uses_declContext) KW_USES() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_USES, 0)
}

func (s *Uses_declContext) Interface_type() IInterface_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInterface_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInterface_typeContext)
}

func (s *Uses_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Uses_declContext) KW_MULTIPLE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_MULTIPLE, 0)
}

func (s *Uses_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Uses_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Uses_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterUses_decl(s)
	}
}

func (s *Uses_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitUses_decl(s)
	}
}

func (p *IDLParser) Uses_decl() (localctx IUses_declContext) {
	localctx = NewUses_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, IDLParserRULE_uses_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1063)
		p.Match(IDLParserKW_USES)
	}
	p.SetState(1065)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_MULTIPLE {
		{
			p.SetState(1064)
			p.Match(IDLParserKW_MULTIPLE)
		}

	}
	{
		p.SetState(1067)
		p.Interface_type()
	}
	{
		p.SetState(1068)
		p.Match(IDLParserID)
	}

	return localctx
}

// IEmits_declContext is an interface to support dynamic dispatch.
type IEmits_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEmits_declContext differentiates from other interfaces.
	IsEmits_declContext()
}

type Emits_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEmits_declContext() *Emits_declContext {
	var p = new(Emits_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_emits_decl
	return p
}

func (*Emits_declContext) IsEmits_declContext() {}

func NewEmits_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Emits_declContext {
	var p = new(Emits_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_emits_decl

	return p
}

func (s *Emits_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Emits_declContext) KW_EMITS() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_EMITS, 0)
}

func (s *Emits_declContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Emits_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Emits_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Emits_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Emits_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterEmits_decl(s)
	}
}

func (s *Emits_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitEmits_decl(s)
	}
}

func (p *IDLParser) Emits_decl() (localctx IEmits_declContext) {
	localctx = NewEmits_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, IDLParserRULE_emits_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1070)
		p.Match(IDLParserKW_EMITS)
	}
	{
		p.SetState(1071)
		p.Scoped_name()
	}
	{
		p.SetState(1072)
		p.Match(IDLParserID)
	}

	return localctx
}

// IPublishes_declContext is an interface to support dynamic dispatch.
type IPublishes_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPublishes_declContext differentiates from other interfaces.
	IsPublishes_declContext()
}

type Publishes_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPublishes_declContext() *Publishes_declContext {
	var p = new(Publishes_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_publishes_decl
	return p
}

func (*Publishes_declContext) IsPublishes_declContext() {}

func NewPublishes_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Publishes_declContext {
	var p = new(Publishes_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_publishes_decl

	return p
}

func (s *Publishes_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Publishes_declContext) KW_PUBLISHES() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_PUBLISHES, 0)
}

func (s *Publishes_declContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Publishes_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Publishes_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Publishes_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Publishes_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterPublishes_decl(s)
	}
}

func (s *Publishes_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitPublishes_decl(s)
	}
}

func (p *IDLParser) Publishes_decl() (localctx IPublishes_declContext) {
	localctx = NewPublishes_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, IDLParserRULE_publishes_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1074)
		p.Match(IDLParserKW_PUBLISHES)
	}
	{
		p.SetState(1075)
		p.Scoped_name()
	}
	{
		p.SetState(1076)
		p.Match(IDLParserID)
	}

	return localctx
}

// IConsumes_declContext is an interface to support dynamic dispatch.
type IConsumes_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConsumes_declContext differentiates from other interfaces.
	IsConsumes_declContext()
}

type Consumes_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConsumes_declContext() *Consumes_declContext {
	var p = new(Consumes_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_consumes_decl
	return p
}

func (*Consumes_declContext) IsConsumes_declContext() {}

func NewConsumes_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Consumes_declContext {
	var p = new(Consumes_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_consumes_decl

	return p
}

func (s *Consumes_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Consumes_declContext) KW_CONSUMES() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_CONSUMES, 0)
}

func (s *Consumes_declContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Consumes_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Consumes_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Consumes_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Consumes_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterConsumes_decl(s)
	}
}

func (s *Consumes_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitConsumes_decl(s)
	}
}

func (p *IDLParser) Consumes_decl() (localctx IConsumes_declContext) {
	localctx = NewConsumes_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, IDLParserRULE_consumes_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1078)
		p.Match(IDLParserKW_CONSUMES)
	}
	{
		p.SetState(1079)
		p.Scoped_name()
	}
	{
		p.SetState(1080)
		p.Match(IDLParserID)
	}

	return localctx
}

// IHome_declContext is an interface to support dynamic dispatch.
type IHome_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHome_declContext differentiates from other interfaces.
	IsHome_declContext()
}

type Home_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHome_declContext() *Home_declContext {
	var p = new(Home_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_home_decl
	return p
}

func (*Home_declContext) IsHome_declContext() {}

func NewHome_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Home_declContext {
	var p = new(Home_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_home_decl

	return p
}

func (s *Home_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Home_declContext) Home_header() IHome_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHome_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHome_headerContext)
}

func (s *Home_declContext) Home_body() IHome_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHome_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHome_bodyContext)
}

func (s *Home_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Home_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Home_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterHome_decl(s)
	}
}

func (s *Home_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitHome_decl(s)
	}
}

func (p *IDLParser) Home_decl() (localctx IHome_declContext) {
	localctx = NewHome_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, IDLParserRULE_home_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1082)
		p.Home_header()
	}
	{
		p.SetState(1083)
		p.Home_body()
	}

	return localctx
}

// IHome_headerContext is an interface to support dynamic dispatch.
type IHome_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHome_headerContext differentiates from other interfaces.
	IsHome_headerContext()
}

type Home_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHome_headerContext() *Home_headerContext {
	var p = new(Home_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_home_header
	return p
}

func (*Home_headerContext) IsHome_headerContext() {}

func NewHome_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Home_headerContext {
	var p = new(Home_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_home_header

	return p
}

func (s *Home_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Home_headerContext) KW_HOME() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_HOME, 0)
}

func (s *Home_headerContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Home_headerContext) KW_MANAGES() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_MANAGES, 0)
}

func (s *Home_headerContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Home_headerContext) Home_inheritance_spec() IHome_inheritance_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHome_inheritance_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHome_inheritance_specContext)
}

func (s *Home_headerContext) Supported_interface_spec() ISupported_interface_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISupported_interface_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISupported_interface_specContext)
}

func (s *Home_headerContext) Primary_key_spec() IPrimary_key_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPrimary_key_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPrimary_key_specContext)
}

func (s *Home_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Home_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Home_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterHome_header(s)
	}
}

func (s *Home_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitHome_header(s)
	}
}

func (p *IDLParser) Home_header() (localctx IHome_headerContext) {
	localctx = NewHome_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, IDLParserRULE_home_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1085)
		p.Match(IDLParserKW_HOME)
	}
	{
		p.SetState(1086)
		p.Match(IDLParserID)
	}
	p.SetState(1088)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserCOLON {
		{
			p.SetState(1087)
			p.Home_inheritance_spec()
		}

	}
	p.SetState(1091)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_SUPPORTS {
		{
			p.SetState(1090)
			p.Supported_interface_spec()
		}

	}
	{
		p.SetState(1093)
		p.Match(IDLParserKW_MANAGES)
	}
	{
		p.SetState(1094)
		p.Scoped_name()
	}
	p.SetState(1096)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_PRIMARYKEY {
		{
			p.SetState(1095)
			p.Primary_key_spec()
		}

	}

	return localctx
}

// IHome_inheritance_specContext is an interface to support dynamic dispatch.
type IHome_inheritance_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHome_inheritance_specContext differentiates from other interfaces.
	IsHome_inheritance_specContext()
}

type Home_inheritance_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHome_inheritance_specContext() *Home_inheritance_specContext {
	var p = new(Home_inheritance_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_home_inheritance_spec
	return p
}

func (*Home_inheritance_specContext) IsHome_inheritance_specContext() {}

func NewHome_inheritance_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Home_inheritance_specContext {
	var p = new(Home_inheritance_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_home_inheritance_spec

	return p
}

func (s *Home_inheritance_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Home_inheritance_specContext) COLON() antlr.TerminalNode {
	return s.GetToken(IDLParserCOLON, 0)
}

func (s *Home_inheritance_specContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Home_inheritance_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Home_inheritance_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Home_inheritance_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterHome_inheritance_spec(s)
	}
}

func (s *Home_inheritance_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitHome_inheritance_spec(s)
	}
}

func (p *IDLParser) Home_inheritance_spec() (localctx IHome_inheritance_specContext) {
	localctx = NewHome_inheritance_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, IDLParserRULE_home_inheritance_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1098)
		p.Match(IDLParserCOLON)
	}
	{
		p.SetState(1099)
		p.Scoped_name()
	}

	return localctx
}

// IPrimary_key_specContext is an interface to support dynamic dispatch.
type IPrimary_key_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPrimary_key_specContext differentiates from other interfaces.
	IsPrimary_key_specContext()
}

type Primary_key_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrimary_key_specContext() *Primary_key_specContext {
	var p = new(Primary_key_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_primary_key_spec
	return p
}

func (*Primary_key_specContext) IsPrimary_key_specContext() {}

func NewPrimary_key_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Primary_key_specContext {
	var p = new(Primary_key_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_primary_key_spec

	return p
}

func (s *Primary_key_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Primary_key_specContext) KW_PRIMARYKEY() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_PRIMARYKEY, 0)
}

func (s *Primary_key_specContext) Scoped_name() IScoped_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScoped_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScoped_nameContext)
}

func (s *Primary_key_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Primary_key_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Primary_key_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterPrimary_key_spec(s)
	}
}

func (s *Primary_key_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitPrimary_key_spec(s)
	}
}

func (p *IDLParser) Primary_key_spec() (localctx IPrimary_key_specContext) {
	localctx = NewPrimary_key_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, IDLParserRULE_primary_key_spec)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1101)
		p.Match(IDLParserKW_PRIMARYKEY)
	}
	{
		p.SetState(1102)
		p.Scoped_name()
	}

	return localctx
}

// IHome_bodyContext is an interface to support dynamic dispatch.
type IHome_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHome_bodyContext differentiates from other interfaces.
	IsHome_bodyContext()
}

type Home_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHome_bodyContext() *Home_bodyContext {
	var p = new(Home_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_home_body
	return p
}

func (*Home_bodyContext) IsHome_bodyContext() {}

func NewHome_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Home_bodyContext {
	var p = new(Home_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_home_body

	return p
}

func (s *Home_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Home_bodyContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Home_bodyContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Home_bodyContext) AllHome_export() []IHome_exportContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IHome_exportContext)(nil)).Elem())
	var tst = make([]IHome_exportContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IHome_exportContext)
		}
	}

	return tst
}

func (s *Home_bodyContext) Home_export(i int) IHome_exportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHome_exportContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IHome_exportContext)
}

func (s *Home_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Home_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Home_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterHome_body(s)
	}
}

func (s *Home_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitHome_body(s)
	}
}

func (p *IDLParser) Home_body() (localctx IHome_bodyContext) {
	localctx = NewHome_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, IDLParserRULE_home_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1104)
		p.Match(IDLParserLEFT_BRACE)
	}
	p.SetState(1108)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(IDLParserDOUBLE_COLON-32))|(1<<(IDLParserKW_STRING-32))|(1<<(IDLParserKW_TYPEDEF-32))|(1<<(IDLParserKW_OCTET-32))|(1<<(IDLParserKW_STRUCT-32))|(1<<(IDLParserKW_NATIVE-32))|(1<<(IDLParserKW_READONLY-32))|(1<<(IDLParserKW_FINDER-32))|(1<<(IDLParserKW_VOID-32))|(1<<(IDLParserKW_WCHAR-32))|(1<<(IDLParserKW_SHORT-32))|(1<<(IDLParserKW_LONG-32))|(1<<(IDLParserKW_ENUM-32))|(1<<(IDLParserKW_WSTRING-32)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(IDLParserKW_FACTORY-66))|(1<<(IDLParserKW_EXCEPTION-66))|(1<<(IDLParserKW_CONST-66))|(1<<(IDLParserKW_VALUEBASE-66))|(1<<(IDLParserKW_OBJECT-66))|(1<<(IDLParserKW_UNSIGNED-66))|(1<<(IDLParserKW_UNION-66))|(1<<(IDLParserKW_ONEWAY-66))|(1<<(IDLParserKW_ANY-66))|(1<<(IDLParserKW_CHAR-66))|(1<<(IDLParserKW_FLOAT-66))|(1<<(IDLParserKW_BOOLEAN-66))|(1<<(IDLParserKW_DOUBLE-66))|(1<<(IDLParserKW_TYPEPREFIX-66))|(1<<(IDLParserKW_TYPEID-66))|(1<<(IDLParserKW_ATTRIBUTE-66)))) != 0) || _la == IDLParserID {
		{
			p.SetState(1105)
			p.Home_export()
		}

		p.SetState(1110)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1111)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IHome_exportContext is an interface to support dynamic dispatch.
type IHome_exportContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHome_exportContext differentiates from other interfaces.
	IsHome_exportContext()
}

type Home_exportContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHome_exportContext() *Home_exportContext {
	var p = new(Home_exportContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_home_export
	return p
}

func (*Home_exportContext) IsHome_exportContext() {}

func NewHome_exportContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Home_exportContext {
	var p = new(Home_exportContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_home_export

	return p
}

func (s *Home_exportContext) GetParser() antlr.Parser { return s.parser }

func (s *Home_exportContext) Export() IExportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExportContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExportContext)
}

func (s *Home_exportContext) Factory_decl() IFactory_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFactory_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFactory_declContext)
}

func (s *Home_exportContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(IDLParserSEMICOLON, 0)
}

func (s *Home_exportContext) Finder_decl() IFinder_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFinder_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFinder_declContext)
}

func (s *Home_exportContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Home_exportContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Home_exportContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterHome_export(s)
	}
}

func (s *Home_exportContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitHome_export(s)
	}
}

func (p *IDLParser) Home_export() (localctx IHome_exportContext) {
	localctx = NewHome_exportContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, IDLParserRULE_home_export)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1120)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case IDLParserDOUBLE_COLON, IDLParserKW_STRING, IDLParserKW_TYPEDEF, IDLParserKW_OCTET, IDLParserKW_STRUCT, IDLParserKW_NATIVE, IDLParserKW_READONLY, IDLParserKW_VOID, IDLParserKW_WCHAR, IDLParserKW_SHORT, IDLParserKW_LONG, IDLParserKW_ENUM, IDLParserKW_WSTRING, IDLParserKW_EXCEPTION, IDLParserKW_CONST, IDLParserKW_VALUEBASE, IDLParserKW_OBJECT, IDLParserKW_UNSIGNED, IDLParserKW_UNION, IDLParserKW_ONEWAY, IDLParserKW_ANY, IDLParserKW_CHAR, IDLParserKW_FLOAT, IDLParserKW_BOOLEAN, IDLParserKW_DOUBLE, IDLParserKW_TYPEPREFIX, IDLParserKW_TYPEID, IDLParserKW_ATTRIBUTE, IDLParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1113)
			p.Export()
		}

	case IDLParserKW_FACTORY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1114)
			p.Factory_decl()
		}
		{
			p.SetState(1115)
			p.Match(IDLParserSEMICOLON)
		}

	case IDLParserKW_FINDER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1117)
			p.Finder_decl()
		}
		{
			p.SetState(1118)
			p.Match(IDLParserSEMICOLON)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFactory_declContext is an interface to support dynamic dispatch.
type IFactory_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFactory_declContext differentiates from other interfaces.
	IsFactory_declContext()
}

type Factory_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFactory_declContext() *Factory_declContext {
	var p = new(Factory_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_factory_decl
	return p
}

func (*Factory_declContext) IsFactory_declContext() {}

func NewFactory_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Factory_declContext {
	var p = new(Factory_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_factory_decl

	return p
}

func (s *Factory_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Factory_declContext) KW_FACTORY() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_FACTORY, 0)
}

func (s *Factory_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Factory_declContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACKET, 0)
}

func (s *Factory_declContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACKET, 0)
}

func (s *Factory_declContext) Init_param_decls() IInit_param_declsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_param_declsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_param_declsContext)
}

func (s *Factory_declContext) Raises_expr() IRaises_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRaises_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRaises_exprContext)
}

func (s *Factory_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Factory_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Factory_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterFactory_decl(s)
	}
}

func (s *Factory_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitFactory_decl(s)
	}
}

func (p *IDLParser) Factory_decl() (localctx IFactory_declContext) {
	localctx = NewFactory_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, IDLParserRULE_factory_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1122)
		p.Match(IDLParserKW_FACTORY)
	}
	{
		p.SetState(1123)
		p.Match(IDLParserID)
	}
	{
		p.SetState(1124)
		p.Match(IDLParserLEFT_BRACKET)
	}
	p.SetState(1126)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_IN {
		{
			p.SetState(1125)
			p.Init_param_decls()
		}

	}
	{
		p.SetState(1128)
		p.Match(IDLParserRIGHT_BRACKET)
	}
	p.SetState(1130)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_RAISES {
		{
			p.SetState(1129)
			p.Raises_expr()
		}

	}

	return localctx
}

// IFinder_declContext is an interface to support dynamic dispatch.
type IFinder_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFinder_declContext differentiates from other interfaces.
	IsFinder_declContext()
}

type Finder_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFinder_declContext() *Finder_declContext {
	var p = new(Finder_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_finder_decl
	return p
}

func (*Finder_declContext) IsFinder_declContext() {}

func NewFinder_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Finder_declContext {
	var p = new(Finder_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_finder_decl

	return p
}

func (s *Finder_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Finder_declContext) KW_FINDER() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_FINDER, 0)
}

func (s *Finder_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Finder_declContext) LEFT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACKET, 0)
}

func (s *Finder_declContext) RIGHT_BRACKET() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACKET, 0)
}

func (s *Finder_declContext) Init_param_decls() IInit_param_declsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IInit_param_declsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IInit_param_declsContext)
}

func (s *Finder_declContext) Raises_expr() IRaises_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRaises_exprContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRaises_exprContext)
}

func (s *Finder_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Finder_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Finder_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterFinder_decl(s)
	}
}

func (s *Finder_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitFinder_decl(s)
	}
}

func (p *IDLParser) Finder_decl() (localctx IFinder_declContext) {
	localctx = NewFinder_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, IDLParserRULE_finder_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1132)
		p.Match(IDLParserKW_FINDER)
	}
	{
		p.SetState(1133)
		p.Match(IDLParserID)
	}
	{
		p.SetState(1134)
		p.Match(IDLParserLEFT_BRACKET)
	}
	p.SetState(1136)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_IN {
		{
			p.SetState(1135)
			p.Init_param_decls()
		}

	}
	{
		p.SetState(1138)
		p.Match(IDLParserRIGHT_BRACKET)
	}
	p.SetState(1140)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_RAISES {
		{
			p.SetState(1139)
			p.Raises_expr()
		}

	}

	return localctx
}

// IEventContext is an interface to support dynamic dispatch.
type IEventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEventContext differentiates from other interfaces.
	IsEventContext()
}

type EventContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventContext() *EventContext {
	var p = new(EventContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_event
	return p
}

func (*EventContext) IsEventContext() {}

func NewEventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventContext {
	var p = new(EventContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_event

	return p
}

func (s *EventContext) GetParser() antlr.Parser { return s.parser }

func (s *EventContext) Event_decl() IEvent_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_declContext)
}

func (s *EventContext) Event_abs_decl() IEvent_abs_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_abs_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_abs_declContext)
}

func (s *EventContext) Event_forward_decl() IEvent_forward_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_forward_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_forward_declContext)
}

func (s *EventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterEvent(s)
	}
}

func (s *EventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitEvent(s)
	}
}

func (p *IDLParser) Event() (localctx IEventContext) {
	localctx = NewEventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, IDLParserRULE_event)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1145)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1142)
			p.Event_decl()
		}

	case 2:
		{
			p.SetState(1143)
			p.Event_abs_decl()
		}

	case 3:
		{
			p.SetState(1144)
			p.Event_forward_decl()
		}

	}

	return localctx
}

// IEvent_forward_declContext is an interface to support dynamic dispatch.
type IEvent_forward_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_forward_declContext differentiates from other interfaces.
	IsEvent_forward_declContext()
}

type Event_forward_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_forward_declContext() *Event_forward_declContext {
	var p = new(Event_forward_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_event_forward_decl
	return p
}

func (*Event_forward_declContext) IsEvent_forward_declContext() {}

func NewEvent_forward_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_forward_declContext {
	var p = new(Event_forward_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_event_forward_decl

	return p
}

func (s *Event_forward_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_forward_declContext) KW_EVENTTYPE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_EVENTTYPE, 0)
}

func (s *Event_forward_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Event_forward_declContext) KW_ABSTRACT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_ABSTRACT, 0)
}

func (s *Event_forward_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_forward_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_forward_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterEvent_forward_decl(s)
	}
}

func (s *Event_forward_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitEvent_forward_decl(s)
	}
}

func (p *IDLParser) Event_forward_decl() (localctx IEvent_forward_declContext) {
	localctx = NewEvent_forward_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, IDLParserRULE_event_forward_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1148)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_ABSTRACT {
		{
			p.SetState(1147)
			p.Match(IDLParserKW_ABSTRACT)
		}

	}
	{
		p.SetState(1150)
		p.Match(IDLParserKW_EVENTTYPE)
	}
	{
		p.SetState(1151)
		p.Match(IDLParserID)
	}

	return localctx
}

// IEvent_abs_declContext is an interface to support dynamic dispatch.
type IEvent_abs_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_abs_declContext differentiates from other interfaces.
	IsEvent_abs_declContext()
}

type Event_abs_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_abs_declContext() *Event_abs_declContext {
	var p = new(Event_abs_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_event_abs_decl
	return p
}

func (*Event_abs_declContext) IsEvent_abs_declContext() {}

func NewEvent_abs_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_abs_declContext {
	var p = new(Event_abs_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_event_abs_decl

	return p
}

func (s *Event_abs_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_abs_declContext) KW_ABSTRACT() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_ABSTRACT, 0)
}

func (s *Event_abs_declContext) KW_EVENTTYPE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_EVENTTYPE, 0)
}

func (s *Event_abs_declContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Event_abs_declContext) Value_inheritance_spec() IValue_inheritance_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_inheritance_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_inheritance_specContext)
}

func (s *Event_abs_declContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Event_abs_declContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Event_abs_declContext) AllExport() []IExportContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExportContext)(nil)).Elem())
	var tst = make([]IExportContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExportContext)
		}
	}

	return tst
}

func (s *Event_abs_declContext) Export(i int) IExportContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExportContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExportContext)
}

func (s *Event_abs_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_abs_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_abs_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterEvent_abs_decl(s)
	}
}

func (s *Event_abs_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitEvent_abs_decl(s)
	}
}

func (p *IDLParser) Event_abs_decl() (localctx IEvent_abs_declContext) {
	localctx = NewEvent_abs_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, IDLParserRULE_event_abs_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1153)
		p.Match(IDLParserKW_ABSTRACT)
	}
	{
		p.SetState(1154)
		p.Match(IDLParserKW_EVENTTYPE)
	}
	{
		p.SetState(1155)
		p.Match(IDLParserID)
	}
	{
		p.SetState(1156)
		p.Value_inheritance_spec()
	}
	{
		p.SetState(1157)
		p.Match(IDLParserLEFT_BRACE)
	}
	p.SetState(1161)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(IDLParserDOUBLE_COLON-32))|(1<<(IDLParserKW_STRING-32))|(1<<(IDLParserKW_TYPEDEF-32))|(1<<(IDLParserKW_OCTET-32))|(1<<(IDLParserKW_STRUCT-32))|(1<<(IDLParserKW_NATIVE-32))|(1<<(IDLParserKW_READONLY-32))|(1<<(IDLParserKW_VOID-32))|(1<<(IDLParserKW_WCHAR-32))|(1<<(IDLParserKW_SHORT-32))|(1<<(IDLParserKW_LONG-32))|(1<<(IDLParserKW_ENUM-32))|(1<<(IDLParserKW_WSTRING-32)))) != 0) || (((_la-67)&-(0x1f+1)) == 0 && ((1<<uint((_la-67)))&((1<<(IDLParserKW_EXCEPTION-67))|(1<<(IDLParserKW_CONST-67))|(1<<(IDLParserKW_VALUEBASE-67))|(1<<(IDLParserKW_OBJECT-67))|(1<<(IDLParserKW_UNSIGNED-67))|(1<<(IDLParserKW_UNION-67))|(1<<(IDLParserKW_ONEWAY-67))|(1<<(IDLParserKW_ANY-67))|(1<<(IDLParserKW_CHAR-67))|(1<<(IDLParserKW_FLOAT-67))|(1<<(IDLParserKW_BOOLEAN-67))|(1<<(IDLParserKW_DOUBLE-67))|(1<<(IDLParserKW_TYPEPREFIX-67))|(1<<(IDLParserKW_TYPEID-67))|(1<<(IDLParserKW_ATTRIBUTE-67))|(1<<(IDLParserID-67)))) != 0) {
		{
			p.SetState(1158)
			p.Export()
		}

		p.SetState(1163)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1164)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IEvent_declContext is an interface to support dynamic dispatch.
type IEvent_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_declContext differentiates from other interfaces.
	IsEvent_declContext()
}

type Event_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_declContext() *Event_declContext {
	var p = new(Event_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_event_decl
	return p
}

func (*Event_declContext) IsEvent_declContext() {}

func NewEvent_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_declContext {
	var p = new(Event_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_event_decl

	return p
}

func (s *Event_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_declContext) Event_header() IEvent_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_headerContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_headerContext)
}

func (s *Event_declContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserLEFT_BRACE, 0)
}

func (s *Event_declContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(IDLParserRIGHT_BRACE, 0)
}

func (s *Event_declContext) AllValue_element() []IValue_elementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IValue_elementContext)(nil)).Elem())
	var tst = make([]IValue_elementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IValue_elementContext)
		}
	}

	return tst
}

func (s *Event_declContext) Value_element(i int) IValue_elementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_elementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IValue_elementContext)
}

func (s *Event_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterEvent_decl(s)
	}
}

func (s *Event_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitEvent_decl(s)
	}
}

func (p *IDLParser) Event_decl() (localctx IEvent_declContext) {
	localctx = NewEvent_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, IDLParserRULE_event_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1166)
		p.Event_header()
	}
	{
		p.SetState(1167)
		p.Match(IDLParserLEFT_BRACE)
	}
	p.SetState(1171)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(IDLParserDOUBLE_COLON-32))|(1<<(IDLParserKW_STRING-32))|(1<<(IDLParserKW_TYPEDEF-32))|(1<<(IDLParserKW_OCTET-32))|(1<<(IDLParserKW_STRUCT-32))|(1<<(IDLParserKW_NATIVE-32))|(1<<(IDLParserKW_READONLY-32))|(1<<(IDLParserKW_VOID-32))|(1<<(IDLParserKW_PRIVATE-32))|(1<<(IDLParserKW_WCHAR-32))|(1<<(IDLParserKW_PUBLIC-32))|(1<<(IDLParserKW_SHORT-32))|(1<<(IDLParserKW_LONG-32))|(1<<(IDLParserKW_ENUM-32))|(1<<(IDLParserKW_WSTRING-32)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(IDLParserKW_FACTORY-66))|(1<<(IDLParserKW_EXCEPTION-66))|(1<<(IDLParserKW_CONST-66))|(1<<(IDLParserKW_VALUEBASE-66))|(1<<(IDLParserKW_OBJECT-66))|(1<<(IDLParserKW_UNSIGNED-66))|(1<<(IDLParserKW_UNION-66))|(1<<(IDLParserKW_ONEWAY-66))|(1<<(IDLParserKW_ANY-66))|(1<<(IDLParserKW_CHAR-66))|(1<<(IDLParserKW_FLOAT-66))|(1<<(IDLParserKW_BOOLEAN-66))|(1<<(IDLParserKW_DOUBLE-66))|(1<<(IDLParserKW_TYPEPREFIX-66))|(1<<(IDLParserKW_TYPEID-66))|(1<<(IDLParserKW_ATTRIBUTE-66)))) != 0) || _la == IDLParserID {
		{
			p.SetState(1168)
			p.Value_element()
		}

		p.SetState(1173)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1174)
		p.Match(IDLParserRIGHT_BRACE)
	}

	return localctx
}

// IEvent_headerContext is an interface to support dynamic dispatch.
type IEvent_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_headerContext differentiates from other interfaces.
	IsEvent_headerContext()
}

type Event_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_headerContext() *Event_headerContext {
	var p = new(Event_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = IDLParserRULE_event_header
	return p
}

func (*Event_headerContext) IsEvent_headerContext() {}

func NewEvent_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_headerContext {
	var p = new(Event_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = IDLParserRULE_event_header

	return p
}

func (s *Event_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_headerContext) KW_EVENTTYPE() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_EVENTTYPE, 0)
}

func (s *Event_headerContext) ID() antlr.TerminalNode {
	return s.GetToken(IDLParserID, 0)
}

func (s *Event_headerContext) Value_inheritance_spec() IValue_inheritance_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IValue_inheritance_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IValue_inheritance_specContext)
}

func (s *Event_headerContext) KW_CUSTOM() antlr.TerminalNode {
	return s.GetToken(IDLParserKW_CUSTOM, 0)
}

func (s *Event_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.EnterEvent_header(s)
	}
}

func (s *Event_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(IDLListener); ok {
		listenerT.ExitEvent_header(s)
	}
}

func (p *IDLParser) Event_header() (localctx IEvent_headerContext) {
	localctx = NewEvent_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, IDLParserRULE_event_header)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1177)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == IDLParserKW_CUSTOM {
		{
			p.SetState(1176)
			p.Match(IDLParserKW_CUSTOM)
		}

	}
	{
		p.SetState(1179)
		p.Match(IDLParserKW_EVENTTYPE)
	}
	{
		p.SetState(1180)
		p.Match(IDLParserID)
	}
	{
		p.SetState(1181)
		p.Value_inheritance_spec()
	}

	return localctx
}
