// Code generated from powerbuilderParser.g4 by ANTLR 4.7.2. DO NOT EDIT.

package powerbuilder // powerbuilderParser
import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 125, 1250,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 4,
	92, 9, 92, 4, 93, 9, 93, 4, 94, 9, 94, 4, 95, 9, 95, 4, 96, 9, 96, 4, 97,
	9, 97, 4, 98, 9, 98, 4, 99, 9, 99, 4, 100, 9, 100, 4, 101, 9, 101, 4, 102,
	9, 102, 3, 2, 5, 2, 206, 10, 2, 3, 2, 6, 2, 209, 10, 2, 13, 2, 14, 2, 210,
	3, 2, 3, 2, 3, 3, 7, 3, 216, 10, 3, 12, 3, 14, 3, 219, 11, 3, 3, 3, 5,
	3, 222, 10, 3, 3, 3, 7, 3, 225, 10, 3, 12, 3, 14, 3, 228, 11, 3, 3, 4,
	3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 3, 4, 5, 4,
	242, 10, 4, 3, 5, 3, 5, 3, 6, 3, 6, 3, 6, 3, 6, 3, 7, 6, 7, 251, 10, 7,
	13, 7, 14, 7, 252, 3, 8, 3, 8, 5, 8, 257, 10, 8, 3, 8, 3, 8, 5, 8, 261,
	10, 8, 3, 8, 3, 8, 3, 9, 6, 9, 266, 10, 9, 13, 9, 14, 9, 267, 3, 10, 3,
	10, 3, 10, 3, 10, 3, 10, 5, 10, 275, 10, 10, 3, 10, 5, 10, 278, 10, 10,
	3, 10, 3, 10, 3, 10, 3, 10, 5, 10, 284, 10, 10, 3, 10, 3, 10, 3, 10, 3,
	10, 5, 10, 290, 10, 10, 3, 10, 5, 10, 293, 10, 10, 5, 10, 295, 10, 10,
	3, 11, 3, 11, 3, 11, 5, 11, 300, 10, 11, 3, 11, 5, 11, 303, 10, 11, 3,
	11, 3, 11, 3, 11, 3, 11, 3, 11, 3, 11, 5, 11, 311, 10, 11, 7, 11, 313,
	10, 11, 12, 11, 14, 11, 316, 11, 11, 3, 12, 3, 12, 3, 12, 5, 12, 321, 10,
	12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12,
	3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 340, 10, 12, 3,
	12, 3, 12, 3, 12, 5, 12, 345, 10, 12, 5, 12, 347, 10, 12, 3, 12, 3, 12,
	3, 12, 3, 12, 3, 12, 5, 12, 354, 10, 12, 3, 12, 3, 12, 3, 12, 5, 12, 359,
	10, 12, 5, 12, 361, 10, 12, 3, 12, 3, 12, 7, 12, 365, 10, 12, 12, 12, 14,
	12, 368, 11, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 3, 12, 5, 12, 376,
	10, 12, 5, 12, 378, 10, 12, 3, 13, 3, 13, 3, 13, 6, 13, 383, 10, 13, 13,
	13, 14, 13, 384, 3, 13, 3, 13, 3, 13, 3, 14, 5, 14, 391, 10, 14, 3, 14,
	3, 14, 3, 14, 3, 14, 3, 14, 3, 14, 5, 14, 399, 10, 14, 3, 14, 3, 14, 3,
	14, 5, 14, 404, 10, 14, 3, 14, 5, 14, 407, 10, 14, 3, 14, 3, 14, 3, 14,
	3, 14, 5, 14, 413, 10, 14, 3, 14, 3, 14, 7, 14, 417, 10, 14, 12, 14, 14,
	14, 420, 11, 14, 3, 14, 3, 14, 3, 14, 3, 15, 3, 15, 3, 15, 3, 15, 3, 15,
	7, 15, 430, 10, 15, 12, 15, 14, 15, 433, 11, 15, 3, 15, 3, 15, 3, 15, 3,
	16, 3, 16, 3, 16, 3, 16, 7, 16, 442, 10, 16, 12, 16, 14, 16, 445, 11, 16,
	3, 16, 3, 16, 3, 16, 3, 17, 5, 17, 451, 10, 17, 3, 17, 5, 17, 454, 10,
	17, 3, 17, 5, 17, 457, 10, 17, 3, 18, 3, 18, 3, 18, 3, 19, 3, 19, 3, 19,
	3, 19, 3, 20, 3, 20, 3, 20, 5, 20, 469, 10, 20, 3, 20, 3, 20, 3, 20, 5,
	20, 474, 10, 20, 3, 20, 5, 20, 477, 10, 20, 3, 20, 3, 20, 5, 20, 481, 10,
	20, 3, 20, 3, 20, 3, 20, 5, 20, 486, 10, 20, 3, 20, 5, 20, 489, 10, 20,
	7, 20, 491, 10, 20, 12, 20, 14, 20, 494, 11, 20, 5, 20, 496, 10, 20, 3,
	20, 5, 20, 499, 10, 20, 3, 21, 3, 21, 3, 22, 3, 22, 3, 22, 3, 23, 5, 23,
	507, 10, 23, 3, 23, 5, 23, 510, 10, 23, 3, 23, 3, 23, 3, 23, 5, 23, 515,
	10, 23, 3, 23, 3, 23, 3, 23, 5, 23, 520, 10, 23, 3, 23, 3, 23, 3, 23, 3,
	23, 3, 23, 3, 23, 5, 23, 528, 10, 23, 5, 23, 530, 10, 23, 3, 23, 3, 23,
	3, 23, 3, 23, 5, 23, 536, 10, 23, 3, 23, 3, 23, 5, 23, 540, 10, 23, 3,
	24, 5, 24, 543, 10, 24, 3, 24, 5, 24, 546, 10, 24, 3, 24, 3, 24, 5, 24,
	550, 10, 24, 3, 24, 3, 24, 5, 24, 554, 10, 24, 3, 25, 3, 25, 3, 25, 7,
	25, 559, 10, 25, 12, 25, 14, 25, 562, 11, 25, 3, 25, 3, 25, 5, 25, 566,
	10, 25, 3, 26, 3, 26, 3, 26, 6, 26, 571, 10, 26, 13, 26, 14, 26, 572, 3,
	26, 3, 26, 3, 26, 3, 27, 5, 27, 579, 10, 27, 3, 27, 5, 27, 582, 10, 27,
	3, 27, 3, 27, 3, 27, 5, 27, 587, 10, 27, 3, 27, 3, 27, 3, 27, 5, 27, 592,
	10, 27, 3, 27, 3, 27, 3, 27, 5, 27, 597, 10, 27, 3, 27, 3, 27, 7, 27, 601,
	10, 27, 12, 27, 14, 27, 604, 11, 27, 3, 27, 3, 27, 3, 27, 3, 28, 3, 28,
	3, 28, 3, 28, 5, 28, 613, 10, 28, 3, 29, 3, 29, 3, 29, 3, 29, 5, 29, 619,
	10, 29, 3, 29, 5, 29, 622, 10, 29, 3, 29, 3, 29, 5, 29, 626, 10, 29, 3,
	29, 5, 29, 629, 10, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 3, 29, 5, 29,
	637, 10, 29, 3, 29, 3, 29, 5, 29, 641, 10, 29, 3, 30, 3, 30, 3, 31, 3,
	31, 3, 31, 5, 31, 648, 10, 31, 3, 31, 3, 31, 3, 31, 5, 31, 653, 10, 31,
	3, 31, 3, 31, 3, 31, 5, 31, 658, 10, 31, 3, 31, 3, 31, 5, 31, 662, 10,
	31, 3, 31, 5, 31, 665, 10, 31, 3, 31, 3, 31, 7, 31, 669, 10, 31, 12, 31,
	14, 31, 672, 11, 31, 3, 31, 3, 31, 3, 31, 3, 32, 3, 32, 3, 33, 3, 33, 3,
	33, 3, 34, 3, 34, 3, 35, 3, 35, 3, 36, 3, 36, 5, 36, 688, 10, 36, 3, 37,
	5, 37, 691, 10, 37, 3, 37, 3, 37, 3, 37, 3, 37, 5, 37, 697, 10, 37, 3,
	37, 7, 37, 700, 10, 37, 12, 37, 14, 37, 703, 11, 37, 3, 38, 3, 38, 3, 39,
	3, 39, 3, 39, 7, 39, 710, 10, 39, 12, 39, 14, 39, 713, 11, 39, 3, 40, 3,
	40, 3, 40, 7, 40, 718, 10, 40, 12, 40, 14, 40, 721, 11, 40, 3, 41, 5, 41,
	724, 10, 41, 3, 41, 3, 41, 3, 42, 3, 42, 3, 42, 5, 42, 731, 10, 42, 3,
	43, 3, 43, 3, 43, 7, 43, 736, 10, 43, 12, 43, 14, 43, 739, 11, 43, 3, 44,
	3, 44, 3, 44, 7, 44, 744, 10, 44, 12, 44, 14, 44, 747, 11, 44, 3, 45, 3,
	45, 3, 45, 3, 45, 3, 45, 5, 45, 754, 10, 45, 3, 45, 5, 45, 757, 10, 45,
	3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3,
	46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46,
	3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 3, 46, 5, 46, 788, 10,
	46, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47, 3, 47,
	3, 47, 3, 47, 5, 47, 802, 10, 47, 3, 48, 3, 48, 3, 48, 3, 48, 3, 48, 3,
	48, 5, 48, 810, 10, 48, 3, 49, 3, 49, 5, 49, 814, 10, 49, 3, 50, 3, 50,
	3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 3, 50, 5, 50, 824, 10, 50, 3, 51, 3,
	51, 5, 51, 828, 10, 51, 3, 52, 3, 52, 3, 53, 3, 53, 3, 53, 3, 53, 3, 53,
	5, 53, 837, 10, 53, 3, 54, 3, 54, 3, 54, 3, 54, 5, 54, 843, 10, 54, 3,
	54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 3, 54, 5, 54, 853, 10, 54,
	3, 55, 3, 55, 3, 55, 3, 55, 3, 55, 3, 56, 3, 56, 3, 56, 3, 56, 3, 56, 3,
	56, 3, 56, 5, 56, 867, 10, 56, 3, 57, 3, 57, 3, 57, 3, 57, 5, 57, 873,
	10, 57, 3, 58, 3, 58, 3, 58, 3, 58, 5, 58, 879, 10, 58, 3, 58, 3, 58, 5,
	58, 883, 10, 58, 3, 59, 3, 59, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 5, 60,
	892, 10, 60, 3, 60, 3, 60, 5, 60, 896, 10, 60, 3, 60, 3, 60, 3, 60, 3,
	61, 3, 61, 3, 62, 3, 62, 5, 62, 905, 10, 62, 3, 62, 3, 62, 3, 62, 5, 62,
	910, 10, 62, 3, 62, 3, 62, 3, 62, 5, 62, 915, 10, 62, 3, 62, 5, 62, 918,
	10, 62, 3, 63, 3, 63, 3, 64, 3, 64, 3, 64, 3, 65, 3, 65, 3, 66, 3, 66,
	3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 3, 66, 5, 66, 935, 10, 66, 3, 66, 3,
	66, 3, 66, 3, 67, 3, 67, 3, 67, 3, 67, 7, 67, 944, 10, 67, 12, 67, 14,
	67, 947, 11, 67, 3, 67, 3, 67, 3, 68, 3, 68, 7, 68, 953, 10, 68, 12, 68,
	14, 68, 956, 11, 68, 3, 68, 3, 68, 3, 68, 3, 68, 3, 69, 3, 69, 3, 69, 3,
	69, 7, 69, 966, 10, 69, 12, 69, 14, 69, 969, 11, 69, 3, 69, 3, 69, 3, 69,
	3, 69, 7, 69, 975, 10, 69, 12, 69, 14, 69, 978, 11, 69, 7, 69, 980, 10,
	69, 12, 69, 14, 69, 983, 11, 69, 3, 69, 3, 69, 7, 69, 987, 10, 69, 12,
	69, 14, 69, 990, 11, 69, 5, 69, 992, 10, 69, 3, 69, 3, 69, 3, 69, 3, 69,
	5, 69, 998, 10, 69, 3, 70, 3, 70, 3, 70, 3, 70, 3, 70, 3, 71, 3, 71, 3,
	72, 3, 72, 3, 73, 3, 73, 3, 73, 5, 73, 1012, 10, 73, 3, 73, 3, 73, 5, 73,
	1016, 10, 73, 3, 73, 3, 73, 3, 73, 5, 73, 1021, 10, 73, 3, 73, 3, 73, 3,
	74, 3, 74, 3, 75, 3, 75, 3, 76, 3, 76, 3, 77, 3, 77, 3, 77, 3, 77, 3, 77,
	3, 77, 3, 77, 6, 77, 1038, 10, 77, 13, 77, 14, 77, 1039, 3, 77, 3, 77,
	3, 77, 3, 78, 3, 78, 3, 78, 3, 78, 7, 78, 1049, 10, 78, 12, 78, 14, 78,
	1052, 11, 78, 3, 78, 7, 78, 1055, 10, 78, 12, 78, 14, 78, 1058, 11, 78,
	3, 79, 3, 79, 3, 79, 3, 79, 3, 79, 7, 79, 1065, 10, 79, 12, 79, 14, 79,
	1068, 11, 79, 3, 80, 3, 80, 3, 80, 3, 80, 3, 80, 7, 80, 1075, 10, 80, 12,
	80, 14, 80, 1078, 11, 80, 3, 81, 3, 81, 3, 81, 7, 81, 1083, 10, 81, 12,
	81, 14, 81, 1086, 11, 81, 3, 82, 3, 82, 3, 82, 3, 83, 3, 83, 3, 84, 3,
	84, 3, 84, 3, 85, 3, 85, 7, 85, 1098, 10, 85, 12, 85, 14, 85, 1101, 11,
	85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 7, 85, 1108, 10, 85, 12, 85, 14,
	85, 1111, 11, 85, 7, 85, 1113, 10, 85, 12, 85, 14, 85, 1116, 11, 85, 3,
	85, 3, 85, 7, 85, 1120, 10, 85, 12, 85, 14, 85, 1123, 11, 85, 5, 85, 1125,
	10, 85, 3, 85, 3, 85, 3, 85, 3, 86, 3, 86, 3, 86, 3, 87, 3, 87, 3, 88,
	3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 5, 88, 1141, 10, 88, 3, 88, 3, 88, 3,
	88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 3, 88, 5, 88,
	1155, 10, 88, 3, 89, 3, 89, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 3,
	90, 3, 90, 3, 90, 3, 90, 3, 90, 3, 90, 5, 90, 1171, 10, 90, 3, 91, 3, 91,
	3, 91, 3, 91, 5, 91, 1177, 10, 91, 3, 91, 3, 91, 3, 91, 5, 91, 1182, 10,
	91, 3, 92, 3, 92, 5, 92, 1186, 10, 92, 3, 92, 3, 92, 5, 92, 1190, 10, 92,
	3, 92, 3, 92, 3, 93, 3, 93, 3, 93, 3, 93, 3, 93, 3, 94, 3, 94, 3, 94, 3,
	95, 3, 95, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96,
	3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 3, 96, 5, 96, 1221, 10,
	96, 3, 97, 3, 97, 3, 97, 3, 97, 3, 97, 3, 98, 3, 98, 3, 99, 3, 99, 3, 100,
	3, 100, 3, 100, 3, 100, 3, 100, 7, 100, 1237, 10, 100, 12, 100, 14, 100,
	1240, 11, 100, 3, 100, 3, 100, 3, 101, 3, 101, 3, 102, 3, 102, 5, 102,
	1248, 10, 102, 3, 102, 2, 2, 103, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22,
	24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58,
	60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94,
	96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124,
	126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154,
	156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184,
	186, 188, 190, 192, 194, 196, 198, 200, 202, 2, 16, 3, 2, 5, 6, 3, 2, 85,
	86, 3, 2, 103, 104, 4, 2, 10, 10, 17, 17, 3, 2, 13, 14, 4, 2, 11, 12, 28,
	28, 4, 2, 11, 12, 27, 31, 4, 2, 5, 5, 32, 32, 3, 2, 79, 84, 4, 2, 90, 91,
	94, 94, 5, 2, 79, 79, 87, 88, 92, 93, 4, 2, 46, 46, 51, 51, 3, 2, 60, 61,
	3, 2, 57, 58, 2, 1409, 2, 205, 3, 2, 2, 2, 4, 217, 3, 2, 2, 2, 6, 241,
	3, 2, 2, 2, 8, 243, 3, 2, 2, 2, 10, 245, 3, 2, 2, 2, 12, 250, 3, 2, 2,
	2, 14, 254, 3, 2, 2, 2, 16, 265, 3, 2, 2, 2, 18, 294, 3, 2, 2, 2, 20, 299,
	3, 2, 2, 2, 22, 377, 3, 2, 2, 2, 24, 379, 3, 2, 2, 2, 26, 390, 3, 2, 2,
	2, 28, 424, 3, 2, 2, 2, 30, 437, 3, 2, 2, 2, 32, 450, 3, 2, 2, 2, 34, 458,
	3, 2, 2, 2, 36, 461, 3, 2, 2, 2, 38, 498, 3, 2, 2, 2, 40, 500, 3, 2, 2,
	2, 42, 502, 3, 2, 2, 2, 44, 506, 3, 2, 2, 2, 46, 542, 3, 2, 2, 2, 48, 555,
	3, 2, 2, 2, 50, 567, 3, 2, 2, 2, 52, 578, 3, 2, 2, 2, 54, 608, 3, 2, 2,
	2, 56, 640, 3, 2, 2, 2, 58, 642, 3, 2, 2, 2, 60, 644, 3, 2, 2, 2, 62, 676,
	3, 2, 2, 2, 64, 678, 3, 2, 2, 2, 66, 681, 3, 2, 2, 2, 68, 683, 3, 2, 2,
	2, 70, 687, 3, 2, 2, 2, 72, 690, 3, 2, 2, 2, 74, 704, 3, 2, 2, 2, 76, 706,
	3, 2, 2, 2, 78, 714, 3, 2, 2, 2, 80, 723, 3, 2, 2, 2, 82, 727, 3, 2, 2,
	2, 84, 732, 3, 2, 2, 2, 86, 740, 3, 2, 2, 2, 88, 756, 3, 2, 2, 2, 90, 787,
	3, 2, 2, 2, 92, 801, 3, 2, 2, 2, 94, 803, 3, 2, 2, 2, 96, 811, 3, 2, 2,
	2, 98, 823, 3, 2, 2, 2, 100, 825, 3, 2, 2, 2, 102, 829, 3, 2, 2, 2, 104,
	836, 3, 2, 2, 2, 106, 852, 3, 2, 2, 2, 108, 854, 3, 2, 2, 2, 110, 866,
	3, 2, 2, 2, 112, 872, 3, 2, 2, 2, 114, 874, 3, 2, 2, 2, 116, 884, 3, 2,
	2, 2, 118, 895, 3, 2, 2, 2, 120, 900, 3, 2, 2, 2, 122, 902, 3, 2, 2, 2,
	124, 919, 3, 2, 2, 2, 126, 921, 3, 2, 2, 2, 128, 924, 3, 2, 2, 2, 130,
	926, 3, 2, 2, 2, 132, 939, 3, 2, 2, 2, 134, 950, 3, 2, 2, 2, 136, 961,
	3, 2, 2, 2, 138, 999, 3, 2, 2, 2, 140, 1004, 3, 2, 2, 2, 142, 1006, 3,
	2, 2, 2, 144, 1011, 3, 2, 2, 2, 146, 1024, 3, 2, 2, 2, 148, 1026, 3, 2,
	2, 2, 150, 1028, 3, 2, 2, 2, 152, 1030, 3, 2, 2, 2, 154, 1044, 3, 2, 2,
	2, 156, 1059, 3, 2, 2, 2, 158, 1069, 3, 2, 2, 2, 160, 1079, 3, 2, 2, 2,
	162, 1087, 3, 2, 2, 2, 164, 1090, 3, 2, 2, 2, 166, 1092, 3, 2, 2, 2, 168,
	1095, 3, 2, 2, 2, 170, 1129, 3, 2, 2, 2, 172, 1132, 3, 2, 2, 2, 174, 1154,
	3, 2, 2, 2, 176, 1156, 3, 2, 2, 2, 178, 1170, 3, 2, 2, 2, 180, 1181, 3,
	2, 2, 2, 182, 1185, 3, 2, 2, 2, 184, 1193, 3, 2, 2, 2, 186, 1198, 3, 2,
	2, 2, 188, 1201, 3, 2, 2, 2, 190, 1220, 3, 2, 2, 2, 192, 1222, 3, 2, 2,
	2, 194, 1227, 3, 2, 2, 2, 196, 1229, 3, 2, 2, 2, 198, 1231, 3, 2, 2, 2,
	200, 1243, 3, 2, 2, 2, 202, 1247, 3, 2, 2, 2, 204, 206, 5, 4, 3, 2, 205,
	204, 3, 2, 2, 2, 205, 206, 3, 2, 2, 2, 206, 208, 3, 2, 2, 2, 207, 209,
	5, 6, 4, 2, 208, 207, 3, 2, 2, 2, 209, 210, 3, 2, 2, 2, 210, 208, 3, 2,
	2, 2, 210, 211, 3, 2, 2, 2, 211, 212, 3, 2, 2, 2, 212, 213, 7, 2, 2, 3,
	213, 3, 3, 2, 2, 2, 214, 216, 5, 8, 5, 2, 215, 214, 3, 2, 2, 2, 216, 219,
	3, 2, 2, 2, 217, 215, 3, 2, 2, 2, 217, 218, 3, 2, 2, 2, 218, 221, 3, 2,
	2, 2, 219, 217, 3, 2, 2, 2, 220, 222, 5, 10, 6, 2, 221, 220, 3, 2, 2, 2,
	221, 222, 3, 2, 2, 2, 222, 226, 3, 2, 2, 2, 223, 225, 5, 12, 7, 2, 224,
	223, 3, 2, 2, 2, 225, 228, 3, 2, 2, 2, 226, 224, 3, 2, 2, 2, 226, 227,
	3, 2, 2, 2, 227, 5, 3, 2, 2, 2, 228, 226, 3, 2, 2, 2, 229, 242, 5, 26,
	14, 2, 230, 242, 5, 64, 33, 2, 231, 242, 5, 24, 13, 2, 232, 242, 5, 28,
	15, 2, 233, 242, 5, 30, 16, 2, 234, 242, 5, 34, 18, 2, 235, 242, 5, 42,
	22, 2, 236, 242, 5, 44, 23, 2, 237, 242, 5, 50, 26, 2, 238, 242, 5, 52,
	27, 2, 239, 242, 5, 54, 28, 2, 240, 242, 5, 60, 31, 2, 241, 229, 3, 2,
	2, 2, 241, 230, 3, 2, 2, 2, 241, 231, 3, 2, 2, 2, 241, 232, 3, 2, 2, 2,
	241, 233, 3, 2, 2, 2, 241, 234, 3, 2, 2, 2, 241, 235, 3, 2, 2, 2, 241,
	236, 3, 2, 2, 2, 241, 237, 3, 2, 2, 2, 241, 238, 3, 2, 2, 2, 241, 239,
	3, 2, 2, 2, 241, 240, 3, 2, 2, 2, 242, 7, 3, 2, 2, 2, 243, 244, 7, 122,
	2, 2, 244, 9, 3, 2, 2, 2, 245, 246, 7, 56, 2, 2, 246, 247, 7, 112, 2, 2,
	247, 248, 7, 108, 2, 2, 248, 11, 3, 2, 2, 2, 249, 251, 5, 14, 8, 2, 250,
	249, 3, 2, 2, 2, 251, 252, 3, 2, 2, 2, 252, 250, 3, 2, 2, 2, 252, 253,
	3, 2, 2, 2, 253, 13, 3, 2, 2, 2, 254, 256, 5, 20, 11, 2, 255, 257, 5, 38,
	20, 2, 256, 255, 3, 2, 2, 2, 256, 257, 3, 2, 2, 2, 257, 258, 3, 2, 2, 2,
	258, 260, 7, 109, 2, 2, 259, 261, 5, 16, 9, 2, 260, 259, 3, 2, 2, 2, 260,
	261, 3, 2, 2, 2, 261, 262, 3, 2, 2, 2, 262, 263, 7, 110, 2, 2, 263, 15,
	3, 2, 2, 2, 264, 266, 5, 18, 10, 2, 265, 264, 3, 2, 2, 2, 266, 267, 3,
	2, 2, 2, 267, 265, 3, 2, 2, 2, 267, 268, 3, 2, 2, 2, 268, 17, 3, 2, 2,
	2, 269, 275, 7, 22, 2, 2, 270, 275, 5, 194, 98, 2, 271, 275, 7, 103, 2,
	2, 272, 275, 7, 115, 2, 2, 273, 275, 7, 116, 2, 2, 274, 269, 3, 2, 2, 2,
	274, 270, 3, 2, 2, 2, 274, 271, 3, 2, 2, 2, 274, 272, 3, 2, 2, 2, 274,
	273, 3, 2, 2, 2, 275, 277, 3, 2, 2, 2, 276, 278, 7, 106, 2, 2, 277, 276,
	3, 2, 2, 2, 277, 278, 3, 2, 2, 2, 278, 295, 3, 2, 2, 2, 279, 280, 5, 20,
	11, 2, 280, 289, 7, 79, 2, 2, 281, 283, 5, 22, 12, 2, 282, 284, 5, 38,
	20, 2, 283, 282, 3, 2, 2, 2, 283, 284, 3, 2, 2, 2, 284, 290, 3, 2, 2, 2,
	285, 286, 7, 109, 2, 2, 286, 287, 5, 16, 9, 2, 287, 288, 7, 110, 2, 2,
	288, 290, 3, 2, 2, 2, 289, 281, 3, 2, 2, 2, 289, 285, 3, 2, 2, 2, 290,
	292, 3, 2, 2, 2, 291, 293, 7, 106, 2, 2, 292, 291, 3, 2, 2, 2, 292, 293,
	3, 2, 2, 2, 293, 295, 3, 2, 2, 2, 294, 274, 3, 2, 2, 2, 294, 279, 3, 2,
	2, 2, 295, 19, 3, 2, 2, 2, 296, 300, 5, 176, 89, 2, 297, 300, 7, 17, 2,
	2, 298, 300, 7, 23, 2, 2, 299, 296, 3, 2, 2, 2, 299, 297, 3, 2, 2, 2, 299,
	298, 3, 2, 2, 2, 300, 302, 3, 2, 2, 2, 301, 303, 7, 112, 2, 2, 302, 301,
	3, 2, 2, 2, 302, 303, 3, 2, 2, 2, 303, 314, 3, 2, 2, 2, 304, 310, 7, 113,
	2, 2, 305, 311, 5, 176, 89, 2, 306, 311, 7, 24, 2, 2, 307, 311, 7, 17,
	2, 2, 308, 311, 7, 18, 2, 2, 309, 311, 7, 25, 2, 2, 310, 305, 3, 2, 2,
	2, 310, 306, 3, 2, 2, 2, 310, 307, 3, 2, 2, 2, 310, 308, 3, 2, 2, 2, 310,
	309, 3, 2, 2, 2, 311, 313, 3, 2, 2, 2, 312, 304, 3, 2, 2, 2, 313, 316,
	3, 2, 2, 2, 314, 312, 3, 2, 2, 2, 314, 315, 3, 2, 2, 2, 315, 21, 3, 2,
	2, 2, 316, 314, 3, 2, 2, 2, 317, 378, 5, 182, 92, 2, 318, 378, 5, 188,
	95, 2, 319, 321, 7, 86, 2, 2, 320, 319, 3, 2, 2, 2, 320, 321, 3, 2, 2,
	2, 321, 322, 3, 2, 2, 2, 322, 378, 5, 194, 98, 2, 323, 378, 5, 196, 99,
	2, 324, 378, 7, 105, 2, 2, 325, 378, 7, 103, 2, 2, 326, 378, 7, 104, 2,
	2, 327, 378, 7, 115, 2, 2, 328, 378, 7, 116, 2, 2, 329, 378, 7, 17, 2,
	2, 330, 378, 7, 19, 2, 2, 331, 378, 7, 20, 2, 2, 332, 378, 7, 21, 2, 2,
	333, 378, 7, 22, 2, 2, 334, 378, 7, 34, 2, 2, 335, 336, 7, 109, 2, 2, 336,
	339, 7, 109, 2, 2, 337, 340, 5, 70, 36, 2, 338, 340, 5, 200, 101, 2, 339,
	337, 3, 2, 2, 2, 339, 338, 3, 2, 2, 2, 340, 346, 3, 2, 2, 2, 341, 344,
	7, 106, 2, 2, 342, 345, 5, 70, 36, 2, 343, 345, 5, 200, 101, 2, 344, 342,
	3, 2, 2, 2, 344, 343, 3, 2, 2, 2, 345, 347, 3, 2, 2, 2, 346, 341, 3, 2,
	2, 2, 346, 347, 3, 2, 2, 2, 347, 348, 3, 2, 2, 2, 348, 366, 7, 110, 2,
	2, 349, 350, 7, 106, 2, 2, 350, 353, 7, 109, 2, 2, 351, 354, 5, 70, 36,
	2, 352, 354, 5, 200, 101, 2, 353, 351, 3, 2, 2, 2, 353, 352, 3, 2, 2, 2,
	354, 360, 3, 2, 2, 2, 355, 358, 7, 106, 2, 2, 356, 359, 5, 70, 36, 2, 357,
	359, 5, 200, 101, 2, 358, 356, 3, 2, 2, 2, 358, 357, 3, 2, 2, 2, 359, 361,
	3, 2, 2, 2, 360, 355, 3, 2, 2, 2, 360, 361, 3, 2, 2, 2, 361, 362, 3, 2,
	2, 2, 362, 363, 7, 110, 2, 2, 363, 365, 3, 2, 2, 2, 364, 349, 3, 2, 2,
	2, 365, 368, 3, 2, 2, 2, 366, 364, 3, 2, 2, 2, 366, 367, 3, 2, 2, 2, 367,
	369, 3, 2, 2, 2, 368, 366, 3, 2, 2, 2, 369, 370, 7, 110, 2, 2, 370, 378,
	3, 2, 2, 2, 371, 375, 5, 200, 101, 2, 372, 373, 7, 109, 2, 2, 373, 374,
	7, 112, 2, 2, 374, 376, 7, 110, 2, 2, 375, 372, 3, 2, 2, 2, 375, 376, 3,
	2, 2, 2, 376, 378, 3, 2, 2, 2, 377, 317, 3, 2, 2, 2, 377, 318, 3, 2, 2,
	2, 377, 320, 3, 2, 2, 2, 377, 323, 3, 2, 2, 2, 377, 324, 3, 2, 2, 2, 377,
	325, 3, 2, 2, 2, 377, 326, 3, 2, 2, 2, 377, 327, 3, 2, 2, 2, 377, 328,
	3, 2, 2, 2, 377, 329, 3, 2, 2, 2, 377, 330, 3, 2, 2, 2, 377, 331, 3, 2,
	2, 2, 377, 332, 3, 2, 2, 2, 377, 333, 3, 2, 2, 2, 377, 334, 3, 2, 2, 2,
	377, 335, 3, 2, 2, 2, 377, 371, 3, 2, 2, 2, 378, 23, 3, 2, 2, 2, 379, 382,
	7, 10, 2, 2, 380, 383, 5, 26, 14, 2, 381, 383, 5, 34, 18, 2, 382, 380,
	3, 2, 2, 2, 382, 381, 3, 2, 2, 2, 383, 384, 3, 2, 2, 2, 384, 382, 3, 2,
	2, 2, 384, 385, 3, 2, 2, 2, 385, 386, 3, 2, 2, 2, 386, 387, 7, 7, 2, 2,
	387, 388, 7, 10, 2, 2, 388, 25, 3, 2, 2, 2, 389, 391, 5, 68, 35, 2, 390,
	389, 3, 2, 2, 2, 390, 391, 3, 2, 2, 2, 391, 392, 3, 2, 2, 2, 392, 393,
	7, 17, 2, 2, 393, 394, 5, 176, 89, 2, 394, 398, 7, 20, 2, 2, 395, 396,
	5, 176, 89, 2, 396, 397, 7, 100, 2, 2, 397, 399, 3, 2, 2, 2, 398, 395,
	3, 2, 2, 2, 398, 399, 3, 2, 2, 2, 399, 400, 3, 2, 2, 2, 400, 403, 5, 202,
	102, 2, 401, 402, 7, 26, 2, 2, 402, 404, 5, 176, 89, 2, 403, 401, 3, 2,
	2, 2, 403, 404, 3, 2, 2, 2, 404, 406, 3, 2, 2, 2, 405, 407, 7, 101, 2,
	2, 406, 405, 3, 2, 2, 2, 406, 407, 3, 2, 2, 2, 407, 412, 3, 2, 2, 2, 408,
	409, 7, 102, 2, 2, 409, 410, 7, 103, 2, 2, 410, 411, 7, 79, 2, 2, 411,
	413, 7, 103, 2, 2, 412, 408, 3, 2, 2, 2, 412, 413, 3, 2, 2, 2, 413, 418,
	3, 2, 2, 2, 414, 417, 5, 34, 18, 2, 415, 417, 5, 58, 30, 2, 416, 414, 3,
	2, 2, 2, 416, 415, 3, 2, 2, 2, 417, 420, 3, 2, 2, 2, 418, 416, 3, 2, 2,
	2, 418, 419, 3, 2, 2, 2, 419, 421, 3, 2, 2, 2, 420, 418, 3, 2, 2, 2, 421,
	422, 7, 7, 2, 2, 422, 423, 7, 17, 2, 2, 423, 27, 3, 2, 2, 2, 424, 425,
	7, 17, 2, 2, 425, 431, 7, 9, 2, 2, 426, 430, 5, 64, 33, 2, 427, 430, 5,
	34, 18, 2, 428, 430, 5, 42, 22, 2, 429, 426, 3, 2, 2, 2, 429, 427, 3, 2,
	2, 2, 429, 428, 3, 2, 2, 2, 430, 433, 3, 2, 2, 2, 431, 429, 3, 2, 2, 2,
	431, 432, 3, 2, 2, 2, 432, 434, 3, 2, 2, 2, 433, 431, 3, 2, 2, 2, 434,
	435, 7, 7, 2, 2, 435, 436, 7, 9, 2, 2, 436, 29, 3, 2, 2, 2, 437, 438, 9,
	2, 2, 2, 438, 443, 7, 9, 2, 2, 439, 442, 5, 34, 18, 2, 440, 442, 5, 42,
	22, 2, 441, 439, 3, 2, 2, 2, 441, 440, 3, 2, 2, 2, 442, 445, 3, 2, 2, 2,
	443, 441, 3, 2, 2, 2, 443, 444, 3, 2, 2, 2, 444, 446, 3, 2, 2, 2, 445,
	443, 3, 2, 2, 2, 446, 447, 7, 7, 2, 2, 447, 448, 7, 9, 2, 2, 448, 31, 3,
	2, 2, 2, 449, 451, 7, 8, 2, 2, 450, 449, 3, 2, 2, 2, 450, 451, 3, 2, 2,
	2, 451, 453, 3, 2, 2, 2, 452, 454, 5, 66, 34, 2, 453, 452, 3, 2, 2, 2,
	453, 454, 3, 2, 2, 2, 454, 456, 3, 2, 2, 2, 455, 457, 5, 68, 35, 2, 456,
	455, 3, 2, 2, 2, 456, 457, 3, 2, 2, 2, 457, 33, 3, 2, 2, 2, 458, 459, 5,
	32, 17, 2, 459, 460, 7, 108, 2, 2, 460, 35, 3, 2, 2, 2, 461, 462, 7, 95,
	2, 2, 462, 463, 7, 112, 2, 2, 463, 464, 7, 96, 2, 2, 464, 37, 3, 2, 2,
	2, 465, 499, 7, 99, 2, 2, 466, 495, 7, 97, 2, 2, 467, 469, 9, 3, 2, 2,
	468, 467, 3, 2, 2, 2, 468, 469, 3, 2, 2, 2, 469, 470, 3, 2, 2, 2, 470,
	476, 7, 112, 2, 2, 471, 473, 7, 19, 2, 2, 472, 474, 9, 3, 2, 2, 473, 472,
	3, 2, 2, 2, 473, 474, 3, 2, 2, 2, 474, 475, 3, 2, 2, 2, 475, 477, 7, 112,
	2, 2, 476, 471, 3, 2, 2, 2, 476, 477, 3, 2, 2, 2, 477, 492, 3, 2, 2, 2,
	478, 480, 7, 106, 2, 2, 479, 481, 9, 3, 2, 2, 480, 479, 3, 2, 2, 2, 480,
	481, 3, 2, 2, 2, 481, 482, 3, 2, 2, 2, 482, 488, 7, 112, 2, 2, 483, 485,
	7, 19, 2, 2, 484, 486, 9, 3, 2, 2, 485, 484, 3, 2, 2, 2, 485, 486, 3, 2,
	2, 2, 486, 487, 3, 2, 2, 2, 487, 489, 7, 112, 2, 2, 488, 483, 3, 2, 2,
	2, 488, 489, 3, 2, 2, 2, 489, 491, 3, 2, 2, 2, 490, 478, 3, 2, 2, 2, 491,
	494, 3, 2, 2, 2, 492, 490, 3, 2, 2, 2, 492, 493, 3, 2, 2, 2, 493, 496,
	3, 2, 2, 2, 494, 492, 3, 2, 2, 2, 495, 468, 3, 2, 2, 2, 495, 496, 3, 2,
	2, 2, 496, 497, 3, 2, 2, 2, 497, 499, 7, 98, 2, 2, 498, 465, 3, 2, 2, 2,
	498, 466, 3, 2, 2, 2, 499, 39, 3, 2, 2, 2, 500, 501, 3, 2, 2, 2, 501, 41,
	3, 2, 2, 2, 502, 503, 5, 40, 21, 2, 503, 504, 7, 108, 2, 2, 504, 43, 3,
	2, 2, 2, 505, 507, 5, 66, 34, 2, 506, 505, 3, 2, 2, 2, 506, 507, 3, 2,
	2, 2, 507, 509, 3, 2, 2, 2, 508, 510, 5, 68, 35, 2, 509, 508, 3, 2, 2,
	2, 509, 510, 3, 2, 2, 2, 510, 514, 3, 2, 2, 2, 511, 512, 7, 13, 2, 2, 512,
	515, 5, 202, 102, 2, 513, 515, 7, 14, 2, 2, 514, 511, 3, 2, 2, 2, 514,
	513, 3, 2, 2, 2, 515, 516, 3, 2, 2, 2, 516, 517, 5, 176, 89, 2, 517, 519,
	7, 109, 2, 2, 518, 520, 5, 48, 25, 2, 519, 518, 3, 2, 2, 2, 519, 520, 3,
	2, 2, 2, 520, 521, 3, 2, 2, 2, 521, 529, 7, 110, 2, 2, 522, 523, 7, 74,
	2, 2, 523, 527, 9, 4, 2, 2, 524, 525, 7, 77, 2, 2, 525, 526, 7, 47, 2,
	2, 526, 528, 9, 4, 2, 2, 527, 524, 3, 2, 2, 2, 527, 528, 3, 2, 2, 2, 528,
	530, 3, 2, 2, 2, 529, 522, 3, 2, 2, 2, 529, 530, 3, 2, 2, 2, 530, 535,
	3, 2, 2, 2, 531, 532, 7, 76, 2, 2, 532, 533, 7, 77, 2, 2, 533, 534, 7,
	47, 2, 2, 534, 536, 9, 4, 2, 2, 535, 531, 3, 2, 2, 2, 535, 536, 3, 2, 2,
	2, 536, 539, 3, 2, 2, 2, 537, 538, 7, 78, 2, 2, 538, 540, 5, 176, 89, 2,
	539, 537, 3, 2, 2, 2, 539, 540, 3, 2, 2, 2, 540, 45, 3, 2, 2, 2, 541, 543,
	7, 15, 2, 2, 542, 541, 3, 2, 2, 2, 542, 543, 3, 2, 2, 2, 543, 545, 3, 2,
	2, 2, 544, 546, 7, 21, 2, 2, 545, 544, 3, 2, 2, 2, 545, 546, 3, 2, 2, 2,
	546, 547, 3, 2, 2, 2, 547, 549, 5, 202, 102, 2, 548, 550, 5, 36, 19, 2,
	549, 548, 3, 2, 2, 2, 549, 550, 3, 2, 2, 2, 550, 551, 3, 2, 2, 2, 551,
	553, 5, 176, 89, 2, 552, 554, 5, 38, 20, 2, 553, 552, 3, 2, 2, 2, 553,
	554, 3, 2, 2, 2, 554, 47, 3, 2, 2, 2, 555, 560, 5, 46, 24, 2, 556, 557,
	7, 106, 2, 2, 557, 559, 5, 46, 24, 2, 558, 556, 3, 2, 2, 2, 559, 562, 3,
	2, 2, 2, 560, 558, 3, 2, 2, 2, 560, 561, 3, 2, 2, 2, 561, 565, 3, 2, 2,
	2, 562, 560, 3, 2, 2, 2, 563, 564, 7, 106, 2, 2, 564, 566, 7, 121, 2, 2,
	565, 563, 3, 2, 2, 2, 565, 566, 3, 2, 2, 2, 566, 49, 3, 2, 2, 2, 567, 568,
	9, 5, 2, 2, 568, 570, 7, 16, 2, 2, 569, 571, 5, 44, 23, 2, 570, 569, 3,
	2, 2, 2, 571, 572, 3, 2, 2, 2, 572, 570, 3, 2, 2, 2, 572, 573, 3, 2, 2,
	2, 573, 574, 3, 2, 2, 2, 574, 575, 7, 7, 2, 2, 575, 576, 7, 16, 2, 2, 576,
	51, 3, 2, 2, 2, 577, 579, 5, 62, 32, 2, 578, 577, 3, 2, 2, 2, 578, 579,
	3, 2, 2, 2, 579, 581, 3, 2, 2, 2, 580, 582, 5, 68, 35, 2, 581, 580, 3,
	2, 2, 2, 581, 582, 3, 2, 2, 2, 582, 586, 3, 2, 2, 2, 583, 584, 7, 13, 2,
	2, 584, 587, 5, 202, 102, 2, 585, 587, 7, 14, 2, 2, 586, 583, 3, 2, 2,
	2, 586, 585, 3, 2, 2, 2, 587, 588, 3, 2, 2, 2, 588, 589, 5, 176, 89, 2,
	589, 591, 7, 109, 2, 2, 590, 592, 5, 48, 25, 2, 591, 590, 3, 2, 2, 2, 591,
	592, 3, 2, 2, 2, 592, 593, 3, 2, 2, 2, 593, 596, 7, 110, 2, 2, 594, 595,
	7, 78, 2, 2, 595, 597, 5, 176, 89, 2, 596, 594, 3, 2, 2, 2, 596, 597, 3,
	2, 2, 2, 597, 602, 3, 2, 2, 2, 598, 599, 7, 108, 2, 2, 599, 601, 5, 90,
	46, 2, 600, 598, 3, 2, 2, 2, 601, 604, 3, 2, 2, 2, 602, 600, 3, 2, 2, 2,
	602, 603, 3, 2, 2, 2, 603, 605, 3, 2, 2, 2, 604, 602, 3, 2, 2, 2, 605,
	606, 7, 7, 2, 2, 606, 607, 9, 6, 2, 2, 607, 53, 3, 2, 2, 2, 608, 612, 7,
	18, 2, 2, 609, 613, 5, 174, 88, 2, 610, 613, 7, 34, 2, 2, 611, 613, 7,
	48, 2, 2, 612, 609, 3, 2, 2, 2, 612, 610, 3, 2, 2, 2, 612, 611, 3, 2, 2,
	2, 613, 55, 3, 2, 2, 2, 614, 618, 7, 33, 2, 2, 615, 619, 5, 176, 89, 2,
	616, 619, 7, 57, 2, 2, 617, 619, 7, 58, 2, 2, 618, 615, 3, 2, 2, 2, 618,
	616, 3, 2, 2, 2, 618, 617, 3, 2, 2, 2, 619, 621, 3, 2, 2, 2, 620, 622,
	5, 176, 89, 2, 621, 620, 3, 2, 2, 2, 621, 622, 3, 2, 2, 2, 622, 628, 3,
	2, 2, 2, 623, 625, 7, 109, 2, 2, 624, 626, 5, 48, 25, 2, 625, 624, 3, 2,
	2, 2, 625, 626, 3, 2, 2, 2, 626, 627, 3, 2, 2, 2, 627, 629, 7, 110, 2,
	2, 628, 623, 3, 2, 2, 2, 628, 629, 3, 2, 2, 2, 629, 641, 3, 2, 2, 2, 630,
	631, 7, 33, 2, 2, 631, 632, 7, 17, 2, 2, 632, 633, 5, 202, 102, 2, 633,
	634, 5, 176, 89, 2, 634, 636, 7, 109, 2, 2, 635, 637, 5, 48, 25, 2, 636,
	635, 3, 2, 2, 2, 636, 637, 3, 2, 2, 2, 637, 638, 3, 2, 2, 2, 638, 639,
	7, 110, 2, 2, 639, 641, 3, 2, 2, 2, 640, 614, 3, 2, 2, 2, 640, 630, 3,
	2, 2, 2, 641, 57, 3, 2, 2, 2, 642, 643, 5, 56, 29, 2, 643, 59, 3, 2, 2,
	2, 644, 647, 7, 33, 2, 2, 645, 646, 7, 17, 2, 2, 646, 648, 5, 202, 102,
	2, 647, 645, 3, 2, 2, 2, 647, 648, 3, 2, 2, 2, 648, 652, 3, 2, 2, 2, 649,
	650, 5, 176, 89, 2, 650, 651, 7, 89, 2, 2, 651, 653, 3, 2, 2, 2, 652, 649,
	3, 2, 2, 2, 652, 653, 3, 2, 2, 2, 653, 657, 3, 2, 2, 2, 654, 658, 5, 176,
	89, 2, 655, 658, 7, 34, 2, 2, 656, 658, 7, 48, 2, 2, 657, 654, 3, 2, 2,
	2, 657, 655, 3, 2, 2, 2, 657, 656, 3, 2, 2, 2, 658, 664, 3, 2, 2, 2, 659,
	661, 7, 109, 2, 2, 660, 662, 5, 48, 25, 2, 661, 660, 3, 2, 2, 2, 661, 662,
	3, 2, 2, 2, 662, 663, 3, 2, 2, 2, 663, 665, 7, 110, 2, 2, 664, 659, 3,
	2, 2, 2, 664, 665, 3, 2, 2, 2, 665, 670, 3, 2, 2, 2, 666, 667, 7, 108,
	2, 2, 667, 669, 5, 90, 46, 2, 668, 666, 3, 2, 2, 2, 669, 672, 3, 2, 2,
	2, 670, 668, 3, 2, 2, 2, 670, 671, 3, 2, 2, 2, 671, 673, 3, 2, 2, 2, 672,
	670, 3, 2, 2, 2, 673, 674, 7, 7, 2, 2, 674, 675, 7, 33, 2, 2, 675, 61,
	3, 2, 2, 2, 676, 677, 9, 7, 2, 2, 677, 63, 3, 2, 2, 2, 678, 679, 5, 62,
	32, 2, 679, 680, 7, 111, 2, 2, 680, 65, 3, 2, 2, 2, 681, 682, 9, 8, 2,
	2, 682, 67, 3, 2, 2, 2, 683, 684, 9, 9, 2, 2, 684, 69, 3, 2, 2, 2, 685,
	688, 5, 110, 56, 2, 686, 688, 7, 95, 2, 2, 687, 685, 3, 2, 2, 2, 687, 686,
	3, 2, 2, 2, 688, 71, 3, 2, 2, 2, 689, 691, 7, 21, 2, 2, 690, 689, 3, 2,
	2, 2, 690, 691, 3, 2, 2, 2, 691, 692, 3, 2, 2, 2, 692, 693, 5, 70, 36,
	2, 693, 701, 3, 2, 2, 2, 694, 696, 7, 106, 2, 2, 695, 697, 7, 21, 2, 2,
	696, 695, 3, 2, 2, 2, 696, 697, 3, 2, 2, 2, 697, 698, 3, 2, 2, 2, 698,
	700, 5, 70, 36, 2, 699, 694, 3, 2, 2, 2, 700, 703, 3, 2, 2, 2, 701, 699,
	3, 2, 2, 2, 701, 702, 3, 2, 2, 2, 702, 73, 3, 2, 2, 2, 703, 701, 3, 2,
	2, 2, 704, 705, 5, 76, 39, 2, 705, 75, 3, 2, 2, 2, 706, 711, 5, 78, 40,
	2, 707, 708, 7, 68, 2, 2, 708, 710, 5, 78, 40, 2, 709, 707, 3, 2, 2, 2,
	710, 713, 3, 2, 2, 2, 711, 709, 3, 2, 2, 2, 711, 712, 3, 2, 2, 2, 712,
	77, 3, 2, 2, 2, 713, 711, 3, 2, 2, 2, 714, 719, 5, 80, 41, 2, 715, 716,
	7, 69, 2, 2, 716, 718, 5, 80, 41, 2, 717, 715, 3, 2, 2, 2, 718, 721, 3,
	2, 2, 2, 719, 717, 3, 2, 2, 2, 719, 720, 3, 2, 2, 2, 720, 79, 3, 2, 2,
	2, 721, 719, 3, 2, 2, 2, 722, 724, 7, 70, 2, 2, 723, 722, 3, 2, 2, 2, 723,
	724, 3, 2, 2, 2, 724, 725, 3, 2, 2, 2, 725, 726, 5, 82, 42, 2, 726, 81,
	3, 2, 2, 2, 727, 730, 5, 84, 43, 2, 728, 729, 9, 10, 2, 2, 729, 731, 5,
	84, 43, 2, 730, 728, 3, 2, 2, 2, 730, 731, 3, 2, 2, 2, 731, 83, 3, 2, 2,
	2, 732, 737, 5, 86, 44, 2, 733, 734, 9, 3, 2, 2, 734, 736, 5, 86, 44, 2,
	735, 733, 3, 2, 2, 2, 736, 739, 3, 2, 2, 2, 737, 735, 3, 2, 2, 2, 737,
	738, 3, 2, 2, 2, 738, 85, 3, 2, 2, 2, 739, 737, 3, 2, 2, 2, 740, 745, 5,
	88, 45, 2, 741, 742, 9, 11, 2, 2, 742, 744, 5, 88, 45, 2, 743, 741, 3,
	2, 2, 2, 744, 747, 3, 2, 2, 2, 745, 743, 3, 2, 2, 2, 745, 746, 3, 2, 2,
	2, 746, 87, 3, 2, 2, 2, 747, 745, 3, 2, 2, 2, 748, 749, 7, 109, 2, 2, 749,
	750, 5, 70, 36, 2, 750, 751, 7, 110, 2, 2, 751, 757, 3, 2, 2, 2, 752, 754,
	9, 3, 2, 2, 753, 752, 3, 2, 2, 2, 753, 754, 3, 2, 2, 2, 754, 755, 3, 2,
	2, 2, 755, 757, 5, 190, 96, 2, 756, 748, 3, 2, 2, 2, 756, 753, 3, 2, 2,
	2, 757, 89, 3, 2, 2, 2, 758, 788, 5, 138, 70, 2, 759, 760, 7, 66, 2, 2,
	760, 788, 5, 176, 89, 2, 761, 788, 5, 96, 49, 2, 762, 763, 5, 92, 47, 2,
	763, 764, 7, 108, 2, 2, 764, 788, 3, 2, 2, 2, 765, 788, 5, 136, 69, 2,
	766, 788, 7, 40, 2, 2, 767, 788, 5, 146, 74, 2, 768, 788, 5, 112, 57, 2,
	769, 788, 5, 120, 61, 2, 770, 788, 5, 42, 22, 2, 771, 788, 5, 34, 18, 2,
	772, 788, 5, 116, 59, 2, 773, 788, 5, 134, 68, 2, 774, 788, 5, 132, 67,
	2, 775, 788, 5, 124, 63, 2, 776, 788, 5, 128, 65, 2, 777, 788, 5, 166,
	84, 2, 778, 788, 5, 174, 88, 2, 779, 788, 5, 172, 87, 2, 780, 788, 5, 164,
	83, 2, 781, 788, 5, 152, 77, 2, 782, 788, 5, 102, 52, 2, 783, 788, 5, 130,
	66, 2, 784, 788, 5, 142, 72, 2, 785, 788, 5, 150, 76, 2, 786, 788, 5, 190,
	96, 2, 787, 758, 3, 2, 2, 2, 787, 759, 3, 2, 2, 2, 787, 761, 3, 2, 2, 2,
	787, 762, 3, 2, 2, 2, 787, 765, 3, 2, 2, 2, 787, 766, 3, 2, 2, 2, 787,
	767, 3, 2, 2, 2, 787, 768, 3, 2, 2, 2, 787, 769, 3, 2, 2, 2, 787, 770,
	3, 2, 2, 2, 787, 771, 3, 2, 2, 2, 787, 772, 3, 2, 2, 2, 787, 773, 3, 2,
	2, 2, 787, 774, 3, 2, 2, 2, 787, 775, 3, 2, 2, 2, 787, 776, 3, 2, 2, 2,
	787, 777, 3, 2, 2, 2, 787, 778, 3, 2, 2, 2, 787, 779, 3, 2, 2, 2, 787,
	780, 3, 2, 2, 2, 787, 781, 3, 2, 2, 2, 787, 782, 3, 2, 2, 2, 787, 783,
	3, 2, 2, 2, 787, 784, 3, 2, 2, 2, 787, 785, 3, 2, 2, 2, 787, 786, 3, 2,
	2, 2, 788, 91, 3, 2, 2, 2, 789, 802, 5, 106, 54, 2, 790, 802, 5, 104, 53,
	2, 791, 802, 5, 100, 51, 2, 792, 802, 5, 108, 55, 2, 793, 802, 5, 110,
	56, 2, 794, 802, 5, 32, 17, 2, 795, 802, 5, 114, 58, 2, 796, 802, 5, 122,
	62, 2, 797, 802, 5, 126, 64, 2, 798, 802, 5, 140, 71, 2, 799, 802, 5, 162,
	82, 2, 800, 802, 5, 94, 48, 2, 801, 789, 3, 2, 2, 2, 801, 790, 3, 2, 2,
	2, 801, 791, 3, 2, 2, 2, 801, 792, 3, 2, 2, 2, 801, 793, 3, 2, 2, 2, 801,
	794, 3, 2, 2, 2, 801, 795, 3, 2, 2, 2, 801, 796, 3, 2, 2, 2, 801, 797,
	3, 2, 2, 2, 801, 798, 3, 2, 2, 2, 801, 799, 3, 2, 2, 2, 801, 800, 3, 2,
	2, 2, 802, 93, 3, 2, 2, 2, 803, 804, 5, 98, 50, 2, 804, 809, 9, 12, 2,
	2, 805, 810, 7, 70, 2, 2, 806, 810, 7, 95, 2, 2, 807, 810, 5, 74, 38, 2,
	808, 810, 5, 70, 36, 2, 809, 805, 3, 2, 2, 2, 809, 806, 3, 2, 2, 2, 809,
	807, 3, 2, 2, 2, 809, 808, 3, 2, 2, 2, 810, 95, 3, 2, 2, 2, 811, 813, 5,
	94, 48, 2, 812, 814, 7, 108, 2, 2, 813, 812, 3, 2, 2, 2, 813, 814, 3, 2,
	2, 2, 814, 97, 3, 2, 2, 2, 815, 816, 5, 180, 91, 2, 816, 817, 7, 113, 2,
	2, 817, 818, 5, 178, 90, 2, 818, 824, 3, 2, 2, 2, 819, 824, 5, 182, 92,
	2, 820, 824, 5, 184, 93, 2, 821, 824, 5, 186, 94, 2, 822, 824, 5, 188,
	95, 2, 823, 815, 3, 2, 2, 2, 823, 819, 3, 2, 2, 2, 823, 820, 3, 2, 2, 2,
	823, 821, 3, 2, 2, 2, 823, 822, 3, 2, 2, 2, 824, 99, 3, 2, 2, 2, 825, 827,
	7, 67, 2, 2, 826, 828, 5, 70, 36, 2, 827, 826, 3, 2, 2, 2, 827, 828, 3,
	2, 2, 2, 828, 101, 3, 2, 2, 2, 829, 830, 5, 100, 51, 2, 830, 103, 3, 2,
	2, 2, 831, 832, 5, 180, 91, 2, 832, 833, 7, 113, 2, 2, 833, 834, 5, 178,
	90, 2, 834, 837, 3, 2, 2, 2, 835, 837, 5, 182, 92, 2, 836, 831, 3, 2, 2,
	2, 836, 835, 3, 2, 2, 2, 837, 105, 3, 2, 2, 2, 838, 839, 5, 176, 89, 2,
	839, 840, 7, 113, 2, 2, 840, 842, 7, 25, 2, 2, 841, 843, 7, 33, 2, 2, 842,
	841, 3, 2, 2, 2, 842, 843, 3, 2, 2, 2, 843, 844, 3, 2, 2, 2, 844, 845,
	5, 104, 53, 2, 845, 853, 3, 2, 2, 2, 846, 847, 5, 176, 89, 2, 847, 848,
	7, 113, 2, 2, 848, 849, 7, 33, 2, 2, 849, 850, 7, 25, 2, 2, 850, 851, 5,
	104, 53, 2, 851, 853, 3, 2, 2, 2, 852, 838, 3, 2, 2, 2, 852, 846, 3, 2,
	2, 2, 853, 107, 3, 2, 2, 2, 854, 855, 7, 34, 2, 2, 855, 856, 7, 109, 2,
	2, 856, 857, 5, 72, 37, 2, 857, 858, 7, 110, 2, 2, 858, 109, 3, 2, 2, 2,
	859, 860, 7, 48, 2, 2, 860, 861, 7, 109, 2, 2, 861, 862, 5, 72, 37, 2,
	862, 863, 7, 110, 2, 2, 863, 867, 3, 2, 2, 2, 864, 865, 7, 72, 2, 2, 865,
	867, 7, 48, 2, 2, 866, 859, 3, 2, 2, 2, 866, 864, 3, 2, 2, 2, 867, 111,
	3, 2, 2, 2, 868, 873, 5, 104, 53, 2, 869, 873, 5, 106, 54, 2, 870, 873,
	5, 108, 55, 2, 871, 873, 5, 110, 56, 2, 872, 868, 3, 2, 2, 2, 872, 869,
	3, 2, 2, 2, 872, 870, 3, 2, 2, 2, 872, 871, 3, 2, 2, 2, 873, 113, 3, 2,
	2, 2, 874, 878, 7, 71, 2, 2, 875, 876, 5, 176, 89, 2, 876, 877, 7, 100,
	2, 2, 877, 879, 3, 2, 2, 2, 878, 875, 3, 2, 2, 2, 878, 879, 3, 2, 2, 2,
	879, 882, 3, 2, 2, 2, 880, 883, 5, 182, 92, 2, 881, 883, 5, 188, 95, 2,
	882, 880, 3, 2, 2, 2, 882, 881, 3, 2, 2, 2, 883, 115, 3, 2, 2, 2, 884,
	885, 5, 114, 58, 2, 885, 117, 3, 2, 2, 2, 886, 887, 5, 176, 89, 2, 887,
	891, 7, 113, 2, 2, 888, 889, 5, 176, 89, 2, 889, 890, 7, 113, 2, 2, 890,
	892, 3, 2, 2, 2, 891, 888, 3, 2, 2, 2, 891, 892, 3, 2, 2, 2, 892, 896,
	3, 2, 2, 2, 893, 894, 7, 73, 2, 2, 894, 896, 7, 89, 2, 2, 895, 886, 3,
	2, 2, 2, 895, 893, 3, 2, 2, 2, 895, 896, 3, 2, 2, 2, 896, 897, 3, 2, 2,
	2, 897, 898, 7, 33, 2, 2, 898, 899, 5, 182, 92, 2, 899, 119, 3, 2, 2, 2,
	900, 901, 5, 118, 60, 2, 901, 121, 3, 2, 2, 2, 902, 904, 7, 57, 2, 2, 903,
	905, 7, 59, 2, 2, 904, 903, 3, 2, 2, 2, 904, 905, 3, 2, 2, 2, 905, 909,
	3, 2, 2, 2, 906, 907, 5, 176, 89, 2, 907, 908, 7, 113, 2, 2, 908, 910,
	3, 2, 2, 2, 909, 906, 3, 2, 2, 2, 909, 910, 3, 2, 2, 2, 910, 911, 3, 2,
	2, 2, 911, 917, 5, 202, 102, 2, 912, 914, 7, 109, 2, 2, 913, 915, 5, 72,
	37, 2, 914, 913, 3, 2, 2, 2, 914, 915, 3, 2, 2, 2, 915, 916, 3, 2, 2, 2,
	916, 918, 7, 110, 2, 2, 917, 912, 3, 2, 2, 2, 917, 918, 3, 2, 2, 2, 918,
	123, 3, 2, 2, 2, 919, 920, 5, 122, 62, 2, 920, 125, 3, 2, 2, 2, 921, 922,
	7, 58, 2, 2, 922, 923, 5, 70, 36, 2, 923, 127, 3, 2, 2, 2, 924, 925, 5,
	126, 64, 2, 925, 129, 3, 2, 2, 2, 926, 927, 7, 47, 2, 2, 927, 928, 5, 98,
	50, 2, 928, 929, 7, 79, 2, 2, 929, 930, 5, 70, 36, 2, 930, 931, 7, 19,
	2, 2, 931, 934, 5, 70, 36, 2, 932, 933, 7, 52, 2, 2, 933, 935, 5, 70, 36,
	2, 934, 932, 3, 2, 2, 2, 934, 935, 3, 2, 2, 2, 935, 936, 3, 2, 2, 2, 936,
	937, 5, 90, 46, 2, 937, 938, 7, 49, 2, 2, 938, 131, 3, 2, 2, 2, 939, 940,
	7, 45, 2, 2, 940, 941, 9, 13, 2, 2, 941, 945, 5, 74, 38, 2, 942, 944, 5,
	90, 46, 2, 943, 942, 3, 2, 2, 2, 944, 947, 3, 2, 2, 2, 945, 943, 3, 2,
	2, 2, 945, 946, 3, 2, 2, 2, 946, 948, 3, 2, 2, 2, 947, 945, 3, 2, 2, 2,
	948, 949, 7, 50, 2, 2, 949, 133, 3, 2, 2, 2, 950, 954, 7, 45, 2, 2, 951,
	953, 5, 90, 46, 2, 952, 951, 3, 2, 2, 2, 953, 956, 3, 2, 2, 2, 954, 952,
	3, 2, 2, 2, 954, 955, 3, 2, 2, 2, 955, 957, 3, 2, 2, 2, 956, 954, 3, 2,
	2, 2, 957, 958, 7, 50, 2, 2, 958, 959, 9, 13, 2, 2, 959, 960, 5, 74, 38,
	2, 960, 135, 3, 2, 2, 2, 961, 962, 7, 37, 2, 2, 962, 963, 5, 74, 38, 2,
	963, 967, 7, 38, 2, 2, 964, 966, 5, 90, 46, 2, 965, 964, 3, 2, 2, 2, 966,
	969, 3, 2, 2, 2, 967, 965, 3, 2, 2, 2, 967, 968, 3, 2, 2, 2, 968, 981,
	3, 2, 2, 2, 969, 967, 3, 2, 2, 2, 970, 971, 7, 39, 2, 2, 971, 972, 5, 74,
	38, 2, 972, 976, 7, 38, 2, 2, 973, 975, 5, 90, 46, 2, 974, 973, 3, 2, 2,
	2, 975, 978, 3, 2, 2, 2, 976, 974, 3, 2, 2, 2, 976, 977, 3, 2, 2, 2, 977,
	980, 3, 2, 2, 2, 978, 976, 3, 2, 2, 2, 979, 970, 3, 2, 2, 2, 980, 983,
	3, 2, 2, 2, 981, 979, 3, 2, 2, 2, 981, 982, 3, 2, 2, 2, 982, 991, 3, 2,
	2, 2, 983, 981, 3, 2, 2, 2, 984, 988, 7, 36, 2, 2, 985, 987, 5, 90, 46,
	2, 986, 985, 3, 2, 2, 2, 987, 990, 3, 2, 2, 2, 988, 986, 3, 2, 2, 2, 988,
	989, 3, 2, 2, 2, 989, 992, 3, 2, 2, 2, 990, 988, 3, 2, 2, 2, 991, 984,
	3, 2, 2, 2, 991, 992, 3, 2, 2, 2, 992, 993, 3, 2, 2, 2, 993, 994, 7, 7,
	2, 2, 994, 997, 7, 37, 2, 2, 995, 998, 7, 108, 2, 2, 996, 998, 3, 2, 2,
	2, 997, 995, 3, 2, 2, 2, 997, 996, 3, 2, 2, 2, 998, 137, 3, 2, 2, 2, 999,
	1000, 7, 37, 2, 2, 1000, 1001, 5, 74, 38, 2, 1001, 1002, 7, 38, 2, 2, 1002,
	1003, 5, 90, 46, 2, 1003, 139, 3, 2, 2, 2, 1004, 1005, 7, 44, 2, 2, 1005,
	141, 3, 2, 2, 2, 1006, 1007, 5, 140, 71, 2, 1007, 143, 3, 2, 2, 2, 1008,
	1009, 5, 188, 95, 2, 1009, 1010, 7, 113, 2, 2, 1010, 1012, 3, 2, 2, 2,
	1011, 1008, 3, 2, 2, 2, 1011, 1012, 3, 2, 2, 2, 1012, 1013, 3, 2, 2, 2,
	1013, 1015, 9, 14, 2, 2, 1014, 1016, 7, 33, 2, 2, 1015, 1014, 3, 2, 2,
	2, 1015, 1016, 3, 2, 2, 2, 1016, 1017, 3, 2, 2, 2, 1017, 1018, 5, 178,
	90, 2, 1018, 1020, 7, 109, 2, 2, 1019, 1021, 5, 72, 37, 2, 1020, 1019,
	3, 2, 2, 2, 1020, 1021, 3, 2, 2, 2, 1021, 1022, 3, 2, 2, 2, 1022, 1023,
	7, 110, 2, 2, 1023, 145, 3, 2, 2, 2, 1024, 1025, 5, 144, 73, 2, 1025, 147,
	3, 2, 2, 2, 1026, 1027, 7, 41, 2, 2, 1027, 149, 3, 2, 2, 2, 1028, 1029,
	5, 148, 75, 2, 1029, 151, 3, 2, 2, 2, 1030, 1031, 7, 42, 2, 2, 1031, 1032,
	7, 24, 2, 2, 1032, 1037, 5, 70, 36, 2, 1033, 1038, 5, 158, 80, 2, 1034,
	1038, 5, 156, 79, 2, 1035, 1038, 5, 160, 81, 2, 1036, 1038, 5, 154, 78,
	2, 1037, 1033, 3, 2, 2, 2, 1037, 1034, 3, 2, 2, 2, 1037, 1035, 3, 2, 2,
	2, 1037, 1036, 3, 2, 2, 2, 1038, 1039, 3, 2, 2, 2, 1039, 1037, 3, 2, 2,
	2, 1039, 1040, 3, 2, 2, 2, 1040, 1041, 3, 2, 2, 2, 1041, 1042, 7, 7, 2,
	2, 1042, 1043, 7, 42, 2, 2, 1043, 153, 3, 2, 2, 2, 1044, 1045, 7, 24, 2,
	2, 1045, 1050, 5, 70, 36, 2, 1046, 1047, 7, 106, 2, 2, 1047, 1049, 5, 70,
	36, 2, 1048, 1046, 3, 2, 2, 2, 1049, 1052, 3, 2, 2, 2, 1050, 1048, 3, 2,
	2, 2, 1050, 1051, 3, 2, 2, 2, 1051, 1056, 3, 2, 2, 2, 1052, 1050, 3, 2,
	2, 2, 1053, 1055, 5, 90, 46, 2, 1054, 1053, 3, 2, 2, 2, 1055, 1058, 3,
	2, 2, 2, 1056, 1054, 3, 2, 2, 2, 1056, 1057, 3, 2, 2, 2, 1057, 155, 3,
	2, 2, 2, 1058, 1056, 3, 2, 2, 2, 1059, 1060, 7, 24, 2, 2, 1060, 1061, 7,
	43, 2, 2, 1061, 1062, 9, 10, 2, 2, 1062, 1066, 5, 70, 36, 2, 1063, 1065,
	5, 90, 46, 2, 1064, 1063, 3, 2, 2, 2, 1065, 1068, 3, 2, 2, 2, 1066, 1064,
	3, 2, 2, 2, 1066, 1067, 3, 2, 2, 2, 1067, 157, 3, 2, 2, 2, 1068, 1066,
	3, 2, 2, 2, 1069, 1070, 7, 24, 2, 2, 1070, 1071, 5, 190, 96, 2, 1071, 1072,
	7, 19, 2, 2, 1072, 1076, 5, 190, 96, 2, 1073, 1075, 5, 90, 46, 2, 1074,
	1073, 3, 2, 2, 2, 1075, 1078, 3, 2, 2, 2, 1076, 1074, 3, 2, 2, 2, 1076,
	1077, 3, 2, 2, 2, 1077, 159, 3, 2, 2, 2, 1078, 1076, 3, 2, 2, 2, 1079,
	1080, 7, 24, 2, 2, 1080, 1084, 7, 36, 2, 2, 1081, 1083, 5, 90, 46, 2, 1082,
	1081, 3, 2, 2, 2, 1083, 1086, 3, 2, 2, 2, 1084, 1082, 3, 2, 2, 2, 1084,
	1085, 3, 2, 2, 2, 1085, 161, 3, 2, 2, 2, 1086, 1084, 3, 2, 2, 2, 1087,
	1088, 7, 35, 2, 2, 1088, 1089, 5, 176, 89, 2, 1089, 163, 3, 2, 2, 2, 1090,
	1091, 5, 162, 82, 2, 1091, 165, 3, 2, 2, 2, 1092, 1093, 5, 176, 89, 2,
	1093, 1094, 7, 111, 2, 2, 1094, 167, 3, 2, 2, 2, 1095, 1099, 7, 40, 2,
	2, 1096, 1098, 5, 90, 46, 2, 1097, 1096, 3, 2, 2, 2, 1098, 1101, 3, 2,
	2, 2, 1099, 1097, 3, 2, 2, 2, 1099, 1100, 3, 2, 2, 2, 1100, 1114, 3, 2,
	2, 2, 1101, 1099, 3, 2, 2, 2, 1102, 1103, 7, 53, 2, 2, 1103, 1104, 7, 109,
	2, 2, 1104, 1105, 5, 32, 17, 2, 1105, 1109, 7, 110, 2, 2, 1106, 1108, 5,
	90, 46, 2, 1107, 1106, 3, 2, 2, 2, 1108, 1111, 3, 2, 2, 2, 1109, 1107,
	3, 2, 2, 2, 1109, 1110, 3, 2, 2, 2, 1110, 1113, 3, 2, 2, 2, 1111, 1109,
	3, 2, 2, 2, 1112, 1102, 3, 2, 2, 2, 1113, 1116, 3, 2, 2, 2, 1114, 1112,
	3, 2, 2, 2, 1114, 1115, 3, 2, 2, 2, 1115, 1124, 3, 2, 2, 2, 1116, 1114,
	3, 2, 2, 2, 1117, 1121, 7, 54, 2, 2, 1118, 1120, 5, 90, 46, 2, 1119, 1118,
	3, 2, 2, 2, 1120, 1123, 3, 2, 2, 2, 1121, 1119, 3, 2, 2, 2, 1121, 1122,
	3, 2, 2, 2, 1122, 1125, 3, 2, 2, 2, 1123, 1121, 3, 2, 2, 2, 1124, 1117,
	3, 2, 2, 2, 1124, 1125, 3, 2, 2, 2, 1125, 1126, 3, 2, 2, 2, 1126, 1127,
	7, 7, 2, 2, 1127, 1128, 7, 40, 2, 2, 1128, 169, 3, 2, 2, 2, 1129, 1130,
	7, 55, 2, 2, 1130, 1131, 5, 70, 36, 2, 1131, 171, 3, 2, 2, 2, 1132, 1133,
	5, 170, 86, 2, 1133, 173, 3, 2, 2, 2, 1134, 1155, 5, 176, 89, 2, 1135,
	1136, 7, 73, 2, 2, 1136, 1140, 7, 89, 2, 2, 1137, 1141, 7, 57, 2, 2, 1138,
	1141, 7, 58, 2, 2, 1139, 1141, 5, 178, 90, 2, 1140, 1137, 3, 2, 2, 2, 1140,
	1138, 3, 2, 2, 2, 1140, 1139, 3, 2, 2, 2, 1141, 1155, 3, 2, 2, 2, 1142,
	1143, 5, 176, 89, 2, 1143, 1144, 7, 89, 2, 2, 1144, 1145, 9, 15, 2, 2,
	1145, 1155, 3, 2, 2, 2, 1146, 1147, 5, 176, 89, 2, 1147, 1148, 7, 113,
	2, 2, 1148, 1149, 9, 15, 2, 2, 1149, 1155, 3, 2, 2, 2, 1150, 1151, 5, 176,
	89, 2, 1151, 1152, 7, 89, 2, 2, 1152, 1153, 5, 178, 90, 2, 1153, 1155,
	3, 2, 2, 2, 1154, 1134, 3, 2, 2, 2, 1154, 1135, 3, 2, 2, 2, 1154, 1142,
	3, 2, 2, 2, 1154, 1146, 3, 2, 2, 2, 1154, 1150, 3, 2, 2, 2, 1155, 175,
	3, 2, 2, 2, 1156, 1157, 7, 107, 2, 2, 1157, 177, 3, 2, 2, 2, 1158, 1171,
	5, 176, 89, 2, 1159, 1171, 7, 62, 2, 2, 1160, 1171, 7, 17, 2, 2, 1161,
	1171, 7, 23, 2, 2, 1162, 1171, 7, 63, 2, 2, 1163, 1171, 7, 34, 2, 2, 1164,
	1171, 7, 48, 2, 2, 1165, 1171, 7, 35, 2, 2, 1166, 1171, 7, 64, 2, 2, 1167,
	1171, 7, 66, 2, 2, 1168, 1171, 7, 65, 2, 2, 1169, 1171, 7, 15, 2, 2, 1170,
	1158, 3, 2, 2, 2, 1170, 1159, 3, 2, 2, 2, 1170, 1160, 3, 2, 2, 2, 1170,
	1161, 3, 2, 2, 2, 1170, 1162, 3, 2, 2, 2, 1170, 1163, 3, 2, 2, 2, 1170,
	1164, 3, 2, 2, 2, 1170, 1165, 3, 2, 2, 2, 1170, 1166, 3, 2, 2, 2, 1170,
	1167, 3, 2, 2, 2, 1170, 1168, 3, 2, 2, 2, 1170, 1169, 3, 2, 2, 2, 1171,
	179, 3, 2, 2, 2, 1172, 1182, 5, 192, 97, 2, 1173, 1174, 5, 176, 89, 2,
	1174, 1176, 7, 109, 2, 2, 1175, 1177, 5, 72, 37, 2, 1176, 1175, 3, 2, 2,
	2, 1176, 1177, 3, 2, 2, 2, 1177, 1178, 3, 2, 2, 2, 1178, 1179, 7, 110,
	2, 2, 1179, 1182, 3, 2, 2, 2, 1180, 1182, 5, 176, 89, 2, 1181, 1172, 3,
	2, 2, 2, 1181, 1173, 3, 2, 2, 2, 1181, 1180, 3, 2, 2, 2, 1182, 181, 3,
	2, 2, 2, 1183, 1186, 5, 174, 88, 2, 1184, 1186, 7, 66, 2, 2, 1185, 1183,
	3, 2, 2, 2, 1185, 1184, 3, 2, 2, 2, 1186, 1187, 3, 2, 2, 2, 1187, 1189,
	7, 109, 2, 2, 1188, 1190, 5, 72, 37, 2, 1189, 1188, 3, 2, 2, 2, 1189, 1190,
	3, 2, 2, 2, 1190, 1191, 3, 2, 2, 2, 1191, 1192, 7, 110, 2, 2, 1192, 183,
	3, 2, 2, 2, 1193, 1194, 5, 176, 89, 2, 1194, 1195, 7, 97, 2, 2, 1195, 1196,
	5, 72, 37, 2, 1196, 1197, 7, 98, 2, 2, 1197, 185, 3, 2, 2, 2, 1198, 1199,
	5, 176, 89, 2, 1199, 1200, 7, 99, 2, 2, 1200, 187, 3, 2, 2, 2, 1201, 1202,
	5, 174, 88, 2, 1202, 189, 3, 2, 2, 2, 1203, 1221, 5, 118, 60, 2, 1204,
	1205, 5, 180, 91, 2, 1205, 1206, 7, 113, 2, 2, 1206, 1207, 5, 178, 90,
	2, 1207, 1221, 3, 2, 2, 2, 1208, 1221, 5, 198, 100, 2, 1209, 1221, 5, 182,
	92, 2, 1210, 1221, 5, 184, 93, 2, 1211, 1221, 5, 186, 94, 2, 1212, 1221,
	5, 188, 95, 2, 1213, 1221, 5, 194, 98, 2, 1214, 1221, 5, 196, 99, 2, 1215,
	1221, 7, 105, 2, 2, 1216, 1221, 7, 103, 2, 2, 1217, 1221, 7, 104, 2, 2,
	1218, 1221, 7, 115, 2, 2, 1219, 1221, 7, 116, 2, 2, 1220, 1203, 3, 2, 2,
	2, 1220, 1204, 3, 2, 2, 2, 1220, 1208, 3, 2, 2, 2, 1220, 1209, 3, 2, 2,
	2, 1220, 1210, 3, 2, 2, 2, 1220, 1211, 3, 2, 2, 2, 1220, 1212, 3, 2, 2,
	2, 1220, 1213, 3, 2, 2, 2, 1220, 1214, 3, 2, 2, 2, 1220, 1215, 3, 2, 2,
	2, 1220, 1216, 3, 2, 2, 2, 1220, 1217, 3, 2, 2, 2, 1220, 1218, 3, 2, 2,
	2, 1220, 1219, 3, 2, 2, 2, 1221, 191, 3, 2, 2, 2, 1222, 1223, 5, 176, 89,
	2, 1223, 1224, 7, 97, 2, 2, 1224, 1225, 5, 72, 37, 2, 1225, 1226, 7, 98,
	2, 2, 1226, 193, 3, 2, 2, 2, 1227, 1228, 7, 112, 2, 2, 1228, 195, 3, 2,
	2, 2, 1229, 1230, 7, 4, 2, 2, 1230, 197, 3, 2, 2, 2, 1231, 1232, 5, 200,
	101, 2, 1232, 1233, 7, 109, 2, 2, 1233, 1238, 5, 70, 36, 2, 1234, 1235,
	7, 106, 2, 2, 1235, 1237, 5, 70, 36, 2, 1236, 1234, 3, 2, 2, 2, 1237, 1240,
	3, 2, 2, 2, 1238, 1236, 3, 2, 2, 2, 1238, 1239, 3, 2, 2, 2, 1239, 1241,
	3, 2, 2, 2, 1240, 1238, 3, 2, 2, 2, 1241, 1242, 7, 110, 2, 2, 1242, 199,
	3, 2, 2, 2, 1243, 1244, 7, 3, 2, 2, 1244, 201, 3, 2, 2, 2, 1245, 1248,
	5, 200, 101, 2, 1246, 1248, 5, 176, 89, 2, 1247, 1245, 3, 2, 2, 2, 1247,
	1246, 3, 2, 2, 2, 1248, 203, 3, 2, 2, 2, 156, 205, 210, 217, 221, 226,
	241, 252, 256, 260, 267, 274, 277, 283, 289, 292, 294, 299, 302, 310, 314,
	320, 339, 344, 346, 353, 358, 360, 366, 375, 377, 382, 384, 390, 398, 403,
	406, 412, 416, 418, 429, 431, 441, 443, 450, 453, 456, 468, 473, 476, 480,
	485, 488, 492, 495, 498, 506, 509, 514, 519, 527, 529, 535, 539, 542, 545,
	549, 553, 560, 565, 572, 578, 581, 586, 591, 596, 602, 612, 618, 621, 625,
	628, 636, 640, 647, 652, 657, 661, 664, 670, 687, 690, 696, 701, 711, 719,
	723, 730, 737, 745, 753, 756, 787, 801, 809, 813, 823, 827, 836, 842, 852,
	866, 872, 878, 882, 891, 895, 904, 909, 914, 917, 934, 945, 954, 967, 976,
	981, 988, 991, 997, 1011, 1015, 1020, 1037, 1039, 1050, 1056, 1066, 1076,
	1084, 1099, 1109, 1114, 1121, 1124, 1140, 1154, 1170, 1176, 1181, 1185,
	1189, 1220, 1238, 1247,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
	"", "", "", "", "", "'='", "'>'", "'>='", "'<'", "'<='", "'<>'", "'+'",
	"'-'", "'+='", "'-='", "'::'", "'*'", "'/'", "'*='", "'/='", "'^'", "'{'",
	"'}'", "'['", "']'", "'[]'", "'`'", "", "", "", "", "", "','", "", "';'",
	"'('", "')'", "':'", "", "", "'\"'", "", "", "", "'???'", "'||'", "", "'...'",
}
var symbolicNames = []string{
	"", "DATA_TYPE_SUB", "BOOLEAN_ATOM", "GLOBAL", "SHARED", "END", "INDIRECT",
	"VARIABLES", "FORWARD", "PUBLIC", "PRIVATE", "FUNCTION", "SUBROUTINE",
	"READONLY", "PROTOTYPES", "TYPE", "ON", "TO", "FROM", "REF", "NULL", "UPDATE",
	"CASE", "DYNAMIC", "WITHIN", "PRIVATEWRITE", "PROTECTED", "PRIVATEREAD",
	"PROTECTEDREAD", "PROTECTEDWRITE", "LOCAL", "EVENT", "OPEN", "GOTO", "ELSE",
	"IF", "THEN", "ELSEIF", "TRY", "EXIT", "CHOOSE", "IS", "CONTINUE", "DO",
	"WHILE", "FOR", "CLOSE", "NEXT", "LOOP", "UNTIL", "STEP", "CATCH", "FINALLY",
	"THROW", "RELEASE", "CREATE", "DESTROY", "USING", "POST", "TRIGGER", "SELECT",
	"DELETE", "INSERT", "TIME2", "DESCRIBE", "RETURN", "OR", "AND", "NOT",
	"CALL", "HALT", "SUPER", "LIBRARY", "SYSTEM", "RPCFUNC", "ALIAS", "THROWS",
	"EQ", "GT", "GTE", "LT", "LTE", "GTLT", "PLUS", "MINUS", "PLUSEQ", "MINUSEQ",
	"COLONCOLON", "MULT", "DIV", "MULTEQ", "DIVEQ", "CARAT", "LCURLY", "RCURLY",
	"LBRACE", "RBRACE", "BRACES", "TICK", "AUTOINSTANTIATE", "DESCRIPTOR",
	"DQUOTED_STRING", "QUOTED_STRING", "ENUM", "COMMA", "ID", "SEMI", "LPAREN",
	"RPAREN", "COLON", "NUMBER", "DOT", "DQUOTE", "DATE", "TIME", "BINDPAR",
	"TQ", "DOUBLE_PIPE", "LINE_CONTINUATION", "DOTDOTDOT", "EXPORT_HEADER",
	"SL_COMMENT", "ML_COMMENT", "WS",
}

var ruleNames = []string{
	"start_rule", "header_rule", "body_rule", "export_header", "release_information",
	"window_property_line", "window_property", "window_property_attributes_sub",
	"window_property_attribute_sub", "attribute_name", "attribute_value", "forward_decl",
	"datatype_decl", "type_variables_decl", "global_variables_decl", "variable_decl_sub",
	"variable_decl", "decimal_decl_sub", "array_decl_sub", "constant_decl_sub",
	"constant_decl", "function_forward_decl", "parameter_sub", "parameters_list_sub",
	"functions_forward_decl", "function_body", "on_body", "event_forward_decl_sub",
	"event_forward_decl", "event_body", "access_type", "access_modif", "access_modif_part",
	"scope_modif", "expression", "expression_list", "boolean_expression", "condition_or",
	"condition_and", "condition_not", "condition_comparison", "add_expr", "mul_expr",
	"unary_sign_expr", "statement", "statement_sub", "assignment_sub", "assignment_statement",
	"lvalue_sub", "return_sub", "return_statement", "function_call_expression_sub",
	"function_virtual_call_expression_sub", "open_call_sub", "close_call_sub",
	"function_call_statement", "super_call_sub", "super_call_statement", "event_call_statement_sub",
	"event_call_statement", "create_call_sub", "create_call_statement", "destroy_call_sub",
	"destroy_call_statement", "for_loop_statement", "do_while_loop_statement",
	"do_loop_while_statement", "if_statement", "if_simple_statement", "continue_sub",
	"continue_statement", "post_event_sub", "post_event", "exit_statement_sub",
	"exit_statement", "choose_statement", "choose_case_value_sub", "choose_case_cond_sub",
	"choose_case_range_sub", "choose_case_else_sub", "goto_stat_sub", "goto_stat",
	"label_stat", "try_catch_block", "throw_stat_sub", "throw_stat", "identifier",
	"identifier_name", "identifier_name_ex", "atom_sub", "atom_sub_call1",
	"atom_sub_array1", "atom_sub_ref1", "atom_sub_member1", "atom", "array_access_atom",
	"numeric_atom", "boolean_atom", "cast_expression", "data_type_sub", "data_type_name",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type powerbuilderParser struct {
	*antlr.BaseParser
}

func NewpowerbuilderParser(input antlr.TokenStream) *powerbuilderParser {
	this := new(powerbuilderParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "powerbuilderParser.g4"

	return this
}

// powerbuilderParser tokens.
const (
	powerbuilderParserEOF               = antlr.TokenEOF
	powerbuilderParserDATA_TYPE_SUB     = 1
	powerbuilderParserBOOLEAN_ATOM      = 2
	powerbuilderParserGLOBAL            = 3
	powerbuilderParserSHARED            = 4
	powerbuilderParserEND               = 5
	powerbuilderParserINDIRECT          = 6
	powerbuilderParserVARIABLES         = 7
	powerbuilderParserFORWARD           = 8
	powerbuilderParserPUBLIC            = 9
	powerbuilderParserPRIVATE           = 10
	powerbuilderParserFUNCTION          = 11
	powerbuilderParserSUBROUTINE        = 12
	powerbuilderParserREADONLY          = 13
	powerbuilderParserPROTOTYPES        = 14
	powerbuilderParserTYPE              = 15
	powerbuilderParserON                = 16
	powerbuilderParserTO                = 17
	powerbuilderParserFROM              = 18
	powerbuilderParserREF               = 19
	powerbuilderParserNULL              = 20
	powerbuilderParserUPDATE            = 21
	powerbuilderParserCASE              = 22
	powerbuilderParserDYNAMIC           = 23
	powerbuilderParserWITHIN            = 24
	powerbuilderParserPRIVATEWRITE      = 25
	powerbuilderParserPROTECTED         = 26
	powerbuilderParserPRIVATEREAD       = 27
	powerbuilderParserPROTECTEDREAD     = 28
	powerbuilderParserPROTECTEDWRITE    = 29
	powerbuilderParserLOCAL             = 30
	powerbuilderParserEVENT             = 31
	powerbuilderParserOPEN              = 32
	powerbuilderParserGOTO              = 33
	powerbuilderParserELSE              = 34
	powerbuilderParserIF                = 35
	powerbuilderParserTHEN              = 36
	powerbuilderParserELSEIF            = 37
	powerbuilderParserTRY               = 38
	powerbuilderParserEXIT              = 39
	powerbuilderParserCHOOSE            = 40
	powerbuilderParserIS                = 41
	powerbuilderParserCONTINUE          = 42
	powerbuilderParserDO                = 43
	powerbuilderParserWHILE             = 44
	powerbuilderParserFOR               = 45
	powerbuilderParserCLOSE             = 46
	powerbuilderParserNEXT              = 47
	powerbuilderParserLOOP              = 48
	powerbuilderParserUNTIL             = 49
	powerbuilderParserSTEP              = 50
	powerbuilderParserCATCH             = 51
	powerbuilderParserFINALLY           = 52
	powerbuilderParserTHROW             = 53
	powerbuilderParserRELEASE           = 54
	powerbuilderParserCREATE            = 55
	powerbuilderParserDESTROY           = 56
	powerbuilderParserUSING             = 57
	powerbuilderParserPOST              = 58
	powerbuilderParserTRIGGER           = 59
	powerbuilderParserSELECT            = 60
	powerbuilderParserDELETE            = 61
	powerbuilderParserINSERT            = 62
	powerbuilderParserTIME2             = 63
	powerbuilderParserDESCRIBE          = 64
	powerbuilderParserRETURN            = 65
	powerbuilderParserOR                = 66
	powerbuilderParserAND               = 67
	powerbuilderParserNOT               = 68
	powerbuilderParserCALL              = 69
	powerbuilderParserHALT              = 70
	powerbuilderParserSUPER             = 71
	powerbuilderParserLIBRARY           = 72
	powerbuilderParserSYSTEM            = 73
	powerbuilderParserRPCFUNC           = 74
	powerbuilderParserALIAS             = 75
	powerbuilderParserTHROWS            = 76
	powerbuilderParserEQ                = 77
	powerbuilderParserGT                = 78
	powerbuilderParserGTE               = 79
	powerbuilderParserLT                = 80
	powerbuilderParserLTE               = 81
	powerbuilderParserGTLT              = 82
	powerbuilderParserPLUS              = 83
	powerbuilderParserMINUS             = 84
	powerbuilderParserPLUSEQ            = 85
	powerbuilderParserMINUSEQ           = 86
	powerbuilderParserCOLONCOLON        = 87
	powerbuilderParserMULT              = 88
	powerbuilderParserDIV               = 89
	powerbuilderParserMULTEQ            = 90
	powerbuilderParserDIVEQ             = 91
	powerbuilderParserCARAT             = 92
	powerbuilderParserLCURLY            = 93
	powerbuilderParserRCURLY            = 94
	powerbuilderParserLBRACE            = 95
	powerbuilderParserRBRACE            = 96
	powerbuilderParserBRACES            = 97
	powerbuilderParserTICK              = 98
	powerbuilderParserAUTOINSTANTIATE   = 99
	powerbuilderParserDESCRIPTOR        = 100
	powerbuilderParserDQUOTED_STRING    = 101
	powerbuilderParserQUOTED_STRING     = 102
	powerbuilderParserENUM              = 103
	powerbuilderParserCOMMA             = 104
	powerbuilderParserID                = 105
	powerbuilderParserSEMI              = 106
	powerbuilderParserLPAREN            = 107
	powerbuilderParserRPAREN            = 108
	powerbuilderParserCOLON             = 109
	powerbuilderParserNUMBER            = 110
	powerbuilderParserDOT               = 111
	powerbuilderParserDQUOTE            = 112
	powerbuilderParserDATE              = 113
	powerbuilderParserTIME              = 114
	powerbuilderParserBINDPAR           = 115
	powerbuilderParserTQ                = 116
	powerbuilderParserDOUBLE_PIPE       = 117
	powerbuilderParserLINE_CONTINUATION = 118
	powerbuilderParserDOTDOTDOT         = 119
	powerbuilderParserEXPORT_HEADER     = 120
	powerbuilderParserSL_COMMENT        = 121
	powerbuilderParserML_COMMENT        = 122
	powerbuilderParserWS                = 123
)

// powerbuilderParser rules.
const (
	powerbuilderParserRULE_start_rule                           = 0
	powerbuilderParserRULE_header_rule                          = 1
	powerbuilderParserRULE_body_rule                            = 2
	powerbuilderParserRULE_export_header                        = 3
	powerbuilderParserRULE_release_information                  = 4
	powerbuilderParserRULE_window_property_line                 = 5
	powerbuilderParserRULE_window_property                      = 6
	powerbuilderParserRULE_window_property_attributes_sub       = 7
	powerbuilderParserRULE_window_property_attribute_sub        = 8
	powerbuilderParserRULE_attribute_name                       = 9
	powerbuilderParserRULE_attribute_value                      = 10
	powerbuilderParserRULE_forward_decl                         = 11
	powerbuilderParserRULE_datatype_decl                        = 12
	powerbuilderParserRULE_type_variables_decl                  = 13
	powerbuilderParserRULE_global_variables_decl                = 14
	powerbuilderParserRULE_variable_decl_sub                    = 15
	powerbuilderParserRULE_variable_decl                        = 16
	powerbuilderParserRULE_decimal_decl_sub                     = 17
	powerbuilderParserRULE_array_decl_sub                       = 18
	powerbuilderParserRULE_constant_decl_sub                    = 19
	powerbuilderParserRULE_constant_decl                        = 20
	powerbuilderParserRULE_function_forward_decl                = 21
	powerbuilderParserRULE_parameter_sub                        = 22
	powerbuilderParserRULE_parameters_list_sub                  = 23
	powerbuilderParserRULE_functions_forward_decl               = 24
	powerbuilderParserRULE_function_body                        = 25
	powerbuilderParserRULE_on_body                              = 26
	powerbuilderParserRULE_event_forward_decl_sub               = 27
	powerbuilderParserRULE_event_forward_decl                   = 28
	powerbuilderParserRULE_event_body                           = 29
	powerbuilderParserRULE_access_type                          = 30
	powerbuilderParserRULE_access_modif                         = 31
	powerbuilderParserRULE_access_modif_part                    = 32
	powerbuilderParserRULE_scope_modif                          = 33
	powerbuilderParserRULE_expression                           = 34
	powerbuilderParserRULE_expression_list                      = 35
	powerbuilderParserRULE_boolean_expression                   = 36
	powerbuilderParserRULE_condition_or                         = 37
	powerbuilderParserRULE_condition_and                        = 38
	powerbuilderParserRULE_condition_not                        = 39
	powerbuilderParserRULE_condition_comparison                 = 40
	powerbuilderParserRULE_add_expr                             = 41
	powerbuilderParserRULE_mul_expr                             = 42
	powerbuilderParserRULE_unary_sign_expr                      = 43
	powerbuilderParserRULE_statement                            = 44
	powerbuilderParserRULE_statement_sub                        = 45
	powerbuilderParserRULE_assignment_sub                       = 46
	powerbuilderParserRULE_assignment_statement                 = 47
	powerbuilderParserRULE_lvalue_sub                           = 48
	powerbuilderParserRULE_return_sub                           = 49
	powerbuilderParserRULE_return_statement                     = 50
	powerbuilderParserRULE_function_call_expression_sub         = 51
	powerbuilderParserRULE_function_virtual_call_expression_sub = 52
	powerbuilderParserRULE_open_call_sub                        = 53
	powerbuilderParserRULE_close_call_sub                       = 54
	powerbuilderParserRULE_function_call_statement              = 55
	powerbuilderParserRULE_super_call_sub                       = 56
	powerbuilderParserRULE_super_call_statement                 = 57
	powerbuilderParserRULE_event_call_statement_sub             = 58
	powerbuilderParserRULE_event_call_statement                 = 59
	powerbuilderParserRULE_create_call_sub                      = 60
	powerbuilderParserRULE_create_call_statement                = 61
	powerbuilderParserRULE_destroy_call_sub                     = 62
	powerbuilderParserRULE_destroy_call_statement               = 63
	powerbuilderParserRULE_for_loop_statement                   = 64
	powerbuilderParserRULE_do_while_loop_statement              = 65
	powerbuilderParserRULE_do_loop_while_statement              = 66
	powerbuilderParserRULE_if_statement                         = 67
	powerbuilderParserRULE_if_simple_statement                  = 68
	powerbuilderParserRULE_continue_sub                         = 69
	powerbuilderParserRULE_continue_statement                   = 70
	powerbuilderParserRULE_post_event_sub                       = 71
	powerbuilderParserRULE_post_event                           = 72
	powerbuilderParserRULE_exit_statement_sub                   = 73
	powerbuilderParserRULE_exit_statement                       = 74
	powerbuilderParserRULE_choose_statement                     = 75
	powerbuilderParserRULE_choose_case_value_sub                = 76
	powerbuilderParserRULE_choose_case_cond_sub                 = 77
	powerbuilderParserRULE_choose_case_range_sub                = 78
	powerbuilderParserRULE_choose_case_else_sub                 = 79
	powerbuilderParserRULE_goto_stat_sub                        = 80
	powerbuilderParserRULE_goto_stat                            = 81
	powerbuilderParserRULE_label_stat                           = 82
	powerbuilderParserRULE_try_catch_block                      = 83
	powerbuilderParserRULE_throw_stat_sub                       = 84
	powerbuilderParserRULE_throw_stat                           = 85
	powerbuilderParserRULE_identifier                           = 86
	powerbuilderParserRULE_identifier_name                      = 87
	powerbuilderParserRULE_identifier_name_ex                   = 88
	powerbuilderParserRULE_atom_sub                             = 89
	powerbuilderParserRULE_atom_sub_call1                       = 90
	powerbuilderParserRULE_atom_sub_array1                      = 91
	powerbuilderParserRULE_atom_sub_ref1                        = 92
	powerbuilderParserRULE_atom_sub_member1                     = 93
	powerbuilderParserRULE_atom                                 = 94
	powerbuilderParserRULE_array_access_atom                    = 95
	powerbuilderParserRULE_numeric_atom                         = 96
	powerbuilderParserRULE_boolean_atom                         = 97
	powerbuilderParserRULE_cast_expression                      = 98
	powerbuilderParserRULE_data_type_sub                        = 99
	powerbuilderParserRULE_data_type_name                       = 100
)

// IStart_ruleContext is an interface to support dynamic dispatch.
type IStart_ruleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStart_ruleContext differentiates from other interfaces.
	IsStart_ruleContext()
}

type Start_ruleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStart_ruleContext() *Start_ruleContext {
	var p = new(Start_ruleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_start_rule
	return p
}

func (*Start_ruleContext) IsStart_ruleContext() {}

func NewStart_ruleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Start_ruleContext {
	var p = new(Start_ruleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_start_rule

	return p
}

func (s *Start_ruleContext) GetParser() antlr.Parser { return s.parser }

func (s *Start_ruleContext) EOF() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEOF, 0)
}

func (s *Start_ruleContext) Header_rule() IHeader_ruleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHeader_ruleContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHeader_ruleContext)
}

func (s *Start_ruleContext) AllBody_rule() []IBody_ruleContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBody_ruleContext)(nil)).Elem())
	var tst = make([]IBody_ruleContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBody_ruleContext)
		}
	}

	return tst
}

func (s *Start_ruleContext) Body_rule(i int) IBody_ruleContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBody_ruleContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBody_ruleContext)
}

func (s *Start_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Start_ruleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Start_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterStart_rule(s)
	}
}

func (s *Start_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitStart_rule(s)
	}
}

func (p *powerbuilderParser) Start_rule() (localctx IStart_ruleContext) {
	localctx = NewStart_ruleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, powerbuilderParserRULE_start_rule)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(203)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 0, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(202)
			p.Header_rule()
		}

	}
	p.SetState(206)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserGLOBAL)|(1<<powerbuilderParserSHARED)|(1<<powerbuilderParserINDIRECT)|(1<<powerbuilderParserFORWARD)|(1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserFUNCTION)|(1<<powerbuilderParserSUBROUTINE)|(1<<powerbuilderParserTYPE)|(1<<powerbuilderParserON)|(1<<powerbuilderParserPRIVATEWRITE)|(1<<powerbuilderParserPROTECTED)|(1<<powerbuilderParserPRIVATEREAD)|(1<<powerbuilderParserPROTECTEDREAD)|(1<<powerbuilderParserPROTECTEDWRITE)|(1<<powerbuilderParserLOCAL)|(1<<powerbuilderParserEVENT))) != 0) || _la == powerbuilderParserSEMI {
		{
			p.SetState(205)
			p.Body_rule()
		}

		p.SetState(208)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(210)
		p.Match(powerbuilderParserEOF)
	}

	return localctx
}

// IHeader_ruleContext is an interface to support dynamic dispatch.
type IHeader_ruleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHeader_ruleContext differentiates from other interfaces.
	IsHeader_ruleContext()
}

type Header_ruleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHeader_ruleContext() *Header_ruleContext {
	var p = new(Header_ruleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_header_rule
	return p
}

func (*Header_ruleContext) IsHeader_ruleContext() {}

func NewHeader_ruleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Header_ruleContext {
	var p = new(Header_ruleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_header_rule

	return p
}

func (s *Header_ruleContext) GetParser() antlr.Parser { return s.parser }

func (s *Header_ruleContext) AllExport_header() []IExport_headerContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExport_headerContext)(nil)).Elem())
	var tst = make([]IExport_headerContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExport_headerContext)
		}
	}

	return tst
}

func (s *Header_ruleContext) Export_header(i int) IExport_headerContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExport_headerContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExport_headerContext)
}

func (s *Header_ruleContext) Release_information() IRelease_informationContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IRelease_informationContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IRelease_informationContext)
}

func (s *Header_ruleContext) AllWindow_property_line() []IWindow_property_lineContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWindow_property_lineContext)(nil)).Elem())
	var tst = make([]IWindow_property_lineContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWindow_property_lineContext)
		}
	}

	return tst
}

func (s *Header_ruleContext) Window_property_line(i int) IWindow_property_lineContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindow_property_lineContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWindow_property_lineContext)
}

func (s *Header_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Header_ruleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Header_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterHeader_rule(s)
	}
}

func (s *Header_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitHeader_rule(s)
	}
}

func (p *powerbuilderParser) Header_rule() (localctx IHeader_ruleContext) {
	localctx = NewHeader_ruleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, powerbuilderParserRULE_header_rule)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(215)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == powerbuilderParserEXPORT_HEADER {
		{
			p.SetState(212)
			p.Export_header()
		}

		p.SetState(217)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(219)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserRELEASE {
		{
			p.SetState(218)
			p.Release_information()
		}

	}
	p.SetState(224)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(221)
				p.Window_property_line()
			}

		}
		p.SetState(226)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext())
	}

	return localctx
}

// IBody_ruleContext is an interface to support dynamic dispatch.
type IBody_ruleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBody_ruleContext differentiates from other interfaces.
	IsBody_ruleContext()
}

type Body_ruleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBody_ruleContext() *Body_ruleContext {
	var p = new(Body_ruleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_body_rule
	return p
}

func (*Body_ruleContext) IsBody_ruleContext() {}

func NewBody_ruleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Body_ruleContext {
	var p = new(Body_ruleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_body_rule

	return p
}

func (s *Body_ruleContext) GetParser() antlr.Parser { return s.parser }

func (s *Body_ruleContext) Datatype_decl() IDatatype_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatatype_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDatatype_declContext)
}

func (s *Body_ruleContext) Access_modif() IAccess_modifContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAccess_modifContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAccess_modifContext)
}

func (s *Body_ruleContext) Forward_decl() IForward_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IForward_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IForward_declContext)
}

func (s *Body_ruleContext) Type_variables_decl() IType_variables_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IType_variables_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IType_variables_declContext)
}

func (s *Body_ruleContext) Global_variables_decl() IGlobal_variables_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGlobal_variables_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGlobal_variables_declContext)
}

func (s *Body_ruleContext) Variable_decl() IVariable_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_declContext)
}

func (s *Body_ruleContext) Constant_decl() IConstant_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_declContext)
}

func (s *Body_ruleContext) Function_forward_decl() IFunction_forward_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_forward_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_forward_declContext)
}

func (s *Body_ruleContext) Functions_forward_decl() IFunctions_forward_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunctions_forward_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunctions_forward_declContext)
}

func (s *Body_ruleContext) Function_body() IFunction_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_bodyContext)
}

func (s *Body_ruleContext) On_body() IOn_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOn_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOn_bodyContext)
}

func (s *Body_ruleContext) Event_body() IEvent_bodyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_bodyContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_bodyContext)
}

func (s *Body_ruleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Body_ruleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Body_ruleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterBody_rule(s)
	}
}

func (s *Body_ruleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitBody_rule(s)
	}
}

func (p *powerbuilderParser) Body_rule() (localctx IBody_ruleContext) {
	localctx = NewBody_ruleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, powerbuilderParserRULE_body_rule)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(239)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(227)
			p.Datatype_decl()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(228)
			p.Access_modif()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(229)
			p.Forward_decl()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(230)
			p.Type_variables_decl()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(231)
			p.Global_variables_decl()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(232)
			p.Variable_decl()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(233)
			p.Constant_decl()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(234)
			p.Function_forward_decl()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(235)
			p.Functions_forward_decl()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(236)
			p.Function_body()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(237)
			p.On_body()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(238)
			p.Event_body()
		}

	}

	return localctx
}

// IExport_headerContext is an interface to support dynamic dispatch.
type IExport_headerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExport_headerContext differentiates from other interfaces.
	IsExport_headerContext()
}

type Export_headerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExport_headerContext() *Export_headerContext {
	var p = new(Export_headerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_export_header
	return p
}

func (*Export_headerContext) IsExport_headerContext() {}

func NewExport_headerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Export_headerContext {
	var p = new(Export_headerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_export_header

	return p
}

func (s *Export_headerContext) GetParser() antlr.Parser { return s.parser }

func (s *Export_headerContext) EXPORT_HEADER() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEXPORT_HEADER, 0)
}

func (s *Export_headerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Export_headerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Export_headerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterExport_header(s)
	}
}

func (s *Export_headerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitExport_header(s)
	}
}

func (p *powerbuilderParser) Export_header() (localctx IExport_headerContext) {
	localctx = NewExport_headerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, powerbuilderParserRULE_export_header)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(241)
		p.Match(powerbuilderParserEXPORT_HEADER)
	}

	return localctx
}

// IRelease_informationContext is an interface to support dynamic dispatch.
type IRelease_informationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelease_informationContext differentiates from other interfaces.
	IsRelease_informationContext()
}

type Release_informationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelease_informationContext() *Release_informationContext {
	var p = new(Release_informationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_release_information
	return p
}

func (*Release_informationContext) IsRelease_informationContext() {}

func NewRelease_informationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Release_informationContext {
	var p = new(Release_informationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_release_information

	return p
}

func (s *Release_informationContext) GetParser() antlr.Parser { return s.parser }

func (s *Release_informationContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRELEASE, 0)
}

func (s *Release_informationContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserNUMBER, 0)
}

func (s *Release_informationContext) SEMI() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserSEMI, 0)
}

func (s *Release_informationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Release_informationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Release_informationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterRelease_information(s)
	}
}

func (s *Release_informationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitRelease_information(s)
	}
}

func (p *powerbuilderParser) Release_information() (localctx IRelease_informationContext) {
	localctx = NewRelease_informationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, powerbuilderParserRULE_release_information)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(243)
		p.Match(powerbuilderParserRELEASE)
	}
	{
		p.SetState(244)
		p.Match(powerbuilderParserNUMBER)
	}
	{
		p.SetState(245)
		p.Match(powerbuilderParserSEMI)
	}

	return localctx
}

// IWindow_property_lineContext is an interface to support dynamic dispatch.
type IWindow_property_lineContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWindow_property_lineContext differentiates from other interfaces.
	IsWindow_property_lineContext()
}

type Window_property_lineContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_property_lineContext() *Window_property_lineContext {
	var p = new(Window_property_lineContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_window_property_line
	return p
}

func (*Window_property_lineContext) IsWindow_property_lineContext() {}

func NewWindow_property_lineContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_property_lineContext {
	var p = new(Window_property_lineContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_window_property_line

	return p
}

func (s *Window_property_lineContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_property_lineContext) AllWindow_property() []IWindow_propertyContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWindow_propertyContext)(nil)).Elem())
	var tst = make([]IWindow_propertyContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWindow_propertyContext)
		}
	}

	return tst
}

func (s *Window_property_lineContext) Window_property(i int) IWindow_propertyContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindow_propertyContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWindow_propertyContext)
}

func (s *Window_property_lineContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_property_lineContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_property_lineContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterWindow_property_line(s)
	}
}

func (s *Window_property_lineContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitWindow_property_line(s)
	}
}

func (p *powerbuilderParser) Window_property_line() (localctx IWindow_property_lineContext) {
	localctx = NewWindow_property_lineContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, powerbuilderParserRULE_window_property_line)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(248)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(247)
				p.Window_property()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(250)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 6, p.GetParserRuleContext())
	}

	return localctx
}

// IWindow_propertyContext is an interface to support dynamic dispatch.
type IWindow_propertyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWindow_propertyContext differentiates from other interfaces.
	IsWindow_propertyContext()
}

type Window_propertyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_propertyContext() *Window_propertyContext {
	var p = new(Window_propertyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_window_property
	return p
}

func (*Window_propertyContext) IsWindow_propertyContext() {}

func NewWindow_propertyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_propertyContext {
	var p = new(Window_propertyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_window_property

	return p
}

func (s *Window_propertyContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_propertyContext) Attribute_name() IAttribute_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_nameContext)
}

func (s *Window_propertyContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLPAREN, 0)
}

func (s *Window_propertyContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRPAREN, 0)
}

func (s *Window_propertyContext) Array_decl_sub() IArray_decl_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_decl_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_decl_subContext)
}

func (s *Window_propertyContext) Window_property_attributes_sub() IWindow_property_attributes_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindow_property_attributes_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindow_property_attributes_subContext)
}

func (s *Window_propertyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_propertyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_propertyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterWindow_property(s)
	}
}

func (s *Window_propertyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitWindow_property(s)
	}
}

func (p *powerbuilderParser) Window_property() (localctx IWindow_propertyContext) {
	localctx = NewWindow_propertyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, powerbuilderParserRULE_window_property)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(252)
		p.Attribute_name()
	}
	p.SetState(254)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserLBRACE || _la == powerbuilderParserBRACES {
		{
			p.SetState(253)
			p.Array_decl_sub()
		}

	}
	{
		p.SetState(256)
		p.Match(powerbuilderParserLPAREN)
	}
	p.SetState(258)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserTYPE)|(1<<powerbuilderParserNULL)|(1<<powerbuilderParserUPDATE))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(powerbuilderParserDQUOTED_STRING-101))|(1<<(powerbuilderParserID-101))|(1<<(powerbuilderParserNUMBER-101))|(1<<(powerbuilderParserDATE-101))|(1<<(powerbuilderParserTIME-101)))) != 0) {
		{
			p.SetState(257)
			p.Window_property_attributes_sub()
		}

	}
	{
		p.SetState(260)
		p.Match(powerbuilderParserRPAREN)
	}

	return localctx
}

// IWindow_property_attributes_subContext is an interface to support dynamic dispatch.
type IWindow_property_attributes_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWindow_property_attributes_subContext differentiates from other interfaces.
	IsWindow_property_attributes_subContext()
}

type Window_property_attributes_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindow_property_attributes_subContext() *Window_property_attributes_subContext {
	var p = new(Window_property_attributes_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_window_property_attributes_sub
	return p
}

func (*Window_property_attributes_subContext) IsWindow_property_attributes_subContext() {}

func NewWindow_property_attributes_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_property_attributes_subContext {
	var p = new(Window_property_attributes_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_window_property_attributes_sub

	return p
}

func (s *Window_property_attributes_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_property_attributes_subContext) AllWindow_property_attribute_sub() []IWindow_property_attribute_subContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWindow_property_attribute_subContext)(nil)).Elem())
	var tst = make([]IWindow_property_attribute_subContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWindow_property_attribute_subContext)
		}
	}

	return tst
}

func (s *Window_property_attributes_subContext) Window_property_attribute_sub(i int) IWindow_property_attribute_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindow_property_attribute_subContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWindow_property_attribute_subContext)
}

func (s *Window_property_attributes_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_property_attributes_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_property_attributes_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterWindow_property_attributes_sub(s)
	}
}

func (s *Window_property_attributes_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitWindow_property_attributes_sub(s)
	}
}

func (p *powerbuilderParser) Window_property_attributes_sub() (localctx IWindow_property_attributes_subContext) {
	localctx = NewWindow_property_attributes_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, powerbuilderParserRULE_window_property_attributes_sub)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(263)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserTYPE)|(1<<powerbuilderParserNULL)|(1<<powerbuilderParserUPDATE))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(powerbuilderParserDQUOTED_STRING-101))|(1<<(powerbuilderParserID-101))|(1<<(powerbuilderParserNUMBER-101))|(1<<(powerbuilderParserDATE-101))|(1<<(powerbuilderParserTIME-101)))) != 0) {
		{
			p.SetState(262)
			p.Window_property_attribute_sub()
		}

		p.SetState(265)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IWindow_property_attribute_subContext is an interface to support dynamic dispatch.
type IWindow_property_attribute_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetEq returns the eq token.
	GetEq() antlr.Token

	// SetEq sets the eq token.
	SetEq(antlr.Token)

	// IsWindow_property_attribute_subContext differentiates from other interfaces.
	IsWindow_property_attribute_subContext()
}

type Window_property_attribute_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	eq     antlr.Token
}

func NewEmptyWindow_property_attribute_subContext() *Window_property_attribute_subContext {
	var p = new(Window_property_attribute_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_window_property_attribute_sub
	return p
}

func (*Window_property_attribute_subContext) IsWindow_property_attribute_subContext() {}

func NewWindow_property_attribute_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Window_property_attribute_subContext {
	var p = new(Window_property_attribute_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_window_property_attribute_sub

	return p
}

func (s *Window_property_attribute_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Window_property_attribute_subContext) GetEq() antlr.Token { return s.eq }

func (s *Window_property_attribute_subContext) SetEq(v antlr.Token) { s.eq = v }

func (s *Window_property_attribute_subContext) NULL() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserNULL, 0)
}

func (s *Window_property_attribute_subContext) Numeric_atom() INumeric_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeric_atomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeric_atomContext)
}

func (s *Window_property_attribute_subContext) DQUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDQUOTED_STRING, 0)
}

func (s *Window_property_attribute_subContext) DATE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDATE, 0)
}

func (s *Window_property_attribute_subContext) TIME() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTIME, 0)
}

func (s *Window_property_attribute_subContext) COMMA() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCOMMA, 0)
}

func (s *Window_property_attribute_subContext) Attribute_name() IAttribute_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_nameContext)
}

func (s *Window_property_attribute_subContext) EQ() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEQ, 0)
}

func (s *Window_property_attribute_subContext) Attribute_value() IAttribute_valueContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAttribute_valueContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAttribute_valueContext)
}

func (s *Window_property_attribute_subContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLPAREN, 0)
}

func (s *Window_property_attribute_subContext) Window_property_attributes_sub() IWindow_property_attributes_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWindow_property_attributes_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWindow_property_attributes_subContext)
}

func (s *Window_property_attribute_subContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRPAREN, 0)
}

func (s *Window_property_attribute_subContext) Array_decl_sub() IArray_decl_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_decl_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_decl_subContext)
}

func (s *Window_property_attribute_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Window_property_attribute_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Window_property_attribute_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterWindow_property_attribute_sub(s)
	}
}

func (s *Window_property_attribute_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitWindow_property_attribute_sub(s)
	}
}

func (p *powerbuilderParser) Window_property_attribute_sub() (localctx IWindow_property_attribute_subContext) {
	localctx = NewWindow_property_attribute_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, powerbuilderParserRULE_window_property_attribute_sub)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(292)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case powerbuilderParserNULL, powerbuilderParserDQUOTED_STRING, powerbuilderParserNUMBER, powerbuilderParserDATE, powerbuilderParserTIME:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(272)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case powerbuilderParserNULL:
			{
				p.SetState(267)
				p.Match(powerbuilderParserNULL)
			}

		case powerbuilderParserNUMBER:
			{
				p.SetState(268)
				p.Numeric_atom()
			}

		case powerbuilderParserDQUOTED_STRING:
			{
				p.SetState(269)
				p.Match(powerbuilderParserDQUOTED_STRING)
			}

		case powerbuilderParserDATE:
			{
				p.SetState(270)
				p.Match(powerbuilderParserDATE)
			}

		case powerbuilderParserTIME:
			{
				p.SetState(271)
				p.Match(powerbuilderParserTIME)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(275)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == powerbuilderParserCOMMA {
			{
				p.SetState(274)
				p.Match(powerbuilderParserCOMMA)
			}

		}

	case powerbuilderParserTYPE, powerbuilderParserUPDATE, powerbuilderParserID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(277)
			p.Attribute_name()
		}
		{
			p.SetState(278)

			var _m = p.Match(powerbuilderParserEQ)

			localctx.(*Window_property_attribute_subContext).eq = _m
		}
		p.SetState(287)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(279)
				p.Attribute_value()
			}
			p.SetState(281)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == powerbuilderParserLBRACE || _la == powerbuilderParserBRACES {
				{
					p.SetState(280)
					p.Array_decl_sub()
				}

			}

		case 2:
			{
				p.SetState(283)
				p.Match(powerbuilderParserLPAREN)
			}
			{
				p.SetState(284)
				p.Window_property_attributes_sub()
			}
			{
				p.SetState(285)
				p.Match(powerbuilderParserRPAREN)
			}

		}

		p.SetState(290)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == powerbuilderParserCOMMA {
			{
				p.SetState(289)
				p.Match(powerbuilderParserCOMMA)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAttribute_nameContext is an interface to support dynamic dispatch.
type IAttribute_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribute_nameContext differentiates from other interfaces.
	IsAttribute_nameContext()
}

type Attribute_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_nameContext() *Attribute_nameContext {
	var p = new(Attribute_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_attribute_name
	return p
}

func (*Attribute_nameContext) IsAttribute_nameContext() {}

func NewAttribute_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_nameContext {
	var p = new(Attribute_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_attribute_name

	return p
}

func (s *Attribute_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_nameContext) AllIdentifier_name() []IIdentifier_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem())
	var tst = make([]IIdentifier_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifier_nameContext)
		}
	}

	return tst
}

func (s *Attribute_nameContext) Identifier_name(i int) IIdentifier_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_nameContext)
}

func (s *Attribute_nameContext) AllTYPE() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserTYPE)
}

func (s *Attribute_nameContext) TYPE(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTYPE, i)
}

func (s *Attribute_nameContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserUPDATE, 0)
}

func (s *Attribute_nameContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserNUMBER, 0)
}

func (s *Attribute_nameContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserDOT)
}

func (s *Attribute_nameContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDOT, i)
}

func (s *Attribute_nameContext) AllCASE() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserCASE)
}

func (s *Attribute_nameContext) CASE(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCASE, i)
}

func (s *Attribute_nameContext) AllON() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserON)
}

func (s *Attribute_nameContext) ON(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserON, i)
}

func (s *Attribute_nameContext) AllDYNAMIC() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserDYNAMIC)
}

func (s *Attribute_nameContext) DYNAMIC(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDYNAMIC, i)
}

func (s *Attribute_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterAttribute_name(s)
	}
}

func (s *Attribute_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitAttribute_name(s)
	}
}

func (p *powerbuilderParser) Attribute_name() (localctx IAttribute_nameContext) {
	localctx = NewAttribute_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, powerbuilderParserRULE_attribute_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(297)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case powerbuilderParserID:
		{
			p.SetState(294)
			p.Identifier_name()
		}

	case powerbuilderParserTYPE:
		{
			p.SetState(295)
			p.Match(powerbuilderParserTYPE)
		}

	case powerbuilderParserUPDATE:
		{
			p.SetState(296)
			p.Match(powerbuilderParserUPDATE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(300)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserNUMBER {
		{
			p.SetState(299)
			p.Match(powerbuilderParserNUMBER)
		}

	}
	p.SetState(312)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == powerbuilderParserDOT {
		{
			p.SetState(302)
			p.Match(powerbuilderParserDOT)
		}
		p.SetState(308)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case powerbuilderParserID:
			{
				p.SetState(303)
				p.Identifier_name()
			}

		case powerbuilderParserCASE:
			{
				p.SetState(304)
				p.Match(powerbuilderParserCASE)
			}

		case powerbuilderParserTYPE:
			{
				p.SetState(305)
				p.Match(powerbuilderParserTYPE)
			}

		case powerbuilderParserON:
			{
				p.SetState(306)
				p.Match(powerbuilderParserON)
			}

		case powerbuilderParserDYNAMIC:
			{
				p.SetState(307)
				p.Match(powerbuilderParserDYNAMIC)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(314)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAttribute_valueContext is an interface to support dynamic dispatch.
type IAttribute_valueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAttribute_valueContext differentiates from other interfaces.
	IsAttribute_valueContext()
}

type Attribute_valueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAttribute_valueContext() *Attribute_valueContext {
	var p = new(Attribute_valueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_attribute_value
	return p
}

func (*Attribute_valueContext) IsAttribute_valueContext() {}

func NewAttribute_valueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Attribute_valueContext {
	var p = new(Attribute_valueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_attribute_value

	return p
}

func (s *Attribute_valueContext) GetParser() antlr.Parser { return s.parser }

func (s *Attribute_valueContext) Atom_sub_call1() IAtom_sub_call1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_sub_call1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_sub_call1Context)
}

func (s *Attribute_valueContext) Atom_sub_member1() IAtom_sub_member1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_sub_member1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_sub_member1Context)
}

func (s *Attribute_valueContext) Numeric_atom() INumeric_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeric_atomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeric_atomContext)
}

func (s *Attribute_valueContext) MINUS() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserMINUS, 0)
}

func (s *Attribute_valueContext) Boolean_atom() IBoolean_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBoolean_atomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBoolean_atomContext)
}

func (s *Attribute_valueContext) ENUM() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserENUM, 0)
}

func (s *Attribute_valueContext) DQUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDQUOTED_STRING, 0)
}

func (s *Attribute_valueContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserQUOTED_STRING, 0)
}

func (s *Attribute_valueContext) DATE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDATE, 0)
}

func (s *Attribute_valueContext) TIME() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTIME, 0)
}

func (s *Attribute_valueContext) TYPE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTYPE, 0)
}

func (s *Attribute_valueContext) TO() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTO, 0)
}

func (s *Attribute_valueContext) FROM() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserFROM, 0)
}

func (s *Attribute_valueContext) REF() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserREF, 0)
}

func (s *Attribute_valueContext) NULL() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserNULL, 0)
}

func (s *Attribute_valueContext) OPEN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserOPEN, 0)
}

func (s *Attribute_valueContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserLPAREN)
}

func (s *Attribute_valueContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLPAREN, i)
}

func (s *Attribute_valueContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserRPAREN)
}

func (s *Attribute_valueContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRPAREN, i)
}

func (s *Attribute_valueContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Attribute_valueContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Attribute_valueContext) AllData_type_sub() []IData_type_subContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IData_type_subContext)(nil)).Elem())
	var tst = make([]IData_type_subContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IData_type_subContext)
		}
	}

	return tst
}

func (s *Attribute_valueContext) Data_type_sub(i int) IData_type_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_subContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IData_type_subContext)
}

func (s *Attribute_valueContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserCOMMA)
}

func (s *Attribute_valueContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCOMMA, i)
}

func (s *Attribute_valueContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserNUMBER, 0)
}

func (s *Attribute_valueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Attribute_valueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Attribute_valueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterAttribute_value(s)
	}
}

func (s *Attribute_valueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitAttribute_value(s)
	}
}

func (p *powerbuilderParser) Attribute_value() (localctx IAttribute_valueContext) {
	localctx = NewAttribute_valueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, powerbuilderParserRULE_attribute_value)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(375)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 29, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(315)
			p.Atom_sub_call1()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(316)
			p.Atom_sub_member1()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(318)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == powerbuilderParserMINUS {
			{
				p.SetState(317)
				p.Match(powerbuilderParserMINUS)
			}

		}
		{
			p.SetState(320)
			p.Numeric_atom()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(321)
			p.Boolean_atom()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(322)
			p.Match(powerbuilderParserENUM)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(323)
			p.Match(powerbuilderParserDQUOTED_STRING)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(324)
			p.Match(powerbuilderParserQUOTED_STRING)
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(325)
			p.Match(powerbuilderParserDATE)
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(326)
			p.Match(powerbuilderParserTIME)
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(327)
			p.Match(powerbuilderParserTYPE)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(328)
			p.Match(powerbuilderParserTO)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(329)
			p.Match(powerbuilderParserFROM)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(330)
			p.Match(powerbuilderParserREF)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(331)
			p.Match(powerbuilderParserNULL)
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(332)
			p.Match(powerbuilderParserOPEN)
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(333)
			p.Match(powerbuilderParserLPAREN)
		}
		{
			p.SetState(334)
			p.Match(powerbuilderParserLPAREN)
		}
		p.SetState(337)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case powerbuilderParserCLOSE, powerbuilderParserHALT, powerbuilderParserLCURLY:
			{
				p.SetState(335)
				p.Expression()
			}

		case powerbuilderParserDATA_TYPE_SUB:
			{
				p.SetState(336)
				p.Data_type_sub()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(344)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == powerbuilderParserCOMMA {
			{
				p.SetState(339)
				p.Match(powerbuilderParserCOMMA)
			}
			p.SetState(342)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case powerbuilderParserCLOSE, powerbuilderParserHALT, powerbuilderParserLCURLY:
				{
					p.SetState(340)
					p.Expression()
				}

			case powerbuilderParserDATA_TYPE_SUB:
				{
					p.SetState(341)
					p.Data_type_sub()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		{
			p.SetState(346)
			p.Match(powerbuilderParserRPAREN)
		}
		p.SetState(364)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == powerbuilderParserCOMMA {
			{
				p.SetState(347)
				p.Match(powerbuilderParserCOMMA)
			}
			{
				p.SetState(348)
				p.Match(powerbuilderParserLPAREN)
			}
			p.SetState(351)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case powerbuilderParserCLOSE, powerbuilderParserHALT, powerbuilderParserLCURLY:
				{
					p.SetState(349)
					p.Expression()
				}

			case powerbuilderParserDATA_TYPE_SUB:
				{
					p.SetState(350)
					p.Data_type_sub()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}
			p.SetState(358)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == powerbuilderParserCOMMA {
				{
					p.SetState(353)
					p.Match(powerbuilderParserCOMMA)
				}
				p.SetState(356)
				p.GetErrorHandler().Sync(p)

				switch p.GetTokenStream().LA(1) {
				case powerbuilderParserCLOSE, powerbuilderParserHALT, powerbuilderParserLCURLY:
					{
						p.SetState(354)
						p.Expression()
					}

				case powerbuilderParserDATA_TYPE_SUB:
					{
						p.SetState(355)
						p.Data_type_sub()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

			}
			{
				p.SetState(360)
				p.Match(powerbuilderParserRPAREN)
			}

			p.SetState(366)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(367)
			p.Match(powerbuilderParserRPAREN)
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(369)
			p.Data_type_sub()
		}
		p.SetState(373)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == powerbuilderParserLPAREN {
			{
				p.SetState(370)
				p.Match(powerbuilderParserLPAREN)
			}
			{
				p.SetState(371)
				p.Match(powerbuilderParserNUMBER)
			}
			{
				p.SetState(372)
				p.Match(powerbuilderParserRPAREN)
			}

		}

	}

	return localctx
}

// IForward_declContext is an interface to support dynamic dispatch.
type IForward_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsForward_declContext differentiates from other interfaces.
	IsForward_declContext()
}

type Forward_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyForward_declContext() *Forward_declContext {
	var p = new(Forward_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_forward_decl
	return p
}

func (*Forward_declContext) IsForward_declContext() {}

func NewForward_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Forward_declContext {
	var p = new(Forward_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_forward_decl

	return p
}

func (s *Forward_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Forward_declContext) AllFORWARD() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserFORWARD)
}

func (s *Forward_declContext) FORWARD(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserFORWARD, i)
}

func (s *Forward_declContext) END() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEND, 0)
}

func (s *Forward_declContext) AllDatatype_decl() []IDatatype_declContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDatatype_declContext)(nil)).Elem())
	var tst = make([]IDatatype_declContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDatatype_declContext)
		}
	}

	return tst
}

func (s *Forward_declContext) Datatype_decl(i int) IDatatype_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDatatype_declContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDatatype_declContext)
}

func (s *Forward_declContext) AllVariable_decl() []IVariable_declContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_declContext)(nil)).Elem())
	var tst = make([]IVariable_declContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_declContext)
		}
	}

	return tst
}

func (s *Forward_declContext) Variable_decl(i int) IVariable_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_declContext)
}

func (s *Forward_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Forward_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Forward_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterForward_decl(s)
	}
}

func (s *Forward_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitForward_decl(s)
	}
}

func (p *powerbuilderParser) Forward_decl() (localctx IForward_declContext) {
	localctx = NewForward_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, powerbuilderParserRULE_forward_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(377)
		p.Match(powerbuilderParserFORWARD)
	}
	p.SetState(380)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserGLOBAL)|(1<<powerbuilderParserINDIRECT)|(1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserTYPE)|(1<<powerbuilderParserPRIVATEWRITE)|(1<<powerbuilderParserPROTECTED)|(1<<powerbuilderParserPRIVATEREAD)|(1<<powerbuilderParserPROTECTEDREAD)|(1<<powerbuilderParserPROTECTEDWRITE)|(1<<powerbuilderParserLOCAL))) != 0) || _la == powerbuilderParserSEMI {
		p.SetState(380)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 30, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(378)
				p.Datatype_decl()
			}

		case 2:
			{
				p.SetState(379)
				p.Variable_decl()
			}

		}

		p.SetState(382)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(384)
		p.Match(powerbuilderParserEND)
	}
	{
		p.SetState(385)
		p.Match(powerbuilderParserFORWARD)
	}

	return localctx
}

// IDatatype_declContext is an interface to support dynamic dispatch.
type IDatatype_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDatatype_declContext differentiates from other interfaces.
	IsDatatype_declContext()
}

type Datatype_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDatatype_declContext() *Datatype_declContext {
	var p = new(Datatype_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_datatype_decl
	return p
}

func (*Datatype_declContext) IsDatatype_declContext() {}

func NewDatatype_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Datatype_declContext {
	var p = new(Datatype_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_datatype_decl

	return p
}

func (s *Datatype_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Datatype_declContext) AllTYPE() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserTYPE)
}

func (s *Datatype_declContext) TYPE(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTYPE, i)
}

func (s *Datatype_declContext) AllIdentifier_name() []IIdentifier_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem())
	var tst = make([]IIdentifier_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifier_nameContext)
		}
	}

	return tst
}

func (s *Datatype_declContext) Identifier_name(i int) IIdentifier_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_nameContext)
}

func (s *Datatype_declContext) FROM() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserFROM, 0)
}

func (s *Datatype_declContext) Data_type_name() IData_type_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_nameContext)
}

func (s *Datatype_declContext) END() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEND, 0)
}

func (s *Datatype_declContext) Scope_modif() IScope_modifContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScope_modifContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScope_modifContext)
}

func (s *Datatype_declContext) TICK() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTICK, 0)
}

func (s *Datatype_declContext) WITHIN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserWITHIN, 0)
}

func (s *Datatype_declContext) AUTOINSTANTIATE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserAUTOINSTANTIATE, 0)
}

func (s *Datatype_declContext) DESCRIPTOR() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDESCRIPTOR, 0)
}

func (s *Datatype_declContext) AllDQUOTED_STRING() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserDQUOTED_STRING)
}

func (s *Datatype_declContext) DQUOTED_STRING(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDQUOTED_STRING, i)
}

func (s *Datatype_declContext) EQ() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEQ, 0)
}

func (s *Datatype_declContext) AllVariable_decl() []IVariable_declContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_declContext)(nil)).Elem())
	var tst = make([]IVariable_declContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_declContext)
		}
	}

	return tst
}

func (s *Datatype_declContext) Variable_decl(i int) IVariable_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_declContext)
}

func (s *Datatype_declContext) AllEvent_forward_decl() []IEvent_forward_declContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IEvent_forward_declContext)(nil)).Elem())
	var tst = make([]IEvent_forward_declContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IEvent_forward_declContext)
		}
	}

	return tst
}

func (s *Datatype_declContext) Event_forward_decl(i int) IEvent_forward_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_forward_declContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IEvent_forward_declContext)
}

func (s *Datatype_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Datatype_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Datatype_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterDatatype_decl(s)
	}
}

func (s *Datatype_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitDatatype_decl(s)
	}
}

func (p *powerbuilderParser) Datatype_decl() (localctx IDatatype_declContext) {
	localctx = NewDatatype_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, powerbuilderParserRULE_datatype_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(388)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserGLOBAL || _la == powerbuilderParserLOCAL {
		{
			p.SetState(387)
			p.Scope_modif()
		}

	}
	{
		p.SetState(390)
		p.Match(powerbuilderParserTYPE)
	}
	{
		p.SetState(391)
		p.Identifier_name()
	}
	{
		p.SetState(392)
		p.Match(powerbuilderParserFROM)
	}
	p.SetState(396)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(393)
			p.Identifier_name()
		}
		{
			p.SetState(394)
			p.Match(powerbuilderParserTICK)
		}

	}
	{
		p.SetState(398)
		p.Data_type_name()
	}
	p.SetState(401)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserWITHIN {
		{
			p.SetState(399)
			p.Match(powerbuilderParserWITHIN)
		}
		{
			p.SetState(400)
			p.Identifier_name()
		}

	}
	p.SetState(404)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserAUTOINSTANTIATE {
		{
			p.SetState(403)
			p.Match(powerbuilderParserAUTOINSTANTIATE)
		}

	}
	p.SetState(410)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserDESCRIPTOR {
		{
			p.SetState(406)
			p.Match(powerbuilderParserDESCRIPTOR)
		}
		{
			p.SetState(407)
			p.Match(powerbuilderParserDQUOTED_STRING)
		}
		{
			p.SetState(408)
			p.Match(powerbuilderParserEQ)
		}
		{
			p.SetState(409)
			p.Match(powerbuilderParserDQUOTED_STRING)
		}

	}
	p.SetState(416)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserGLOBAL)|(1<<powerbuilderParserINDIRECT)|(1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserPRIVATEWRITE)|(1<<powerbuilderParserPROTECTED)|(1<<powerbuilderParserPRIVATEREAD)|(1<<powerbuilderParserPROTECTEDREAD)|(1<<powerbuilderParserPROTECTEDWRITE)|(1<<powerbuilderParserLOCAL)|(1<<powerbuilderParserEVENT))) != 0) || _la == powerbuilderParserSEMI {
		p.SetState(414)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case powerbuilderParserGLOBAL, powerbuilderParserINDIRECT, powerbuilderParserPUBLIC, powerbuilderParserPRIVATE, powerbuilderParserPRIVATEWRITE, powerbuilderParserPROTECTED, powerbuilderParserPRIVATEREAD, powerbuilderParserPROTECTEDREAD, powerbuilderParserPROTECTEDWRITE, powerbuilderParserLOCAL, powerbuilderParserSEMI:
			{
				p.SetState(412)
				p.Variable_decl()
			}

		case powerbuilderParserEVENT:
			{
				p.SetState(413)
				p.Event_forward_decl()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(418)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(419)
		p.Match(powerbuilderParserEND)
	}
	{
		p.SetState(420)
		p.Match(powerbuilderParserTYPE)
	}

	return localctx
}

// IType_variables_declContext is an interface to support dynamic dispatch.
type IType_variables_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsType_variables_declContext differentiates from other interfaces.
	IsType_variables_declContext()
}

type Type_variables_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyType_variables_declContext() *Type_variables_declContext {
	var p = new(Type_variables_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_type_variables_decl
	return p
}

func (*Type_variables_declContext) IsType_variables_declContext() {}

func NewType_variables_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Type_variables_declContext {
	var p = new(Type_variables_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_type_variables_decl

	return p
}

func (s *Type_variables_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Type_variables_declContext) TYPE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTYPE, 0)
}

func (s *Type_variables_declContext) AllVARIABLES() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserVARIABLES)
}

func (s *Type_variables_declContext) VARIABLES(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserVARIABLES, i)
}

func (s *Type_variables_declContext) END() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEND, 0)
}

func (s *Type_variables_declContext) AllAccess_modif() []IAccess_modifContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAccess_modifContext)(nil)).Elem())
	var tst = make([]IAccess_modifContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAccess_modifContext)
		}
	}

	return tst
}

func (s *Type_variables_declContext) Access_modif(i int) IAccess_modifContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAccess_modifContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAccess_modifContext)
}

func (s *Type_variables_declContext) AllVariable_decl() []IVariable_declContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_declContext)(nil)).Elem())
	var tst = make([]IVariable_declContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_declContext)
		}
	}

	return tst
}

func (s *Type_variables_declContext) Variable_decl(i int) IVariable_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_declContext)
}

func (s *Type_variables_declContext) AllConstant_decl() []IConstant_declContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_declContext)(nil)).Elem())
	var tst = make([]IConstant_declContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_declContext)
		}
	}

	return tst
}

func (s *Type_variables_declContext) Constant_decl(i int) IConstant_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_declContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_declContext)
}

func (s *Type_variables_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Type_variables_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Type_variables_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterType_variables_decl(s)
	}
}

func (s *Type_variables_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitType_variables_decl(s)
	}
}

func (p *powerbuilderParser) Type_variables_decl() (localctx IType_variables_declContext) {
	localctx = NewType_variables_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, powerbuilderParserRULE_type_variables_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(422)
		p.Match(powerbuilderParserTYPE)
	}
	{
		p.SetState(423)
		p.Match(powerbuilderParserVARIABLES)
	}
	p.SetState(429)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserGLOBAL)|(1<<powerbuilderParserINDIRECT)|(1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserPRIVATEWRITE)|(1<<powerbuilderParserPROTECTED)|(1<<powerbuilderParserPRIVATEREAD)|(1<<powerbuilderParserPROTECTEDREAD)|(1<<powerbuilderParserPROTECTEDWRITE)|(1<<powerbuilderParserLOCAL))) != 0) || _la == powerbuilderParserSEMI {
		p.SetState(427)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(424)
				p.Access_modif()
			}

		case 2:
			{
				p.SetState(425)
				p.Variable_decl()
			}

		case 3:
			{
				p.SetState(426)
				p.Constant_decl()
			}

		}

		p.SetState(431)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(432)
		p.Match(powerbuilderParserEND)
	}
	{
		p.SetState(433)
		p.Match(powerbuilderParserVARIABLES)
	}

	return localctx
}

// IGlobal_variables_declContext is an interface to support dynamic dispatch.
type IGlobal_variables_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobal_variables_declContext differentiates from other interfaces.
	IsGlobal_variables_declContext()
}

type Global_variables_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobal_variables_declContext() *Global_variables_declContext {
	var p = new(Global_variables_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_global_variables_decl
	return p
}

func (*Global_variables_declContext) IsGlobal_variables_declContext() {}

func NewGlobal_variables_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Global_variables_declContext {
	var p = new(Global_variables_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_global_variables_decl

	return p
}

func (s *Global_variables_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Global_variables_declContext) AllVARIABLES() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserVARIABLES)
}

func (s *Global_variables_declContext) VARIABLES(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserVARIABLES, i)
}

func (s *Global_variables_declContext) END() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEND, 0)
}

func (s *Global_variables_declContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserGLOBAL, 0)
}

func (s *Global_variables_declContext) SHARED() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserSHARED, 0)
}

func (s *Global_variables_declContext) AllVariable_decl() []IVariable_declContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_declContext)(nil)).Elem())
	var tst = make([]IVariable_declContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_declContext)
		}
	}

	return tst
}

func (s *Global_variables_declContext) Variable_decl(i int) IVariable_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_declContext)
}

func (s *Global_variables_declContext) AllConstant_decl() []IConstant_declContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IConstant_declContext)(nil)).Elem())
	var tst = make([]IConstant_declContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IConstant_declContext)
		}
	}

	return tst
}

func (s *Global_variables_declContext) Constant_decl(i int) IConstant_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_declContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IConstant_declContext)
}

func (s *Global_variables_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Global_variables_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Global_variables_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterGlobal_variables_decl(s)
	}
}

func (s *Global_variables_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitGlobal_variables_decl(s)
	}
}

func (p *powerbuilderParser) Global_variables_decl() (localctx IGlobal_variables_declContext) {
	localctx = NewGlobal_variables_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, powerbuilderParserRULE_global_variables_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(435)
		_la = p.GetTokenStream().LA(1)

		if !(_la == powerbuilderParserGLOBAL || _la == powerbuilderParserSHARED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(436)
		p.Match(powerbuilderParserVARIABLES)
	}
	p.SetState(441)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserGLOBAL)|(1<<powerbuilderParserINDIRECT)|(1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserPRIVATEWRITE)|(1<<powerbuilderParserPROTECTED)|(1<<powerbuilderParserPRIVATEREAD)|(1<<powerbuilderParserPROTECTEDREAD)|(1<<powerbuilderParserPROTECTEDWRITE)|(1<<powerbuilderParserLOCAL))) != 0) || _la == powerbuilderParserSEMI {
		p.SetState(439)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 41, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(437)
				p.Variable_decl()
			}

		case 2:
			{
				p.SetState(438)
				p.Constant_decl()
			}

		}

		p.SetState(443)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(444)
		p.Match(powerbuilderParserEND)
	}
	{
		p.SetState(445)
		p.Match(powerbuilderParserVARIABLES)
	}

	return localctx
}

// IVariable_decl_subContext is an interface to support dynamic dispatch.
type IVariable_decl_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_decl_subContext differentiates from other interfaces.
	IsVariable_decl_subContext()
}

type Variable_decl_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_decl_subContext() *Variable_decl_subContext {
	var p = new(Variable_decl_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_variable_decl_sub
	return p
}

func (*Variable_decl_subContext) IsVariable_decl_subContext() {}

func NewVariable_decl_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_decl_subContext {
	var p = new(Variable_decl_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_variable_decl_sub

	return p
}

func (s *Variable_decl_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_decl_subContext) INDIRECT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserINDIRECT, 0)
}

func (s *Variable_decl_subContext) Access_modif_part() IAccess_modif_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAccess_modif_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAccess_modif_partContext)
}

func (s *Variable_decl_subContext) Scope_modif() IScope_modifContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScope_modifContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScope_modifContext)
}

func (s *Variable_decl_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_decl_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_decl_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterVariable_decl_sub(s)
	}
}

func (s *Variable_decl_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitVariable_decl_sub(s)
	}
}

func (p *powerbuilderParser) Variable_decl_sub() (localctx IVariable_decl_subContext) {
	localctx = NewVariable_decl_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, powerbuilderParserRULE_variable_decl_sub)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(448)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserINDIRECT {
		{
			p.SetState(447)
			p.Match(powerbuilderParserINDIRECT)
		}

	}
	p.SetState(451)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserPRIVATEWRITE)|(1<<powerbuilderParserPROTECTED)|(1<<powerbuilderParserPRIVATEREAD)|(1<<powerbuilderParserPROTECTEDREAD)|(1<<powerbuilderParserPROTECTEDWRITE))) != 0 {
		{
			p.SetState(450)
			p.Access_modif_part()
		}

	}
	p.SetState(454)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserGLOBAL || _la == powerbuilderParserLOCAL {
		{
			p.SetState(453)
			p.Scope_modif()
		}

	}

	return localctx
}

// IVariable_declContext is an interface to support dynamic dispatch.
type IVariable_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVariable_declContext differentiates from other interfaces.
	IsVariable_declContext()
}

type Variable_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariable_declContext() *Variable_declContext {
	var p = new(Variable_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_variable_decl
	return p
}

func (*Variable_declContext) IsVariable_declContext() {}

func NewVariable_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Variable_declContext {
	var p = new(Variable_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_variable_decl

	return p
}

func (s *Variable_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Variable_declContext) Variable_decl_sub() IVariable_decl_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_decl_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_decl_subContext)
}

func (s *Variable_declContext) SEMI() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserSEMI, 0)
}

func (s *Variable_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Variable_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Variable_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterVariable_decl(s)
	}
}

func (s *Variable_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitVariable_decl(s)
	}
}

func (p *powerbuilderParser) Variable_decl() (localctx IVariable_declContext) {
	localctx = NewVariable_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, powerbuilderParserRULE_variable_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(456)
		p.Variable_decl_sub()
	}

	{
		p.SetState(457)
		p.Match(powerbuilderParserSEMI)
	}

	return localctx
}

// IDecimal_decl_subContext is an interface to support dynamic dispatch.
type IDecimal_decl_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecimal_decl_subContext differentiates from other interfaces.
	IsDecimal_decl_subContext()
}

type Decimal_decl_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimal_decl_subContext() *Decimal_decl_subContext {
	var p = new(Decimal_decl_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_decimal_decl_sub
	return p
}

func (*Decimal_decl_subContext) IsDecimal_decl_subContext() {}

func NewDecimal_decl_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Decimal_decl_subContext {
	var p = new(Decimal_decl_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_decimal_decl_sub

	return p
}

func (s *Decimal_decl_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Decimal_decl_subContext) LCURLY() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLCURLY, 0)
}

func (s *Decimal_decl_subContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserNUMBER, 0)
}

func (s *Decimal_decl_subContext) RCURLY() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRCURLY, 0)
}

func (s *Decimal_decl_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Decimal_decl_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Decimal_decl_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterDecimal_decl_sub(s)
	}
}

func (s *Decimal_decl_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitDecimal_decl_sub(s)
	}
}

func (p *powerbuilderParser) Decimal_decl_sub() (localctx IDecimal_decl_subContext) {
	localctx = NewDecimal_decl_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, powerbuilderParserRULE_decimal_decl_sub)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(459)
		p.Match(powerbuilderParserLCURLY)
	}
	{
		p.SetState(460)
		p.Match(powerbuilderParserNUMBER)
	}
	{
		p.SetState(461)
		p.Match(powerbuilderParserRCURLY)
	}

	return localctx
}

// IArray_decl_subContext is an interface to support dynamic dispatch.
type IArray_decl_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_decl_subContext differentiates from other interfaces.
	IsArray_decl_subContext()
}

type Array_decl_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_decl_subContext() *Array_decl_subContext {
	var p = new(Array_decl_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_array_decl_sub
	return p
}

func (*Array_decl_subContext) IsArray_decl_subContext() {}

func NewArray_decl_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_decl_subContext {
	var p = new(Array_decl_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_array_decl_sub

	return p
}

func (s *Array_decl_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_decl_subContext) BRACES() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserBRACES, 0)
}

func (s *Array_decl_subContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLBRACE, 0)
}

func (s *Array_decl_subContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRBRACE, 0)
}

func (s *Array_decl_subContext) AllNUMBER() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserNUMBER)
}

func (s *Array_decl_subContext) NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserNUMBER, i)
}

func (s *Array_decl_subContext) AllTO() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserTO)
}

func (s *Array_decl_subContext) TO(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTO, i)
}

func (s *Array_decl_subContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserCOMMA)
}

func (s *Array_decl_subContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCOMMA, i)
}

func (s *Array_decl_subContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserPLUS)
}

func (s *Array_decl_subContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserPLUS, i)
}

func (s *Array_decl_subContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserMINUS)
}

func (s *Array_decl_subContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserMINUS, i)
}

func (s *Array_decl_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_decl_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_decl_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterArray_decl_sub(s)
	}
}

func (s *Array_decl_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitArray_decl_sub(s)
	}
}

func (p *powerbuilderParser) Array_decl_sub() (localctx IArray_decl_subContext) {
	localctx = NewArray_decl_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, powerbuilderParserRULE_array_decl_sub)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(496)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case powerbuilderParserBRACES:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(463)
			p.Match(powerbuilderParserBRACES)
		}

	case powerbuilderParserLBRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(464)
			p.Match(powerbuilderParserLBRACE)
		}
		p.SetState(493)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la-83)&-(0x1f+1)) == 0 && ((1<<uint((_la-83)))&((1<<(powerbuilderParserPLUS-83))|(1<<(powerbuilderParserMINUS-83))|(1<<(powerbuilderParserNUMBER-83)))) != 0 {
			p.SetState(466)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == powerbuilderParserPLUS || _la == powerbuilderParserMINUS {
				{
					p.SetState(465)
					_la = p.GetTokenStream().LA(1)

					if !(_la == powerbuilderParserPLUS || _la == powerbuilderParserMINUS) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}
			{
				p.SetState(468)
				p.Match(powerbuilderParserNUMBER)
			}
			p.SetState(474)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == powerbuilderParserTO {
				{
					p.SetState(469)
					p.Match(powerbuilderParserTO)
				}
				p.SetState(471)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == powerbuilderParserPLUS || _la == powerbuilderParserMINUS {
					{
						p.SetState(470)
						_la = p.GetTokenStream().LA(1)

						if !(_la == powerbuilderParserPLUS || _la == powerbuilderParserMINUS) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				}
				{
					p.SetState(473)
					p.Match(powerbuilderParserNUMBER)
				}

			}
			p.SetState(490)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == powerbuilderParserCOMMA {
				{
					p.SetState(476)
					p.Match(powerbuilderParserCOMMA)
				}
				p.SetState(478)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == powerbuilderParserPLUS || _la == powerbuilderParserMINUS {
					{
						p.SetState(477)
						_la = p.GetTokenStream().LA(1)

						if !(_la == powerbuilderParserPLUS || _la == powerbuilderParserMINUS) {
							p.GetErrorHandler().RecoverInline(p)
						} else {
							p.GetErrorHandler().ReportMatch(p)
							p.Consume()
						}
					}

				}
				{
					p.SetState(480)
					p.Match(powerbuilderParserNUMBER)
				}
				p.SetState(486)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == powerbuilderParserTO {
					{
						p.SetState(481)
						p.Match(powerbuilderParserTO)
					}
					p.SetState(483)
					p.GetErrorHandler().Sync(p)
					_la = p.GetTokenStream().LA(1)

					if _la == powerbuilderParserPLUS || _la == powerbuilderParserMINUS {
						{
							p.SetState(482)
							_la = p.GetTokenStream().LA(1)

							if !(_la == powerbuilderParserPLUS || _la == powerbuilderParserMINUS) {
								p.GetErrorHandler().RecoverInline(p)
							} else {
								p.GetErrorHandler().ReportMatch(p)
								p.Consume()
							}
						}

					}
					{
						p.SetState(485)
						p.Match(powerbuilderParserNUMBER)
					}

				}

				p.SetState(492)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		{
			p.SetState(495)
			p.Match(powerbuilderParserRBRACE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConstant_decl_subContext is an interface to support dynamic dispatch.
type IConstant_decl_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_decl_subContext differentiates from other interfaces.
	IsConstant_decl_subContext()
}

type Constant_decl_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_decl_subContext() *Constant_decl_subContext {
	var p = new(Constant_decl_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_constant_decl_sub
	return p
}

func (*Constant_decl_subContext) IsConstant_decl_subContext() {}

func NewConstant_decl_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_decl_subContext {
	var p = new(Constant_decl_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_constant_decl_sub

	return p
}

func (s *Constant_decl_subContext) GetParser() antlr.Parser { return s.parser }
func (s *Constant_decl_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_decl_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_decl_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterConstant_decl_sub(s)
	}
}

func (s *Constant_decl_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitConstant_decl_sub(s)
	}
}

func (p *powerbuilderParser) Constant_decl_sub() (localctx IConstant_decl_subContext) {
	localctx = NewConstant_decl_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, powerbuilderParserRULE_constant_decl_sub)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)

	return localctx
}

// IConstant_declContext is an interface to support dynamic dispatch.
type IConstant_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConstant_declContext differentiates from other interfaces.
	IsConstant_declContext()
}

type Constant_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstant_declContext() *Constant_declContext {
	var p = new(Constant_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_constant_decl
	return p
}

func (*Constant_declContext) IsConstant_declContext() {}

func NewConstant_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Constant_declContext {
	var p = new(Constant_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_constant_decl

	return p
}

func (s *Constant_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Constant_declContext) Constant_decl_sub() IConstant_decl_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_decl_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_decl_subContext)
}

func (s *Constant_declContext) SEMI() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserSEMI, 0)
}

func (s *Constant_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Constant_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Constant_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterConstant_decl(s)
	}
}

func (s *Constant_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitConstant_decl(s)
	}
}

func (p *powerbuilderParser) Constant_decl() (localctx IConstant_declContext) {
	localctx = NewConstant_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, powerbuilderParserRULE_constant_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(500)
		p.Constant_decl_sub()
	}
	{
		p.SetState(501)
		p.Match(powerbuilderParserSEMI)
	}

	return localctx
}

// IFunction_forward_declContext is an interface to support dynamic dispatch.
type IFunction_forward_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_forward_declContext differentiates from other interfaces.
	IsFunction_forward_declContext()
}

type Function_forward_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_forward_declContext() *Function_forward_declContext {
	var p = new(Function_forward_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_function_forward_decl
	return p
}

func (*Function_forward_declContext) IsFunction_forward_declContext() {}

func NewFunction_forward_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_forward_declContext {
	var p = new(Function_forward_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_function_forward_decl

	return p
}

func (s *Function_forward_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_forward_declContext) AllIdentifier_name() []IIdentifier_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem())
	var tst = make([]IIdentifier_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifier_nameContext)
		}
	}

	return tst
}

func (s *Function_forward_declContext) Identifier_name(i int) IIdentifier_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_nameContext)
}

func (s *Function_forward_declContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLPAREN, 0)
}

func (s *Function_forward_declContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRPAREN, 0)
}

func (s *Function_forward_declContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserFUNCTION, 0)
}

func (s *Function_forward_declContext) Data_type_name() IData_type_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_nameContext)
}

func (s *Function_forward_declContext) SUBROUTINE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserSUBROUTINE, 0)
}

func (s *Function_forward_declContext) Access_modif_part() IAccess_modif_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAccess_modif_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAccess_modif_partContext)
}

func (s *Function_forward_declContext) Scope_modif() IScope_modifContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScope_modifContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScope_modifContext)
}

func (s *Function_forward_declContext) Parameters_list_sub() IParameters_list_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameters_list_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameters_list_subContext)
}

func (s *Function_forward_declContext) LIBRARY() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLIBRARY, 0)
}

func (s *Function_forward_declContext) RPCFUNC() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRPCFUNC, 0)
}

func (s *Function_forward_declContext) AllALIAS() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserALIAS)
}

func (s *Function_forward_declContext) ALIAS(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserALIAS, i)
}

func (s *Function_forward_declContext) AllFOR() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserFOR)
}

func (s *Function_forward_declContext) FOR(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserFOR, i)
}

func (s *Function_forward_declContext) THROWS() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTHROWS, 0)
}

func (s *Function_forward_declContext) AllDQUOTED_STRING() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserDQUOTED_STRING)
}

func (s *Function_forward_declContext) DQUOTED_STRING(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDQUOTED_STRING, i)
}

func (s *Function_forward_declContext) AllQUOTED_STRING() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserQUOTED_STRING)
}

func (s *Function_forward_declContext) QUOTED_STRING(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserQUOTED_STRING, i)
}

func (s *Function_forward_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_forward_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_forward_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterFunction_forward_decl(s)
	}
}

func (s *Function_forward_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitFunction_forward_decl(s)
	}
}

func (p *powerbuilderParser) Function_forward_decl() (localctx IFunction_forward_declContext) {
	localctx = NewFunction_forward_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, powerbuilderParserRULE_function_forward_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(504)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserPRIVATEWRITE)|(1<<powerbuilderParserPROTECTED)|(1<<powerbuilderParserPRIVATEREAD)|(1<<powerbuilderParserPROTECTEDREAD)|(1<<powerbuilderParserPROTECTEDWRITE))) != 0 {
		{
			p.SetState(503)
			p.Access_modif_part()
		}

	}
	p.SetState(507)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserGLOBAL || _la == powerbuilderParserLOCAL {
		{
			p.SetState(506)
			p.Scope_modif()
		}

	}
	p.SetState(512)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case powerbuilderParserFUNCTION:
		{
			p.SetState(509)
			p.Match(powerbuilderParserFUNCTION)
		}
		{
			p.SetState(510)
			p.Data_type_name()
		}

	case powerbuilderParserSUBROUTINE:
		{
			p.SetState(511)
			p.Match(powerbuilderParserSUBROUTINE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(514)
		p.Identifier_name()
	}
	{
		p.SetState(515)
		p.Match(powerbuilderParserLPAREN)
	}
	p.SetState(517)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserDATA_TYPE_SUB)|(1<<powerbuilderParserREADONLY)|(1<<powerbuilderParserREF))) != 0) || _la == powerbuilderParserID {
		{
			p.SetState(516)
			p.Parameters_list_sub()
		}

	}
	{
		p.SetState(519)
		p.Match(powerbuilderParserRPAREN)
	}
	p.SetState(527)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserLIBRARY {
		{
			p.SetState(520)
			p.Match(powerbuilderParserLIBRARY)
		}
		{
			p.SetState(521)
			_la = p.GetTokenStream().LA(1)

			if !(_la == powerbuilderParserDQUOTED_STRING || _la == powerbuilderParserQUOTED_STRING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(525)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == powerbuilderParserALIAS {
			{
				p.SetState(522)
				p.Match(powerbuilderParserALIAS)
			}
			{
				p.SetState(523)
				p.Match(powerbuilderParserFOR)
			}
			{
				p.SetState(524)
				_la = p.GetTokenStream().LA(1)

				if !(_la == powerbuilderParserDQUOTED_STRING || _la == powerbuilderParserQUOTED_STRING) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	}
	p.SetState(533)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserRPCFUNC {
		{
			p.SetState(529)
			p.Match(powerbuilderParserRPCFUNC)
		}
		{
			p.SetState(530)
			p.Match(powerbuilderParserALIAS)
		}
		{
			p.SetState(531)
			p.Match(powerbuilderParserFOR)
		}
		{
			p.SetState(532)
			_la = p.GetTokenStream().LA(1)

			if !(_la == powerbuilderParserDQUOTED_STRING || _la == powerbuilderParserQUOTED_STRING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(537)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserTHROWS {
		{
			p.SetState(535)
			p.Match(powerbuilderParserTHROWS)
		}
		{
			p.SetState(536)
			p.Identifier_name()
		}

	}

	return localctx
}

// IParameter_subContext is an interface to support dynamic dispatch.
type IParameter_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameter_subContext differentiates from other interfaces.
	IsParameter_subContext()
}

type Parameter_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameter_subContext() *Parameter_subContext {
	var p = new(Parameter_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_parameter_sub
	return p
}

func (*Parameter_subContext) IsParameter_subContext() {}

func NewParameter_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameter_subContext {
	var p = new(Parameter_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_parameter_sub

	return p
}

func (s *Parameter_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameter_subContext) Data_type_name() IData_type_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_nameContext)
}

func (s *Parameter_subContext) Identifier_name() IIdentifier_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_nameContext)
}

func (s *Parameter_subContext) READONLY() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserREADONLY, 0)
}

func (s *Parameter_subContext) REF() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserREF, 0)
}

func (s *Parameter_subContext) Decimal_decl_sub() IDecimal_decl_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDecimal_decl_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDecimal_decl_subContext)
}

func (s *Parameter_subContext) Array_decl_sub() IArray_decl_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_decl_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_decl_subContext)
}

func (s *Parameter_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameter_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameter_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterParameter_sub(s)
	}
}

func (s *Parameter_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitParameter_sub(s)
	}
}

func (p *powerbuilderParser) Parameter_sub() (localctx IParameter_subContext) {
	localctx = NewParameter_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, powerbuilderParserRULE_parameter_sub)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(540)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserREADONLY {
		{
			p.SetState(539)
			p.Match(powerbuilderParserREADONLY)
		}

	}
	p.SetState(543)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserREF {
		{
			p.SetState(542)
			p.Match(powerbuilderParserREF)
		}

	}
	{
		p.SetState(545)
		p.Data_type_name()
	}
	p.SetState(547)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserLCURLY {
		{
			p.SetState(546)
			p.Decimal_decl_sub()
		}

	}
	{
		p.SetState(549)
		p.Identifier_name()
	}
	p.SetState(551)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserLBRACE || _la == powerbuilderParserBRACES {
		{
			p.SetState(550)
			p.Array_decl_sub()
		}

	}

	return localctx
}

// IParameters_list_subContext is an interface to support dynamic dispatch.
type IParameters_list_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParameters_list_subContext differentiates from other interfaces.
	IsParameters_list_subContext()
}

type Parameters_list_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameters_list_subContext() *Parameters_list_subContext {
	var p = new(Parameters_list_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_parameters_list_sub
	return p
}

func (*Parameters_list_subContext) IsParameters_list_subContext() {}

func NewParameters_list_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Parameters_list_subContext {
	var p = new(Parameters_list_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_parameters_list_sub

	return p
}

func (s *Parameters_list_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Parameters_list_subContext) AllParameter_sub() []IParameter_subContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IParameter_subContext)(nil)).Elem())
	var tst = make([]IParameter_subContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IParameter_subContext)
		}
	}

	return tst
}

func (s *Parameters_list_subContext) Parameter_sub(i int) IParameter_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameter_subContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IParameter_subContext)
}

func (s *Parameters_list_subContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserCOMMA)
}

func (s *Parameters_list_subContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCOMMA, i)
}

func (s *Parameters_list_subContext) DOTDOTDOT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDOTDOTDOT, 0)
}

func (s *Parameters_list_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Parameters_list_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Parameters_list_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterParameters_list_sub(s)
	}
}

func (s *Parameters_list_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitParameters_list_sub(s)
	}
}

func (p *powerbuilderParser) Parameters_list_sub() (localctx IParameters_list_subContext) {
	localctx = NewParameters_list_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, powerbuilderParserRULE_parameters_list_sub)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(553)
		p.Parameter_sub()
	}
	p.SetState(558)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(554)
				p.Match(powerbuilderParserCOMMA)
			}
			{
				p.SetState(555)
				p.Parameter_sub()
			}

		}
		p.SetState(560)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext())
	}
	p.SetState(563)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserCOMMA {
		{
			p.SetState(561)
			p.Match(powerbuilderParserCOMMA)
		}
		{
			p.SetState(562)
			p.Match(powerbuilderParserDOTDOTDOT)
		}

	}

	return localctx
}

// IFunctions_forward_declContext is an interface to support dynamic dispatch.
type IFunctions_forward_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctions_forward_declContext differentiates from other interfaces.
	IsFunctions_forward_declContext()
}

type Functions_forward_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctions_forward_declContext() *Functions_forward_declContext {
	var p = new(Functions_forward_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_functions_forward_decl
	return p
}

func (*Functions_forward_declContext) IsFunctions_forward_declContext() {}

func NewFunctions_forward_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Functions_forward_declContext {
	var p = new(Functions_forward_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_functions_forward_decl

	return p
}

func (s *Functions_forward_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Functions_forward_declContext) AllPROTOTYPES() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserPROTOTYPES)
}

func (s *Functions_forward_declContext) PROTOTYPES(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserPROTOTYPES, i)
}

func (s *Functions_forward_declContext) END() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEND, 0)
}

func (s *Functions_forward_declContext) FORWARD() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserFORWARD, 0)
}

func (s *Functions_forward_declContext) TYPE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTYPE, 0)
}

func (s *Functions_forward_declContext) AllFunction_forward_decl() []IFunction_forward_declContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFunction_forward_declContext)(nil)).Elem())
	var tst = make([]IFunction_forward_declContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFunction_forward_declContext)
		}
	}

	return tst
}

func (s *Functions_forward_declContext) Function_forward_decl(i int) IFunction_forward_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_forward_declContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFunction_forward_declContext)
}

func (s *Functions_forward_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Functions_forward_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Functions_forward_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterFunctions_forward_decl(s)
	}
}

func (s *Functions_forward_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitFunctions_forward_decl(s)
	}
}

func (p *powerbuilderParser) Functions_forward_decl() (localctx IFunctions_forward_declContext) {
	localctx = NewFunctions_forward_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, powerbuilderParserRULE_functions_forward_decl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(565)
		_la = p.GetTokenStream().LA(1)

		if !(_la == powerbuilderParserFORWARD || _la == powerbuilderParserTYPE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(566)
		p.Match(powerbuilderParserPROTOTYPES)
	}
	p.SetState(568)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserGLOBAL)|(1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserFUNCTION)|(1<<powerbuilderParserSUBROUTINE)|(1<<powerbuilderParserPRIVATEWRITE)|(1<<powerbuilderParserPROTECTED)|(1<<powerbuilderParserPRIVATEREAD)|(1<<powerbuilderParserPROTECTEDREAD)|(1<<powerbuilderParserPROTECTEDWRITE)|(1<<powerbuilderParserLOCAL))) != 0) {
		{
			p.SetState(567)
			p.Function_forward_decl()
		}

		p.SetState(570)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(572)
		p.Match(powerbuilderParserEND)
	}
	{
		p.SetState(573)
		p.Match(powerbuilderParserPROTOTYPES)
	}

	return localctx
}

// IFunction_bodyContext is an interface to support dynamic dispatch.
type IFunction_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_bodyContext differentiates from other interfaces.
	IsFunction_bodyContext()
}

type Function_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_bodyContext() *Function_bodyContext {
	var p = new(Function_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_function_body
	return p
}

func (*Function_bodyContext) IsFunction_bodyContext() {}

func NewFunction_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_bodyContext {
	var p = new(Function_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_function_body

	return p
}

func (s *Function_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_bodyContext) AllIdentifier_name() []IIdentifier_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem())
	var tst = make([]IIdentifier_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifier_nameContext)
		}
	}

	return tst
}

func (s *Function_bodyContext) Identifier_name(i int) IIdentifier_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_nameContext)
}

func (s *Function_bodyContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLPAREN, 0)
}

func (s *Function_bodyContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRPAREN, 0)
}

func (s *Function_bodyContext) END() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEND, 0)
}

func (s *Function_bodyContext) AllFUNCTION() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserFUNCTION)
}

func (s *Function_bodyContext) FUNCTION(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserFUNCTION, i)
}

func (s *Function_bodyContext) AllSUBROUTINE() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserSUBROUTINE)
}

func (s *Function_bodyContext) SUBROUTINE(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserSUBROUTINE, i)
}

func (s *Function_bodyContext) Data_type_name() IData_type_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_nameContext)
}

func (s *Function_bodyContext) Access_type() IAccess_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAccess_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAccess_typeContext)
}

func (s *Function_bodyContext) Scope_modif() IScope_modifContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IScope_modifContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IScope_modifContext)
}

func (s *Function_bodyContext) Parameters_list_sub() IParameters_list_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameters_list_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameters_list_subContext)
}

func (s *Function_bodyContext) THROWS() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTHROWS, 0)
}

func (s *Function_bodyContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserSEMI)
}

func (s *Function_bodyContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserSEMI, i)
}

func (s *Function_bodyContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Function_bodyContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Function_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterFunction_body(s)
	}
}

func (s *Function_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitFunction_body(s)
	}
}

func (p *powerbuilderParser) Function_body() (localctx IFunction_bodyContext) {
	localctx = NewFunction_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, powerbuilderParserRULE_function_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(576)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserPROTECTED))) != 0 {
		{
			p.SetState(575)
			p.Access_type()
		}

	}
	p.SetState(579)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserGLOBAL || _la == powerbuilderParserLOCAL {
		{
			p.SetState(578)
			p.Scope_modif()
		}

	}
	p.SetState(584)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case powerbuilderParserFUNCTION:
		{
			p.SetState(581)
			p.Match(powerbuilderParserFUNCTION)
		}
		{
			p.SetState(582)
			p.Data_type_name()
		}

	case powerbuilderParserSUBROUTINE:
		{
			p.SetState(583)
			p.Match(powerbuilderParserSUBROUTINE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(586)
		p.Identifier_name()
	}
	{
		p.SetState(587)
		p.Match(powerbuilderParserLPAREN)
	}
	p.SetState(589)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserDATA_TYPE_SUB)|(1<<powerbuilderParserREADONLY)|(1<<powerbuilderParserREF))) != 0) || _la == powerbuilderParserID {
		{
			p.SetState(588)
			p.Parameters_list_sub()
		}

	}
	{
		p.SetState(591)
		p.Match(powerbuilderParserRPAREN)
	}
	p.SetState(594)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserTHROWS {
		{
			p.SetState(592)
			p.Match(powerbuilderParserTHROWS)
		}
		{
			p.SetState(593)
			p.Identifier_name()
		}

	}
	p.SetState(600)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == powerbuilderParserSEMI {
		{
			p.SetState(596)
			p.Match(powerbuilderParserSEMI)
		}
		{
			p.SetState(597)
			p.Statement()
		}

		p.SetState(602)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(603)
		p.Match(powerbuilderParserEND)
	}
	{
		p.SetState(604)
		_la = p.GetTokenStream().LA(1)

		if !(_la == powerbuilderParserFUNCTION || _la == powerbuilderParserSUBROUTINE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IOn_bodyContext is an interface to support dynamic dispatch.
type IOn_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOn_bodyContext differentiates from other interfaces.
	IsOn_bodyContext()
}

type On_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOn_bodyContext() *On_bodyContext {
	var p = new(On_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_on_body
	return p
}

func (*On_bodyContext) IsOn_bodyContext() {}

func NewOn_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *On_bodyContext {
	var p = new(On_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_on_body

	return p
}

func (s *On_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *On_bodyContext) ON() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserON, 0)
}

func (s *On_bodyContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *On_bodyContext) OPEN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserOPEN, 0)
}

func (s *On_bodyContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCLOSE, 0)
}

func (s *On_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *On_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *On_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterOn_body(s)
	}
}

func (s *On_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitOn_body(s)
	}
}

func (p *powerbuilderParser) On_body() (localctx IOn_bodyContext) {
	localctx = NewOn_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, powerbuilderParserRULE_on_body)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(606)
		p.Match(powerbuilderParserON)
	}
	p.SetState(610)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case powerbuilderParserSUPER, powerbuilderParserID:
		{
			p.SetState(607)
			p.Identifier()
		}

	case powerbuilderParserOPEN:
		{
			p.SetState(608)
			p.Match(powerbuilderParserOPEN)
		}

	case powerbuilderParserCLOSE:
		{
			p.SetState(609)
			p.Match(powerbuilderParserCLOSE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEvent_forward_decl_subContext is an interface to support dynamic dispatch.
type IEvent_forward_decl_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_forward_decl_subContext differentiates from other interfaces.
	IsEvent_forward_decl_subContext()
}

type Event_forward_decl_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_forward_decl_subContext() *Event_forward_decl_subContext {
	var p = new(Event_forward_decl_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_event_forward_decl_sub
	return p
}

func (*Event_forward_decl_subContext) IsEvent_forward_decl_subContext() {}

func NewEvent_forward_decl_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_forward_decl_subContext {
	var p = new(Event_forward_decl_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_event_forward_decl_sub

	return p
}

func (s *Event_forward_decl_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_forward_decl_subContext) EVENT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEVENT, 0)
}

func (s *Event_forward_decl_subContext) AllIdentifier_name() []IIdentifier_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem())
	var tst = make([]IIdentifier_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifier_nameContext)
		}
	}

	return tst
}

func (s *Event_forward_decl_subContext) Identifier_name(i int) IIdentifier_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_nameContext)
}

func (s *Event_forward_decl_subContext) CREATE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCREATE, 0)
}

func (s *Event_forward_decl_subContext) DESTROY() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDESTROY, 0)
}

func (s *Event_forward_decl_subContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLPAREN, 0)
}

func (s *Event_forward_decl_subContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRPAREN, 0)
}

func (s *Event_forward_decl_subContext) Parameters_list_sub() IParameters_list_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameters_list_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameters_list_subContext)
}

func (s *Event_forward_decl_subContext) TYPE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTYPE, 0)
}

func (s *Event_forward_decl_subContext) Data_type_name() IData_type_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_nameContext)
}

func (s *Event_forward_decl_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_forward_decl_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_forward_decl_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterEvent_forward_decl_sub(s)
	}
}

func (s *Event_forward_decl_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitEvent_forward_decl_sub(s)
	}
}

func (p *powerbuilderParser) Event_forward_decl_sub() (localctx IEvent_forward_decl_subContext) {
	localctx = NewEvent_forward_decl_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, powerbuilderParserRULE_event_forward_decl_sub)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(638)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(612)
			p.Match(powerbuilderParserEVENT)
		}
		p.SetState(616)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case powerbuilderParserID:
			{
				p.SetState(613)
				p.Identifier_name()
			}

		case powerbuilderParserCREATE:
			{
				p.SetState(614)
				p.Match(powerbuilderParserCREATE)
			}

		case powerbuilderParserDESTROY:
			{
				p.SetState(615)
				p.Match(powerbuilderParserDESTROY)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}
		p.SetState(619)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == powerbuilderParserID {
			{
				p.SetState(618)
				p.Identifier_name()
			}

		}
		p.SetState(626)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == powerbuilderParserLPAREN {
			{
				p.SetState(621)
				p.Match(powerbuilderParserLPAREN)
			}
			p.SetState(623)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserDATA_TYPE_SUB)|(1<<powerbuilderParserREADONLY)|(1<<powerbuilderParserREF))) != 0) || _la == powerbuilderParserID {
				{
					p.SetState(622)
					p.Parameters_list_sub()
				}

			}
			{
				p.SetState(625)
				p.Match(powerbuilderParserRPAREN)
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(628)
			p.Match(powerbuilderParserEVENT)
		}
		{
			p.SetState(629)
			p.Match(powerbuilderParserTYPE)
		}
		{
			p.SetState(630)
			p.Data_type_name()
		}
		{
			p.SetState(631)
			p.Identifier_name()
		}

		{
			p.SetState(632)
			p.Match(powerbuilderParserLPAREN)
		}
		p.SetState(634)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserDATA_TYPE_SUB)|(1<<powerbuilderParserREADONLY)|(1<<powerbuilderParserREF))) != 0) || _la == powerbuilderParserID {
			{
				p.SetState(633)
				p.Parameters_list_sub()
			}

		}
		{
			p.SetState(636)
			p.Match(powerbuilderParserRPAREN)
		}

	}

	return localctx
}

// IEvent_forward_declContext is an interface to support dynamic dispatch.
type IEvent_forward_declContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_forward_declContext differentiates from other interfaces.
	IsEvent_forward_declContext()
}

type Event_forward_declContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_forward_declContext() *Event_forward_declContext {
	var p = new(Event_forward_declContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_event_forward_decl
	return p
}

func (*Event_forward_declContext) IsEvent_forward_declContext() {}

func NewEvent_forward_declContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_forward_declContext {
	var p = new(Event_forward_declContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_event_forward_decl

	return p
}

func (s *Event_forward_declContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_forward_declContext) Event_forward_decl_sub() IEvent_forward_decl_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_forward_decl_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_forward_decl_subContext)
}

func (s *Event_forward_declContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_forward_declContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_forward_declContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterEvent_forward_decl(s)
	}
}

func (s *Event_forward_declContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitEvent_forward_decl(s)
	}
}

func (p *powerbuilderParser) Event_forward_decl() (localctx IEvent_forward_declContext) {
	localctx = NewEvent_forward_declContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, powerbuilderParserRULE_event_forward_decl)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(640)
		p.Event_forward_decl_sub()
	}

	return localctx
}

// IEvent_bodyContext is an interface to support dynamic dispatch.
type IEvent_bodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_bodyContext differentiates from other interfaces.
	IsEvent_bodyContext()
}

type Event_bodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_bodyContext() *Event_bodyContext {
	var p = new(Event_bodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_event_body
	return p
}

func (*Event_bodyContext) IsEvent_bodyContext() {}

func NewEvent_bodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_bodyContext {
	var p = new(Event_bodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_event_body

	return p
}

func (s *Event_bodyContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_bodyContext) AllEVENT() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserEVENT)
}

func (s *Event_bodyContext) EVENT(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEVENT, i)
}

func (s *Event_bodyContext) END() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEND, 0)
}

func (s *Event_bodyContext) AllIdentifier_name() []IIdentifier_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem())
	var tst = make([]IIdentifier_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifier_nameContext)
		}
	}

	return tst
}

func (s *Event_bodyContext) Identifier_name(i int) IIdentifier_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_nameContext)
}

func (s *Event_bodyContext) OPEN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserOPEN, 0)
}

func (s *Event_bodyContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCLOSE, 0)
}

func (s *Event_bodyContext) TYPE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTYPE, 0)
}

func (s *Event_bodyContext) Data_type_name() IData_type_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_nameContext)
}

func (s *Event_bodyContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCOLONCOLON, 0)
}

func (s *Event_bodyContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLPAREN, 0)
}

func (s *Event_bodyContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRPAREN, 0)
}

func (s *Event_bodyContext) AllSEMI() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserSEMI)
}

func (s *Event_bodyContext) SEMI(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserSEMI, i)
}

func (s *Event_bodyContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Event_bodyContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Event_bodyContext) Parameters_list_sub() IParameters_list_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IParameters_list_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IParameters_list_subContext)
}

func (s *Event_bodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_bodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_bodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterEvent_body(s)
	}
}

func (s *Event_bodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitEvent_body(s)
	}
}

func (p *powerbuilderParser) Event_body() (localctx IEvent_bodyContext) {
	localctx = NewEvent_bodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, powerbuilderParserRULE_event_body)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(642)
		p.Match(powerbuilderParserEVENT)
	}
	p.SetState(645)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserTYPE {
		{
			p.SetState(643)
			p.Match(powerbuilderParserTYPE)
		}
		{
			p.SetState(644)
			p.Data_type_name()
		}

	}
	p.SetState(650)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 84, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(647)
			p.Identifier_name()
		}
		{
			p.SetState(648)
			p.Match(powerbuilderParserCOLONCOLON)
		}

	}
	p.SetState(655)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case powerbuilderParserID:
		{
			p.SetState(652)
			p.Identifier_name()
		}

	case powerbuilderParserOPEN:
		{
			p.SetState(653)
			p.Match(powerbuilderParserOPEN)
		}

	case powerbuilderParserCLOSE:
		{
			p.SetState(654)
			p.Match(powerbuilderParserCLOSE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(662)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserLPAREN {
		{
			p.SetState(657)
			p.Match(powerbuilderParserLPAREN)
		}
		p.SetState(659)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserDATA_TYPE_SUB)|(1<<powerbuilderParserREADONLY)|(1<<powerbuilderParserREF))) != 0) || _la == powerbuilderParserID {
			{
				p.SetState(658)
				p.Parameters_list_sub()
			}

		}
		{
			p.SetState(661)
			p.Match(powerbuilderParserRPAREN)
		}

	}
	p.SetState(668)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == powerbuilderParserSEMI {
		{
			p.SetState(664)
			p.Match(powerbuilderParserSEMI)
		}
		{
			p.SetState(665)
			p.Statement()
		}

		p.SetState(670)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(671)
		p.Match(powerbuilderParserEND)
	}
	{
		p.SetState(672)
		p.Match(powerbuilderParserEVENT)
	}

	return localctx
}

// IAccess_typeContext is an interface to support dynamic dispatch.
type IAccess_typeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAccess_typeContext differentiates from other interfaces.
	IsAccess_typeContext()
}

type Access_typeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccess_typeContext() *Access_typeContext {
	var p = new(Access_typeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_access_type
	return p
}

func (*Access_typeContext) IsAccess_typeContext() {}

func NewAccess_typeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Access_typeContext {
	var p = new(Access_typeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_access_type

	return p
}

func (s *Access_typeContext) GetParser() antlr.Parser { return s.parser }

func (s *Access_typeContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserPUBLIC, 0)
}

func (s *Access_typeContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserPRIVATE, 0)
}

func (s *Access_typeContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserPROTECTED, 0)
}

func (s *Access_typeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Access_typeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Access_typeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterAccess_type(s)
	}
}

func (s *Access_typeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitAccess_type(s)
	}
}

func (p *powerbuilderParser) Access_type() (localctx IAccess_typeContext) {
	localctx = NewAccess_typeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, powerbuilderParserRULE_access_type)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(674)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserPROTECTED))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IAccess_modifContext is an interface to support dynamic dispatch.
type IAccess_modifContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAccess_modifContext differentiates from other interfaces.
	IsAccess_modifContext()
}

type Access_modifContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccess_modifContext() *Access_modifContext {
	var p = new(Access_modifContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_access_modif
	return p
}

func (*Access_modifContext) IsAccess_modifContext() {}

func NewAccess_modifContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Access_modifContext {
	var p = new(Access_modifContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_access_modif

	return p
}

func (s *Access_modifContext) GetParser() antlr.Parser { return s.parser }

func (s *Access_modifContext) Access_type() IAccess_typeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAccess_typeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAccess_typeContext)
}

func (s *Access_modifContext) COLON() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCOLON, 0)
}

func (s *Access_modifContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Access_modifContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Access_modifContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterAccess_modif(s)
	}
}

func (s *Access_modifContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitAccess_modif(s)
	}
}

func (p *powerbuilderParser) Access_modif() (localctx IAccess_modifContext) {
	localctx = NewAccess_modifContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, powerbuilderParserRULE_access_modif)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(676)
		p.Access_type()
	}
	{
		p.SetState(677)
		p.Match(powerbuilderParserCOLON)
	}

	return localctx
}

// IAccess_modif_partContext is an interface to support dynamic dispatch.
type IAccess_modif_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAccess_modif_partContext differentiates from other interfaces.
	IsAccess_modif_partContext()
}

type Access_modif_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccess_modif_partContext() *Access_modif_partContext {
	var p = new(Access_modif_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_access_modif_part
	return p
}

func (*Access_modif_partContext) IsAccess_modif_partContext() {}

func NewAccess_modif_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Access_modif_partContext {
	var p = new(Access_modif_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_access_modif_part

	return p
}

func (s *Access_modif_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Access_modif_partContext) PUBLIC() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserPUBLIC, 0)
}

func (s *Access_modif_partContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserPRIVATE, 0)
}

func (s *Access_modif_partContext) PRIVATEREAD() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserPRIVATEREAD, 0)
}

func (s *Access_modif_partContext) PRIVATEWRITE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserPRIVATEWRITE, 0)
}

func (s *Access_modif_partContext) PROTECTED() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserPROTECTED, 0)
}

func (s *Access_modif_partContext) PROTECTEDREAD() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserPROTECTEDREAD, 0)
}

func (s *Access_modif_partContext) PROTECTEDWRITE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserPROTECTEDWRITE, 0)
}

func (s *Access_modif_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Access_modif_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Access_modif_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterAccess_modif_part(s)
	}
}

func (s *Access_modif_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitAccess_modif_part(s)
	}
}

func (p *powerbuilderParser) Access_modif_part() (localctx IAccess_modif_partContext) {
	localctx = NewAccess_modif_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, powerbuilderParserRULE_access_modif_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(679)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserPRIVATEWRITE)|(1<<powerbuilderParserPROTECTED)|(1<<powerbuilderParserPRIVATEREAD)|(1<<powerbuilderParserPROTECTEDREAD)|(1<<powerbuilderParserPROTECTEDWRITE))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IScope_modifContext is an interface to support dynamic dispatch.
type IScope_modifContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScope_modifContext differentiates from other interfaces.
	IsScope_modifContext()
}

type Scope_modifContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScope_modifContext() *Scope_modifContext {
	var p = new(Scope_modifContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_scope_modif
	return p
}

func (*Scope_modifContext) IsScope_modifContext() {}

func NewScope_modifContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Scope_modifContext {
	var p = new(Scope_modifContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_scope_modif

	return p
}

func (s *Scope_modifContext) GetParser() antlr.Parser { return s.parser }

func (s *Scope_modifContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserGLOBAL, 0)
}

func (s *Scope_modifContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLOCAL, 0)
}

func (s *Scope_modifContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Scope_modifContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Scope_modifContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterScope_modif(s)
	}
}

func (s *Scope_modifContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitScope_modif(s)
	}
}

func (p *powerbuilderParser) Scope_modif() (localctx IScope_modifContext) {
	localctx = NewScope_modifContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, powerbuilderParserRULE_scope_modif)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(681)
		_la = p.GetTokenStream().LA(1)

		if !(_la == powerbuilderParserGLOBAL || _la == powerbuilderParserLOCAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_expression
	return p
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) Close_call_sub() IClose_call_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClose_call_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClose_call_subContext)
}

func (s *ExpressionContext) LCURLY() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLCURLY, 0)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterExpression(s)
	}
}

func (s *ExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitExpression(s)
	}
}

func (p *powerbuilderParser) Expression() (localctx IExpressionContext) {
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, powerbuilderParserRULE_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(685)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case powerbuilderParserCLOSE, powerbuilderParserHALT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(683)
			p.Close_call_sub()
		}

	case powerbuilderParserLCURLY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(684)
			p.Match(powerbuilderParserLCURLY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IExpression_listContext is an interface to support dynamic dispatch.
type IExpression_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExpression_listContext differentiates from other interfaces.
	IsExpression_listContext()
}

type Expression_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpression_listContext() *Expression_listContext {
	var p = new(Expression_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_expression_list
	return p
}

func (*Expression_listContext) IsExpression_listContext() {}

func NewExpression_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Expression_listContext {
	var p = new(Expression_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_expression_list

	return p
}

func (s *Expression_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Expression_listContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Expression_listContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Expression_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserCOMMA)
}

func (s *Expression_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCOMMA, i)
}

func (s *Expression_listContext) AllREF() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserREF)
}

func (s *Expression_listContext) REF(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserREF, i)
}

func (s *Expression_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Expression_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Expression_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterExpression_list(s)
	}
}

func (s *Expression_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitExpression_list(s)
	}
}

func (p *powerbuilderParser) Expression_list() (localctx IExpression_listContext) {
	localctx = NewExpression_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, powerbuilderParserRULE_expression_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(688)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserREF {
		{
			p.SetState(687)
			p.Match(powerbuilderParserREF)
		}

	}
	{
		p.SetState(690)
		p.Expression()
	}

	p.SetState(699)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == powerbuilderParserCOMMA {
		{
			p.SetState(692)
			p.Match(powerbuilderParserCOMMA)
		}
		p.SetState(694)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == powerbuilderParserREF {
			{
				p.SetState(693)
				p.Match(powerbuilderParserREF)
			}

		}
		{
			p.SetState(696)
			p.Expression()
		}

		p.SetState(701)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IBoolean_expressionContext is an interface to support dynamic dispatch.
type IBoolean_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBoolean_expressionContext differentiates from other interfaces.
	IsBoolean_expressionContext()
}

type Boolean_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoolean_expressionContext() *Boolean_expressionContext {
	var p = new(Boolean_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_boolean_expression
	return p
}

func (*Boolean_expressionContext) IsBoolean_expressionContext() {}

func NewBoolean_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Boolean_expressionContext {
	var p = new(Boolean_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_boolean_expression

	return p
}

func (s *Boolean_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Boolean_expressionContext) Condition_or() ICondition_orContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICondition_orContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICondition_orContext)
}

func (s *Boolean_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Boolean_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Boolean_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterBoolean_expression(s)
	}
}

func (s *Boolean_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitBoolean_expression(s)
	}
}

func (p *powerbuilderParser) Boolean_expression() (localctx IBoolean_expressionContext) {
	localctx = NewBoolean_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, powerbuilderParserRULE_boolean_expression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(702)
		p.Condition_or()
	}

	return localctx
}

// ICondition_orContext is an interface to support dynamic dispatch.
type ICondition_orContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCondition_orContext differentiates from other interfaces.
	IsCondition_orContext()
}

type Condition_orContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCondition_orContext() *Condition_orContext {
	var p = new(Condition_orContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_condition_or
	return p
}

func (*Condition_orContext) IsCondition_orContext() {}

func NewCondition_orContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Condition_orContext {
	var p = new(Condition_orContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_condition_or

	return p
}

func (s *Condition_orContext) GetParser() antlr.Parser { return s.parser }

func (s *Condition_orContext) AllCondition_and() []ICondition_andContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICondition_andContext)(nil)).Elem())
	var tst = make([]ICondition_andContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICondition_andContext)
		}
	}

	return tst
}

func (s *Condition_orContext) Condition_and(i int) ICondition_andContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICondition_andContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICondition_andContext)
}

func (s *Condition_orContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserOR)
}

func (s *Condition_orContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserOR, i)
}

func (s *Condition_orContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Condition_orContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Condition_orContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterCondition_or(s)
	}
}

func (s *Condition_orContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitCondition_or(s)
	}
}

func (p *powerbuilderParser) Condition_or() (localctx ICondition_orContext) {
	localctx = NewCondition_orContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, powerbuilderParserRULE_condition_or)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(704)
		p.Condition_and()
	}
	p.SetState(709)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == powerbuilderParserOR {
		{
			p.SetState(705)
			p.Match(powerbuilderParserOR)
		}
		{
			p.SetState(706)
			p.Condition_and()
		}

		p.SetState(711)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICondition_andContext is an interface to support dynamic dispatch.
type ICondition_andContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCondition_andContext differentiates from other interfaces.
	IsCondition_andContext()
}

type Condition_andContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCondition_andContext() *Condition_andContext {
	var p = new(Condition_andContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_condition_and
	return p
}

func (*Condition_andContext) IsCondition_andContext() {}

func NewCondition_andContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Condition_andContext {
	var p = new(Condition_andContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_condition_and

	return p
}

func (s *Condition_andContext) GetParser() antlr.Parser { return s.parser }

func (s *Condition_andContext) AllCondition_not() []ICondition_notContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICondition_notContext)(nil)).Elem())
	var tst = make([]ICondition_notContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICondition_notContext)
		}
	}

	return tst
}

func (s *Condition_andContext) Condition_not(i int) ICondition_notContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICondition_notContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICondition_notContext)
}

func (s *Condition_andContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserAND)
}

func (s *Condition_andContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserAND, i)
}

func (s *Condition_andContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Condition_andContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Condition_andContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterCondition_and(s)
	}
}

func (s *Condition_andContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitCondition_and(s)
	}
}

func (p *powerbuilderParser) Condition_and() (localctx ICondition_andContext) {
	localctx = NewCondition_andContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, powerbuilderParserRULE_condition_and)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(712)
		p.Condition_not()
	}
	p.SetState(717)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == powerbuilderParserAND {
		{
			p.SetState(713)
			p.Match(powerbuilderParserAND)
		}
		{
			p.SetState(714)
			p.Condition_not()
		}

		p.SetState(719)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICondition_notContext is an interface to support dynamic dispatch.
type ICondition_notContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCondition_notContext differentiates from other interfaces.
	IsCondition_notContext()
}

type Condition_notContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCondition_notContext() *Condition_notContext {
	var p = new(Condition_notContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_condition_not
	return p
}

func (*Condition_notContext) IsCondition_notContext() {}

func NewCondition_notContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Condition_notContext {
	var p = new(Condition_notContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_condition_not

	return p
}

func (s *Condition_notContext) GetParser() antlr.Parser { return s.parser }

func (s *Condition_notContext) Condition_comparison() ICondition_comparisonContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICondition_comparisonContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICondition_comparisonContext)
}

func (s *Condition_notContext) NOT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserNOT, 0)
}

func (s *Condition_notContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Condition_notContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Condition_notContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterCondition_not(s)
	}
}

func (s *Condition_notContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitCondition_not(s)
	}
}

func (p *powerbuilderParser) Condition_not() (localctx ICondition_notContext) {
	localctx = NewCondition_notContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, powerbuilderParserRULE_condition_not)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(721)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserNOT {
		{
			p.SetState(720)
			p.Match(powerbuilderParserNOT)
		}

	}
	{
		p.SetState(723)
		p.Condition_comparison()
	}

	return localctx
}

// ICondition_comparisonContext is an interface to support dynamic dispatch.
type ICondition_comparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCondition_comparisonContext differentiates from other interfaces.
	IsCondition_comparisonContext()
}

type Condition_comparisonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCondition_comparisonContext() *Condition_comparisonContext {
	var p = new(Condition_comparisonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_condition_comparison
	return p
}

func (*Condition_comparisonContext) IsCondition_comparisonContext() {}

func NewCondition_comparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Condition_comparisonContext {
	var p = new(Condition_comparisonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_condition_comparison

	return p
}

func (s *Condition_comparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *Condition_comparisonContext) AllAdd_expr() []IAdd_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAdd_exprContext)(nil)).Elem())
	var tst = make([]IAdd_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAdd_exprContext)
		}
	}

	return tst
}

func (s *Condition_comparisonContext) Add_expr(i int) IAdd_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAdd_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAdd_exprContext)
}

func (s *Condition_comparisonContext) EQ() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEQ, 0)
}

func (s *Condition_comparisonContext) GT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserGT, 0)
}

func (s *Condition_comparisonContext) LT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLT, 0)
}

func (s *Condition_comparisonContext) GTLT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserGTLT, 0)
}

func (s *Condition_comparisonContext) GTE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserGTE, 0)
}

func (s *Condition_comparisonContext) LTE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLTE, 0)
}

func (s *Condition_comparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Condition_comparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Condition_comparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterCondition_comparison(s)
	}
}

func (s *Condition_comparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitCondition_comparison(s)
	}
}

func (p *powerbuilderParser) Condition_comparison() (localctx ICondition_comparisonContext) {
	localctx = NewCondition_comparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, powerbuilderParserRULE_condition_comparison)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(725)
		p.Add_expr()
	}
	p.SetState(728)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(powerbuilderParserEQ-77))|(1<<(powerbuilderParserGT-77))|(1<<(powerbuilderParserGTE-77))|(1<<(powerbuilderParserLT-77))|(1<<(powerbuilderParserLTE-77))|(1<<(powerbuilderParserGTLT-77)))) != 0 {
		{
			p.SetState(726)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(powerbuilderParserEQ-77))|(1<<(powerbuilderParserGT-77))|(1<<(powerbuilderParserGTE-77))|(1<<(powerbuilderParserLT-77))|(1<<(powerbuilderParserLTE-77))|(1<<(powerbuilderParserGTLT-77)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(727)
			p.Add_expr()
		}

	}

	return localctx
}

// IAdd_exprContext is an interface to support dynamic dispatch.
type IAdd_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAdd_exprContext differentiates from other interfaces.
	IsAdd_exprContext()
}

type Add_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAdd_exprContext() *Add_exprContext {
	var p = new(Add_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_add_expr
	return p
}

func (*Add_exprContext) IsAdd_exprContext() {}

func NewAdd_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Add_exprContext {
	var p = new(Add_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_add_expr

	return p
}

func (s *Add_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Add_exprContext) AllMul_expr() []IMul_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMul_exprContext)(nil)).Elem())
	var tst = make([]IMul_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMul_exprContext)
		}
	}

	return tst
}

func (s *Add_exprContext) Mul_expr(i int) IMul_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMul_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMul_exprContext)
}

func (s *Add_exprContext) AllMINUS() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserMINUS)
}

func (s *Add_exprContext) MINUS(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserMINUS, i)
}

func (s *Add_exprContext) AllPLUS() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserPLUS)
}

func (s *Add_exprContext) PLUS(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserPLUS, i)
}

func (s *Add_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Add_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Add_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterAdd_expr(s)
	}
}

func (s *Add_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitAdd_expr(s)
	}
}

func (p *powerbuilderParser) Add_expr() (localctx IAdd_exprContext) {
	localctx = NewAdd_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, powerbuilderParserRULE_add_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(730)
		p.Mul_expr()
	}
	p.SetState(735)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == powerbuilderParserPLUS || _la == powerbuilderParserMINUS {
		{
			p.SetState(731)
			_la = p.GetTokenStream().LA(1)

			if !(_la == powerbuilderParserPLUS || _la == powerbuilderParserMINUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(732)
			p.Mul_expr()
		}

		p.SetState(737)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMul_exprContext is an interface to support dynamic dispatch.
type IMul_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMul_exprContext differentiates from other interfaces.
	IsMul_exprContext()
}

type Mul_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMul_exprContext() *Mul_exprContext {
	var p = new(Mul_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_mul_expr
	return p
}

func (*Mul_exprContext) IsMul_exprContext() {}

func NewMul_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mul_exprContext {
	var p = new(Mul_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_mul_expr

	return p
}

func (s *Mul_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Mul_exprContext) AllUnary_sign_expr() []IUnary_sign_exprContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IUnary_sign_exprContext)(nil)).Elem())
	var tst = make([]IUnary_sign_exprContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IUnary_sign_exprContext)
		}
	}

	return tst
}

func (s *Mul_exprContext) Unary_sign_expr(i int) IUnary_sign_exprContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IUnary_sign_exprContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IUnary_sign_exprContext)
}

func (s *Mul_exprContext) AllMULT() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserMULT)
}

func (s *Mul_exprContext) MULT(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserMULT, i)
}

func (s *Mul_exprContext) AllDIV() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserDIV)
}

func (s *Mul_exprContext) DIV(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDIV, i)
}

func (s *Mul_exprContext) AllCARAT() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserCARAT)
}

func (s *Mul_exprContext) CARAT(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCARAT, i)
}

func (s *Mul_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mul_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mul_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterMul_expr(s)
	}
}

func (s *Mul_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitMul_expr(s)
	}
}

func (p *powerbuilderParser) Mul_expr() (localctx IMul_exprContext) {
	localctx = NewMul_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, powerbuilderParserRULE_mul_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(738)
		p.Unary_sign_expr()
	}
	p.SetState(743)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la-88)&-(0x1f+1)) == 0 && ((1<<uint((_la-88)))&((1<<(powerbuilderParserMULT-88))|(1<<(powerbuilderParserDIV-88))|(1<<(powerbuilderParserCARAT-88)))) != 0 {
		{
			p.SetState(739)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-88)&-(0x1f+1)) == 0 && ((1<<uint((_la-88)))&((1<<(powerbuilderParserMULT-88))|(1<<(powerbuilderParserDIV-88))|(1<<(powerbuilderParserCARAT-88)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(740)
			p.Unary_sign_expr()
		}

		p.SetState(745)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUnary_sign_exprContext is an interface to support dynamic dispatch.
type IUnary_sign_exprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnary_sign_exprContext differentiates from other interfaces.
	IsUnary_sign_exprContext()
}

type Unary_sign_exprContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnary_sign_exprContext() *Unary_sign_exprContext {
	var p = new(Unary_sign_exprContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_unary_sign_expr
	return p
}

func (*Unary_sign_exprContext) IsUnary_sign_exprContext() {}

func NewUnary_sign_exprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Unary_sign_exprContext {
	var p = new(Unary_sign_exprContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_unary_sign_expr

	return p
}

func (s *Unary_sign_exprContext) GetParser() antlr.Parser { return s.parser }

func (s *Unary_sign_exprContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLPAREN, 0)
}

func (s *Unary_sign_exprContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Unary_sign_exprContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRPAREN, 0)
}

func (s *Unary_sign_exprContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *Unary_sign_exprContext) MINUS() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserMINUS, 0)
}

func (s *Unary_sign_exprContext) PLUS() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserPLUS, 0)
}

func (s *Unary_sign_exprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Unary_sign_exprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Unary_sign_exprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterUnary_sign_expr(s)
	}
}

func (s *Unary_sign_exprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitUnary_sign_expr(s)
	}
}

func (p *powerbuilderParser) Unary_sign_expr() (localctx IUnary_sign_exprContext) {
	localctx = NewUnary_sign_exprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, powerbuilderParserRULE_unary_sign_expr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(754)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case powerbuilderParserLPAREN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(746)
			p.Match(powerbuilderParserLPAREN)
		}
		{
			p.SetState(747)
			p.Expression()
		}
		{
			p.SetState(748)
			p.Match(powerbuilderParserRPAREN)
		}

	case powerbuilderParserDATA_TYPE_SUB, powerbuilderParserBOOLEAN_ATOM, powerbuilderParserEVENT, powerbuilderParserDESCRIBE, powerbuilderParserSUPER, powerbuilderParserPLUS, powerbuilderParserMINUS, powerbuilderParserDQUOTED_STRING, powerbuilderParserQUOTED_STRING, powerbuilderParserENUM, powerbuilderParserID, powerbuilderParserNUMBER, powerbuilderParserDATE, powerbuilderParserTIME:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(751)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == powerbuilderParserPLUS || _la == powerbuilderParserMINUS {
			{
				p.SetState(750)
				_la = p.GetTokenStream().LA(1)

				if !(_la == powerbuilderParserPLUS || _la == powerbuilderParserMINUS) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(753)
			p.Atom()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) If_simple_statement() IIf_simple_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_simple_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_simple_statementContext)
}

func (s *StatementContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDESCRIBE, 0)
}

func (s *StatementContext) Identifier_name() IIdentifier_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_nameContext)
}

func (s *StatementContext) Assignment_statement() IAssignment_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_statementContext)
}

func (s *StatementContext) Statement_sub() IStatement_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatement_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatement_subContext)
}

func (s *StatementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserSEMI, 0)
}

func (s *StatementContext) If_statement() IIf_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIf_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIf_statementContext)
}

func (s *StatementContext) TRY() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTRY, 0)
}

func (s *StatementContext) Post_event() IPost_eventContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPost_eventContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPost_eventContext)
}

func (s *StatementContext) Function_call_statement() IFunction_call_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_call_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_call_statementContext)
}

func (s *StatementContext) Event_call_statement() IEvent_call_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_call_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_call_statementContext)
}

func (s *StatementContext) Constant_decl() IConstant_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IConstant_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IConstant_declContext)
}

func (s *StatementContext) Variable_decl() IVariable_declContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_declContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_declContext)
}

func (s *StatementContext) Super_call_statement() ISuper_call_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuper_call_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuper_call_statementContext)
}

func (s *StatementContext) Do_loop_while_statement() IDo_loop_while_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDo_loop_while_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDo_loop_while_statementContext)
}

func (s *StatementContext) Do_while_loop_statement() IDo_while_loop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDo_while_loop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDo_while_loop_statementContext)
}

func (s *StatementContext) Create_call_statement() ICreate_call_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreate_call_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreate_call_statementContext)
}

func (s *StatementContext) Destroy_call_statement() IDestroy_call_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDestroy_call_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDestroy_call_statementContext)
}

func (s *StatementContext) Label_stat() ILabel_statContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILabel_statContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILabel_statContext)
}

func (s *StatementContext) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StatementContext) Throw_stat() IThrow_statContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThrow_statContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThrow_statContext)
}

func (s *StatementContext) Goto_stat() IGoto_statContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGoto_statContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGoto_statContext)
}

func (s *StatementContext) Choose_statement() IChoose_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChoose_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IChoose_statementContext)
}

func (s *StatementContext) Return_statement() IReturn_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturn_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturn_statementContext)
}

func (s *StatementContext) For_loop_statement() IFor_loop_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFor_loop_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFor_loop_statementContext)
}

func (s *StatementContext) Continue_statement() IContinue_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinue_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinue_statementContext)
}

func (s *StatementContext) Exit_statement() IExit_statementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExit_statementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExit_statementContext)
}

func (s *StatementContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitStatement(s)
	}
}

func (p *powerbuilderParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, powerbuilderParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(785)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 101, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(756)
			p.If_simple_statement()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(757)
			p.Match(powerbuilderParserDESCRIBE)
		}
		{
			p.SetState(758)
			p.Identifier_name()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(759)
			p.Assignment_statement()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(760)
			p.Statement_sub()
		}
		{
			p.SetState(761)
			p.Match(powerbuilderParserSEMI)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(763)
			p.If_statement()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(764)
			p.Match(powerbuilderParserTRY)
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(765)
			p.Post_event()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(766)
			p.Function_call_statement()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(767)
			p.Event_call_statement()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(768)
			p.Constant_decl()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(769)
			p.Variable_decl()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(770)
			p.Super_call_statement()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(771)
			p.Do_loop_while_statement()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(772)
			p.Do_while_loop_statement()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(773)
			p.Create_call_statement()
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(774)
			p.Destroy_call_statement()
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(775)
			p.Label_stat()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(776)
			p.Identifier()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(777)
			p.Throw_stat()
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(778)
			p.Goto_stat()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(779)
			p.Choose_statement()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(780)
			p.Return_statement()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(781)
			p.For_loop_statement()
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(782)
			p.Continue_statement()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(783)
			p.Exit_statement()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(784)
			p.Atom()
		}

	}

	return localctx
}

// IStatement_subContext is an interface to support dynamic dispatch.
type IStatement_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatement_subContext differentiates from other interfaces.
	IsStatement_subContext()
}

type Statement_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatement_subContext() *Statement_subContext {
	var p = new(Statement_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_statement_sub
	return p
}

func (*Statement_subContext) IsStatement_subContext() {}

func NewStatement_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Statement_subContext {
	var p = new(Statement_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_statement_sub

	return p
}

func (s *Statement_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Statement_subContext) Function_virtual_call_expression_sub() IFunction_virtual_call_expression_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_virtual_call_expression_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_virtual_call_expression_subContext)
}

func (s *Statement_subContext) Function_call_expression_sub() IFunction_call_expression_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_call_expression_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_call_expression_subContext)
}

func (s *Statement_subContext) Return_sub() IReturn_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturn_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturn_subContext)
}

func (s *Statement_subContext) Open_call_sub() IOpen_call_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpen_call_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOpen_call_subContext)
}

func (s *Statement_subContext) Close_call_sub() IClose_call_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClose_call_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClose_call_subContext)
}

func (s *Statement_subContext) Variable_decl_sub() IVariable_decl_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_decl_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVariable_decl_subContext)
}

func (s *Statement_subContext) Super_call_sub() ISuper_call_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuper_call_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuper_call_subContext)
}

func (s *Statement_subContext) Create_call_sub() ICreate_call_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreate_call_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreate_call_subContext)
}

func (s *Statement_subContext) Destroy_call_sub() IDestroy_call_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDestroy_call_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDestroy_call_subContext)
}

func (s *Statement_subContext) Continue_sub() IContinue_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinue_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinue_subContext)
}

func (s *Statement_subContext) Goto_stat_sub() IGoto_stat_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGoto_stat_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGoto_stat_subContext)
}

func (s *Statement_subContext) Assignment_sub() IAssignment_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_subContext)
}

func (s *Statement_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Statement_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Statement_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterStatement_sub(s)
	}
}

func (s *Statement_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitStatement_sub(s)
	}
}

func (p *powerbuilderParser) Statement_sub() (localctx IStatement_subContext) {
	localctx = NewStatement_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, powerbuilderParserRULE_statement_sub)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(799)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(787)
			p.Function_virtual_call_expression_sub()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(788)
			p.Function_call_expression_sub()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(789)
			p.Return_sub()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(790)
			p.Open_call_sub()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(791)
			p.Close_call_sub()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(792)
			p.Variable_decl_sub()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(793)
			p.Super_call_sub()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(794)
			p.Create_call_sub()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(795)
			p.Destroy_call_sub()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(796)
			p.Continue_sub()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(797)
			p.Goto_stat_sub()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(798)
			p.Assignment_sub()
		}

	}

	return localctx
}

// IAssignment_subContext is an interface to support dynamic dispatch.
type IAssignment_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignment_subContext differentiates from other interfaces.
	IsAssignment_subContext()
}

type Assignment_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_subContext() *Assignment_subContext {
	var p = new(Assignment_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_assignment_sub
	return p
}

func (*Assignment_subContext) IsAssignment_subContext() {}

func NewAssignment_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_subContext {
	var p = new(Assignment_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_assignment_sub

	return p
}

func (s *Assignment_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_subContext) Lvalue_sub() ILvalue_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILvalue_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILvalue_subContext)
}

func (s *Assignment_subContext) EQ() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEQ, 0)
}

func (s *Assignment_subContext) PLUSEQ() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserPLUSEQ, 0)
}

func (s *Assignment_subContext) MINUSEQ() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserMINUSEQ, 0)
}

func (s *Assignment_subContext) MULTEQ() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserMULTEQ, 0)
}

func (s *Assignment_subContext) DIVEQ() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDIVEQ, 0)
}

func (s *Assignment_subContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Assignment_subContext) NOT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserNOT, 0)
}

func (s *Assignment_subContext) LCURLY() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLCURLY, 0)
}

func (s *Assignment_subContext) Boolean_expression() IBoolean_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBoolean_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBoolean_expressionContext)
}

func (s *Assignment_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterAssignment_sub(s)
	}
}

func (s *Assignment_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitAssignment_sub(s)
	}
}

func (p *powerbuilderParser) Assignment_sub() (localctx IAssignment_subContext) {
	localctx = NewAssignment_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, powerbuilderParserRULE_assignment_sub)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(801)
		p.Lvalue_sub()
	}
	{
		p.SetState(802)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(powerbuilderParserEQ-77))|(1<<(powerbuilderParserPLUSEQ-77))|(1<<(powerbuilderParserMINUSEQ-77))|(1<<(powerbuilderParserMULTEQ-77))|(1<<(powerbuilderParserDIVEQ-77)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(807)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(803)
			p.Match(powerbuilderParserNOT)
		}

	case 2:
		{
			p.SetState(804)
			p.Match(powerbuilderParserLCURLY)
		}

	case 3:
		{
			p.SetState(805)
			p.Boolean_expression()
		}

	case 4:
		{
			p.SetState(806)
			p.Expression()
		}

	}

	return localctx
}

// IAssignment_statementContext is an interface to support dynamic dispatch.
type IAssignment_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignment_statementContext differentiates from other interfaces.
	IsAssignment_statementContext()
}

type Assignment_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignment_statementContext() *Assignment_statementContext {
	var p = new(Assignment_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_assignment_statement
	return p
}

func (*Assignment_statementContext) IsAssignment_statementContext() {}

func NewAssignment_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Assignment_statementContext {
	var p = new(Assignment_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_assignment_statement

	return p
}

func (s *Assignment_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Assignment_statementContext) Assignment_sub() IAssignment_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAssignment_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAssignment_subContext)
}

func (s *Assignment_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserSEMI, 0)
}

func (s *Assignment_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Assignment_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Assignment_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterAssignment_statement(s)
	}
}

func (s *Assignment_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitAssignment_statement(s)
	}
}

func (p *powerbuilderParser) Assignment_statement() (localctx IAssignment_statementContext) {
	localctx = NewAssignment_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, powerbuilderParserRULE_assignment_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(809)
		p.Assignment_sub()
	}
	p.SetState(811)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 104, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(810)
			p.Match(powerbuilderParserSEMI)
		}

	}

	return localctx
}

// ILvalue_subContext is an interface to support dynamic dispatch.
type ILvalue_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLvalue_subContext differentiates from other interfaces.
	IsLvalue_subContext()
}

type Lvalue_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLvalue_subContext() *Lvalue_subContext {
	var p = new(Lvalue_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_lvalue_sub
	return p
}

func (*Lvalue_subContext) IsLvalue_subContext() {}

func NewLvalue_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Lvalue_subContext {
	var p = new(Lvalue_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_lvalue_sub

	return p
}

func (s *Lvalue_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Lvalue_subContext) Atom_sub() IAtom_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_subContext)
}

func (s *Lvalue_subContext) DOT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDOT, 0)
}

func (s *Lvalue_subContext) Identifier_name_ex() IIdentifier_name_exContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_name_exContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_name_exContext)
}

func (s *Lvalue_subContext) Atom_sub_call1() IAtom_sub_call1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_sub_call1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_sub_call1Context)
}

func (s *Lvalue_subContext) Atom_sub_array1() IAtom_sub_array1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_sub_array1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_sub_array1Context)
}

func (s *Lvalue_subContext) Atom_sub_ref1() IAtom_sub_ref1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_sub_ref1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_sub_ref1Context)
}

func (s *Lvalue_subContext) Atom_sub_member1() IAtom_sub_member1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_sub_member1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_sub_member1Context)
}

func (s *Lvalue_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Lvalue_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Lvalue_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterLvalue_sub(s)
	}
}

func (s *Lvalue_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitLvalue_sub(s)
	}
}

func (p *powerbuilderParser) Lvalue_sub() (localctx ILvalue_subContext) {
	localctx = NewLvalue_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, powerbuilderParserRULE_lvalue_sub)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(821)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(813)
			p.Atom_sub()
		}

		{
			p.SetState(814)
			p.Match(powerbuilderParserDOT)
		}
		{
			p.SetState(815)
			p.Identifier_name_ex()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(817)
			p.Atom_sub_call1()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(818)
			p.Atom_sub_array1()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(819)
			p.Atom_sub_ref1()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(820)
			p.Atom_sub_member1()
		}

	}

	return localctx
}

// IReturn_subContext is an interface to support dynamic dispatch.
type IReturn_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturn_subContext differentiates from other interfaces.
	IsReturn_subContext()
}

type Return_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturn_subContext() *Return_subContext {
	var p = new(Return_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_return_sub
	return p
}

func (*Return_subContext) IsReturn_subContext() {}

func NewReturn_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Return_subContext {
	var p = new(Return_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_return_sub

	return p
}

func (s *Return_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Return_subContext) RETURN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRETURN, 0)
}

func (s *Return_subContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Return_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Return_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterReturn_sub(s)
	}
}

func (s *Return_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitReturn_sub(s)
	}
}

func (p *powerbuilderParser) Return_sub() (localctx IReturn_subContext) {
	localctx = NewReturn_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, powerbuilderParserRULE_return_sub)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(823)
		p.Match(powerbuilderParserRETURN)
	}
	p.SetState(825)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(824)
			p.Expression()
		}

	}

	return localctx
}

// IReturn_statementContext is an interface to support dynamic dispatch.
type IReturn_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturn_statementContext differentiates from other interfaces.
	IsReturn_statementContext()
}

type Return_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturn_statementContext() *Return_statementContext {
	var p = new(Return_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_return_statement
	return p
}

func (*Return_statementContext) IsReturn_statementContext() {}

func NewReturn_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Return_statementContext {
	var p = new(Return_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_return_statement

	return p
}

func (s *Return_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Return_statementContext) Return_sub() IReturn_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IReturn_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IReturn_subContext)
}

func (s *Return_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Return_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Return_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterReturn_statement(s)
	}
}

func (s *Return_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitReturn_statement(s)
	}
}

func (p *powerbuilderParser) Return_statement() (localctx IReturn_statementContext) {
	localctx = NewReturn_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, powerbuilderParserRULE_return_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(827)
		p.Return_sub()
	}

	return localctx
}

// IFunction_call_expression_subContext is an interface to support dynamic dispatch.
type IFunction_call_expression_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_call_expression_subContext differentiates from other interfaces.
	IsFunction_call_expression_subContext()
}

type Function_call_expression_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_call_expression_subContext() *Function_call_expression_subContext {
	var p = new(Function_call_expression_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_function_call_expression_sub
	return p
}

func (*Function_call_expression_subContext) IsFunction_call_expression_subContext() {}

func NewFunction_call_expression_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_call_expression_subContext {
	var p = new(Function_call_expression_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_function_call_expression_sub

	return p
}

func (s *Function_call_expression_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_call_expression_subContext) Atom_sub() IAtom_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_subContext)
}

func (s *Function_call_expression_subContext) DOT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDOT, 0)
}

func (s *Function_call_expression_subContext) Identifier_name_ex() IIdentifier_name_exContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_name_exContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_name_exContext)
}

func (s *Function_call_expression_subContext) Atom_sub_call1() IAtom_sub_call1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_sub_call1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_sub_call1Context)
}

func (s *Function_call_expression_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_call_expression_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_call_expression_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterFunction_call_expression_sub(s)
	}
}

func (s *Function_call_expression_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitFunction_call_expression_sub(s)
	}
}

func (p *powerbuilderParser) Function_call_expression_sub() (localctx IFunction_call_expression_subContext) {
	localctx = NewFunction_call_expression_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, powerbuilderParserRULE_function_call_expression_sub)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(834)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 107, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(829)
			p.Atom_sub()
		}

		{
			p.SetState(830)
			p.Match(powerbuilderParserDOT)
		}
		{
			p.SetState(831)
			p.Identifier_name_ex()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(833)
			p.Atom_sub_call1()
		}

	}

	return localctx
}

// IFunction_virtual_call_expression_subContext is an interface to support dynamic dispatch.
type IFunction_virtual_call_expression_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_virtual_call_expression_subContext differentiates from other interfaces.
	IsFunction_virtual_call_expression_subContext()
}

type Function_virtual_call_expression_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_virtual_call_expression_subContext() *Function_virtual_call_expression_subContext {
	var p = new(Function_virtual_call_expression_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_function_virtual_call_expression_sub
	return p
}

func (*Function_virtual_call_expression_subContext) IsFunction_virtual_call_expression_subContext() {}

func NewFunction_virtual_call_expression_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_virtual_call_expression_subContext {
	var p = new(Function_virtual_call_expression_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_function_virtual_call_expression_sub

	return p
}

func (s *Function_virtual_call_expression_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_virtual_call_expression_subContext) Identifier_name() IIdentifier_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_nameContext)
}

func (s *Function_virtual_call_expression_subContext) DOT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDOT, 0)
}

func (s *Function_virtual_call_expression_subContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDYNAMIC, 0)
}

func (s *Function_virtual_call_expression_subContext) Function_call_expression_sub() IFunction_call_expression_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_call_expression_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_call_expression_subContext)
}

func (s *Function_virtual_call_expression_subContext) EVENT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEVENT, 0)
}

func (s *Function_virtual_call_expression_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_virtual_call_expression_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_virtual_call_expression_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterFunction_virtual_call_expression_sub(s)
	}
}

func (s *Function_virtual_call_expression_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitFunction_virtual_call_expression_sub(s)
	}
}

func (p *powerbuilderParser) Function_virtual_call_expression_sub() (localctx IFunction_virtual_call_expression_subContext) {
	localctx = NewFunction_virtual_call_expression_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, powerbuilderParserRULE_function_virtual_call_expression_sub)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(850)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 109, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(836)
			p.Identifier_name()
		}
		{
			p.SetState(837)
			p.Match(powerbuilderParserDOT)
		}
		{
			p.SetState(838)
			p.Match(powerbuilderParserDYNAMIC)
		}
		p.SetState(840)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == powerbuilderParserEVENT {
			{
				p.SetState(839)
				p.Match(powerbuilderParserEVENT)
			}

		}
		{
			p.SetState(842)
			p.Function_call_expression_sub()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(844)
			p.Identifier_name()
		}
		{
			p.SetState(845)
			p.Match(powerbuilderParserDOT)
		}
		{
			p.SetState(846)
			p.Match(powerbuilderParserEVENT)
		}
		{
			p.SetState(847)
			p.Match(powerbuilderParserDYNAMIC)
		}
		{
			p.SetState(848)
			p.Function_call_expression_sub()
		}

	}

	return localctx
}

// IOpen_call_subContext is an interface to support dynamic dispatch.
type IOpen_call_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpen_call_subContext differentiates from other interfaces.
	IsOpen_call_subContext()
}

type Open_call_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpen_call_subContext() *Open_call_subContext {
	var p = new(Open_call_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_open_call_sub
	return p
}

func (*Open_call_subContext) IsOpen_call_subContext() {}

func NewOpen_call_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Open_call_subContext {
	var p = new(Open_call_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_open_call_sub

	return p
}

func (s *Open_call_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Open_call_subContext) OPEN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserOPEN, 0)
}

func (s *Open_call_subContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLPAREN, 0)
}

func (s *Open_call_subContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *Open_call_subContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRPAREN, 0)
}

func (s *Open_call_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Open_call_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Open_call_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterOpen_call_sub(s)
	}
}

func (s *Open_call_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitOpen_call_sub(s)
	}
}

func (p *powerbuilderParser) Open_call_sub() (localctx IOpen_call_subContext) {
	localctx = NewOpen_call_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, powerbuilderParserRULE_open_call_sub)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(852)
		p.Match(powerbuilderParserOPEN)
	}
	{
		p.SetState(853)
		p.Match(powerbuilderParserLPAREN)
	}
	{
		p.SetState(854)
		p.Expression_list()
	}
	{
		p.SetState(855)
		p.Match(powerbuilderParserRPAREN)
	}

	return localctx
}

// IClose_call_subContext is an interface to support dynamic dispatch.
type IClose_call_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClose_call_subContext differentiates from other interfaces.
	IsClose_call_subContext()
}

type Close_call_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClose_call_subContext() *Close_call_subContext {
	var p = new(Close_call_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_close_call_sub
	return p
}

func (*Close_call_subContext) IsClose_call_subContext() {}

func NewClose_call_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Close_call_subContext {
	var p = new(Close_call_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_close_call_sub

	return p
}

func (s *Close_call_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Close_call_subContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCLOSE, 0)
}

func (s *Close_call_subContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLPAREN, 0)
}

func (s *Close_call_subContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *Close_call_subContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRPAREN, 0)
}

func (s *Close_call_subContext) HALT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserHALT, 0)
}

func (s *Close_call_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Close_call_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Close_call_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterClose_call_sub(s)
	}
}

func (s *Close_call_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitClose_call_sub(s)
	}
}

func (p *powerbuilderParser) Close_call_sub() (localctx IClose_call_subContext) {
	localctx = NewClose_call_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, powerbuilderParserRULE_close_call_sub)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(864)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case powerbuilderParserCLOSE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(857)
			p.Match(powerbuilderParserCLOSE)
		}
		{
			p.SetState(858)
			p.Match(powerbuilderParserLPAREN)
		}
		{
			p.SetState(859)
			p.Expression_list()
		}
		{
			p.SetState(860)
			p.Match(powerbuilderParserRPAREN)
		}

	case powerbuilderParserHALT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(862)
			p.Match(powerbuilderParserHALT)
		}
		{
			p.SetState(863)
			p.Match(powerbuilderParserCLOSE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFunction_call_statementContext is an interface to support dynamic dispatch.
type IFunction_call_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunction_call_statementContext differentiates from other interfaces.
	IsFunction_call_statementContext()
}

type Function_call_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunction_call_statementContext() *Function_call_statementContext {
	var p = new(Function_call_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_function_call_statement
	return p
}

func (*Function_call_statementContext) IsFunction_call_statementContext() {}

func NewFunction_call_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Function_call_statementContext {
	var p = new(Function_call_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_function_call_statement

	return p
}

func (s *Function_call_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Function_call_statementContext) Function_call_expression_sub() IFunction_call_expression_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_call_expression_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_call_expression_subContext)
}

func (s *Function_call_statementContext) Function_virtual_call_expression_sub() IFunction_virtual_call_expression_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFunction_virtual_call_expression_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFunction_virtual_call_expression_subContext)
}

func (s *Function_call_statementContext) Open_call_sub() IOpen_call_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IOpen_call_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IOpen_call_subContext)
}

func (s *Function_call_statementContext) Close_call_sub() IClose_call_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IClose_call_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IClose_call_subContext)
}

func (s *Function_call_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Function_call_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Function_call_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterFunction_call_statement(s)
	}
}

func (s *Function_call_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitFunction_call_statement(s)
	}
}

func (p *powerbuilderParser) Function_call_statement() (localctx IFunction_call_statementContext) {
	localctx = NewFunction_call_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, powerbuilderParserRULE_function_call_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(870)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(866)
			p.Function_call_expression_sub()
		}

	case 2:
		{
			p.SetState(867)
			p.Function_virtual_call_expression_sub()
		}

	case 3:
		{
			p.SetState(868)
			p.Open_call_sub()
		}

	case 4:
		{
			p.SetState(869)
			p.Close_call_sub()
		}

	}

	return localctx
}

// ISuper_call_subContext is an interface to support dynamic dispatch.
type ISuper_call_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSuper_call_subContext differentiates from other interfaces.
	IsSuper_call_subContext()
}

type Super_call_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuper_call_subContext() *Super_call_subContext {
	var p = new(Super_call_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_super_call_sub
	return p
}

func (*Super_call_subContext) IsSuper_call_subContext() {}

func NewSuper_call_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Super_call_subContext {
	var p = new(Super_call_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_super_call_sub

	return p
}

func (s *Super_call_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Super_call_subContext) CALL() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCALL, 0)
}

func (s *Super_call_subContext) Atom_sub_member1() IAtom_sub_member1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_sub_member1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_sub_member1Context)
}

func (s *Super_call_subContext) Identifier_name() IIdentifier_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_nameContext)
}

func (s *Super_call_subContext) TICK() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTICK, 0)
}

func (s *Super_call_subContext) Atom_sub_call1() IAtom_sub_call1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_sub_call1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_sub_call1Context)
}

func (s *Super_call_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Super_call_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Super_call_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterSuper_call_sub(s)
	}
}

func (s *Super_call_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitSuper_call_sub(s)
	}
}

func (p *powerbuilderParser) Super_call_sub() (localctx ISuper_call_subContext) {
	localctx = NewSuper_call_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, powerbuilderParserRULE_super_call_sub)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(872)
		p.Match(powerbuilderParserCALL)
	}
	p.SetState(876)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 112, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(873)
			p.Identifier_name()
		}
		{
			p.SetState(874)
			p.Match(powerbuilderParserTICK)
		}

	}
	p.SetState(880)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 113, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(878)
			p.Atom_sub_call1()
		}

	case 2:
		{
			p.SetState(879)
			p.Atom_sub_member1()
		}

	}

	return localctx
}

// ISuper_call_statementContext is an interface to support dynamic dispatch.
type ISuper_call_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSuper_call_statementContext differentiates from other interfaces.
	IsSuper_call_statementContext()
}

type Super_call_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySuper_call_statementContext() *Super_call_statementContext {
	var p = new(Super_call_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_super_call_statement
	return p
}

func (*Super_call_statementContext) IsSuper_call_statementContext() {}

func NewSuper_call_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Super_call_statementContext {
	var p = new(Super_call_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_super_call_statement

	return p
}

func (s *Super_call_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Super_call_statementContext) Super_call_sub() ISuper_call_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISuper_call_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISuper_call_subContext)
}

func (s *Super_call_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Super_call_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Super_call_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterSuper_call_statement(s)
	}
}

func (s *Super_call_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitSuper_call_statement(s)
	}
}

func (p *powerbuilderParser) Super_call_statement() (localctx ISuper_call_statementContext) {
	localctx = NewSuper_call_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, powerbuilderParserRULE_super_call_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(882)
		p.Super_call_sub()
	}

	return localctx
}

// IEvent_call_statement_subContext is an interface to support dynamic dispatch.
type IEvent_call_statement_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_call_statement_subContext differentiates from other interfaces.
	IsEvent_call_statement_subContext()
}

type Event_call_statement_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_call_statement_subContext() *Event_call_statement_subContext {
	var p = new(Event_call_statement_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_event_call_statement_sub
	return p
}

func (*Event_call_statement_subContext) IsEvent_call_statement_subContext() {}

func NewEvent_call_statement_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_call_statement_subContext {
	var p = new(Event_call_statement_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_event_call_statement_sub

	return p
}

func (s *Event_call_statement_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_call_statement_subContext) EVENT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEVENT, 0)
}

func (s *Event_call_statement_subContext) Atom_sub_call1() IAtom_sub_call1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_sub_call1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_sub_call1Context)
}

func (s *Event_call_statement_subContext) AllIdentifier_name() []IIdentifier_nameContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem())
	var tst = make([]IIdentifier_nameContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IIdentifier_nameContext)
		}
	}

	return tst
}

func (s *Event_call_statement_subContext) Identifier_name(i int) IIdentifier_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_nameContext)
}

func (s *Event_call_statement_subContext) AllDOT() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserDOT)
}

func (s *Event_call_statement_subContext) DOT(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDOT, i)
}

func (s *Event_call_statement_subContext) SUPER() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserSUPER, 0)
}

func (s *Event_call_statement_subContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCOLONCOLON, 0)
}

func (s *Event_call_statement_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_call_statement_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_call_statement_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterEvent_call_statement_sub(s)
	}
}

func (s *Event_call_statement_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitEvent_call_statement_sub(s)
	}
}

func (p *powerbuilderParser) Event_call_statement_sub() (localctx IEvent_call_statement_subContext) {
	localctx = NewEvent_call_statement_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, powerbuilderParserRULE_event_call_statement_sub)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(893)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case powerbuilderParserID:
		{
			p.SetState(884)
			p.Identifier_name()
		}
		{
			p.SetState(885)
			p.Match(powerbuilderParserDOT)
		}
		p.SetState(889)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == powerbuilderParserID {
			{
				p.SetState(886)
				p.Identifier_name()
			}
			{
				p.SetState(887)
				p.Match(powerbuilderParserDOT)
			}

		}

	case powerbuilderParserSUPER:
		{
			p.SetState(891)
			p.Match(powerbuilderParserSUPER)
		}
		{
			p.SetState(892)
			p.Match(powerbuilderParserCOLONCOLON)
		}

	case powerbuilderParserEVENT:

	default:
	}
	{
		p.SetState(895)
		p.Match(powerbuilderParserEVENT)
	}
	{
		p.SetState(896)
		p.Atom_sub_call1()
	}

	return localctx
}

// IEvent_call_statementContext is an interface to support dynamic dispatch.
type IEvent_call_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvent_call_statementContext differentiates from other interfaces.
	IsEvent_call_statementContext()
}

type Event_call_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvent_call_statementContext() *Event_call_statementContext {
	var p = new(Event_call_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_event_call_statement
	return p
}

func (*Event_call_statementContext) IsEvent_call_statementContext() {}

func NewEvent_call_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Event_call_statementContext {
	var p = new(Event_call_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_event_call_statement

	return p
}

func (s *Event_call_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Event_call_statementContext) Event_call_statement_sub() IEvent_call_statement_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_call_statement_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_call_statement_subContext)
}

func (s *Event_call_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Event_call_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Event_call_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterEvent_call_statement(s)
	}
}

func (s *Event_call_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitEvent_call_statement(s)
	}
}

func (p *powerbuilderParser) Event_call_statement() (localctx IEvent_call_statementContext) {
	localctx = NewEvent_call_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, powerbuilderParserRULE_event_call_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(898)
		p.Event_call_statement_sub()
	}

	return localctx
}

// ICreate_call_subContext is an interface to support dynamic dispatch.
type ICreate_call_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreate_call_subContext differentiates from other interfaces.
	IsCreate_call_subContext()
}

type Create_call_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_call_subContext() *Create_call_subContext {
	var p = new(Create_call_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_create_call_sub
	return p
}

func (*Create_call_subContext) IsCreate_call_subContext() {}

func NewCreate_call_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_call_subContext {
	var p = new(Create_call_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_create_call_sub

	return p
}

func (s *Create_call_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_call_subContext) CREATE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCREATE, 0)
}

func (s *Create_call_subContext) Data_type_name() IData_type_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_nameContext)
}

func (s *Create_call_subContext) USING() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserUSING, 0)
}

func (s *Create_call_subContext) Identifier_name() IIdentifier_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_nameContext)
}

func (s *Create_call_subContext) DOT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDOT, 0)
}

func (s *Create_call_subContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLPAREN, 0)
}

func (s *Create_call_subContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRPAREN, 0)
}

func (s *Create_call_subContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *Create_call_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_call_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_call_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterCreate_call_sub(s)
	}
}

func (s *Create_call_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitCreate_call_sub(s)
	}
}

func (p *powerbuilderParser) Create_call_sub() (localctx ICreate_call_subContext) {
	localctx = NewCreate_call_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, powerbuilderParserRULE_create_call_sub)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(900)
		p.Match(powerbuilderParserCREATE)
	}
	p.SetState(902)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserUSING {
		{
			p.SetState(901)
			p.Match(powerbuilderParserUSING)
		}

	}
	p.SetState(907)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(904)
			p.Identifier_name()
		}
		{
			p.SetState(905)
			p.Match(powerbuilderParserDOT)
		}

	}
	{
		p.SetState(909)
		p.Data_type_name()
	}
	p.SetState(915)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserLPAREN {
		{
			p.SetState(910)
			p.Match(powerbuilderParserLPAREN)
		}
		p.SetState(912)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == powerbuilderParserREF || _la == powerbuilderParserCLOSE || _la == powerbuilderParserHALT || _la == powerbuilderParserLCURLY {
			{
				p.SetState(911)
				p.Expression_list()
			}

		}
		{
			p.SetState(914)
			p.Match(powerbuilderParserRPAREN)
		}

	}

	return localctx
}

// ICreate_call_statementContext is an interface to support dynamic dispatch.
type ICreate_call_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCreate_call_statementContext differentiates from other interfaces.
	IsCreate_call_statementContext()
}

type Create_call_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreate_call_statementContext() *Create_call_statementContext {
	var p = new(Create_call_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_create_call_statement
	return p
}

func (*Create_call_statementContext) IsCreate_call_statementContext() {}

func NewCreate_call_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Create_call_statementContext {
	var p = new(Create_call_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_create_call_statement

	return p
}

func (s *Create_call_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Create_call_statementContext) Create_call_sub() ICreate_call_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICreate_call_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICreate_call_subContext)
}

func (s *Create_call_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Create_call_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Create_call_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterCreate_call_statement(s)
	}
}

func (s *Create_call_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitCreate_call_statement(s)
	}
}

func (p *powerbuilderParser) Create_call_statement() (localctx ICreate_call_statementContext) {
	localctx = NewCreate_call_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, powerbuilderParserRULE_create_call_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(917)
		p.Create_call_sub()
	}

	return localctx
}

// IDestroy_call_subContext is an interface to support dynamic dispatch.
type IDestroy_call_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDestroy_call_subContext differentiates from other interfaces.
	IsDestroy_call_subContext()
}

type Destroy_call_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDestroy_call_subContext() *Destroy_call_subContext {
	var p = new(Destroy_call_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_destroy_call_sub
	return p
}

func (*Destroy_call_subContext) IsDestroy_call_subContext() {}

func NewDestroy_call_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Destroy_call_subContext {
	var p = new(Destroy_call_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_destroy_call_sub

	return p
}

func (s *Destroy_call_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Destroy_call_subContext) DESTROY() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDESTROY, 0)
}

func (s *Destroy_call_subContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Destroy_call_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Destroy_call_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Destroy_call_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterDestroy_call_sub(s)
	}
}

func (s *Destroy_call_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitDestroy_call_sub(s)
	}
}

func (p *powerbuilderParser) Destroy_call_sub() (localctx IDestroy_call_subContext) {
	localctx = NewDestroy_call_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, powerbuilderParserRULE_destroy_call_sub)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(919)
		p.Match(powerbuilderParserDESTROY)
	}
	{
		p.SetState(920)
		p.Expression()
	}

	return localctx
}

// IDestroy_call_statementContext is an interface to support dynamic dispatch.
type IDestroy_call_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDestroy_call_statementContext differentiates from other interfaces.
	IsDestroy_call_statementContext()
}

type Destroy_call_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDestroy_call_statementContext() *Destroy_call_statementContext {
	var p = new(Destroy_call_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_destroy_call_statement
	return p
}

func (*Destroy_call_statementContext) IsDestroy_call_statementContext() {}

func NewDestroy_call_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Destroy_call_statementContext {
	var p = new(Destroy_call_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_destroy_call_statement

	return p
}

func (s *Destroy_call_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Destroy_call_statementContext) Destroy_call_sub() IDestroy_call_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDestroy_call_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDestroy_call_subContext)
}

func (s *Destroy_call_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Destroy_call_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Destroy_call_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterDestroy_call_statement(s)
	}
}

func (s *Destroy_call_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitDestroy_call_statement(s)
	}
}

func (p *powerbuilderParser) Destroy_call_statement() (localctx IDestroy_call_statementContext) {
	localctx = NewDestroy_call_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, powerbuilderParserRULE_destroy_call_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(922)
		p.Destroy_call_sub()
	}

	return localctx
}

// IFor_loop_statementContext is an interface to support dynamic dispatch.
type IFor_loop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFor_loop_statementContext differentiates from other interfaces.
	IsFor_loop_statementContext()
}

type For_loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFor_loop_statementContext() *For_loop_statementContext {
	var p = new(For_loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_for_loop_statement
	return p
}

func (*For_loop_statementContext) IsFor_loop_statementContext() {}

func NewFor_loop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *For_loop_statementContext {
	var p = new(For_loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_for_loop_statement

	return p
}

func (s *For_loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *For_loop_statementContext) FOR() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserFOR, 0)
}

func (s *For_loop_statementContext) Lvalue_sub() ILvalue_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILvalue_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILvalue_subContext)
}

func (s *For_loop_statementContext) EQ() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEQ, 0)
}

func (s *For_loop_statementContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *For_loop_statementContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *For_loop_statementContext) TO() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTO, 0)
}

func (s *For_loop_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *For_loop_statementContext) NEXT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserNEXT, 0)
}

func (s *For_loop_statementContext) STEP() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserSTEP, 0)
}

func (s *For_loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *For_loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *For_loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterFor_loop_statement(s)
	}
}

func (s *For_loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitFor_loop_statement(s)
	}
}

func (p *powerbuilderParser) For_loop_statement() (localctx IFor_loop_statementContext) {
	localctx = NewFor_loop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, powerbuilderParserRULE_for_loop_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(924)
		p.Match(powerbuilderParserFOR)
	}
	{
		p.SetState(925)
		p.Lvalue_sub()
	}
	{
		p.SetState(926)
		p.Match(powerbuilderParserEQ)
	}
	{
		p.SetState(927)
		p.Expression()
	}
	{
		p.SetState(928)
		p.Match(powerbuilderParserTO)
	}
	{
		p.SetState(929)
		p.Expression()
	}
	p.SetState(932)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserSTEP {
		{
			p.SetState(930)
			p.Match(powerbuilderParserSTEP)
		}
		{
			p.SetState(931)
			p.Expression()
		}

	}
	{
		p.SetState(934)
		p.Statement()
	}
	{
		p.SetState(935)
		p.Match(powerbuilderParserNEXT)
	}

	return localctx
}

// IDo_while_loop_statementContext is an interface to support dynamic dispatch.
type IDo_while_loop_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDo_while_loop_statementContext differentiates from other interfaces.
	IsDo_while_loop_statementContext()
}

type Do_while_loop_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDo_while_loop_statementContext() *Do_while_loop_statementContext {
	var p = new(Do_while_loop_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_do_while_loop_statement
	return p
}

func (*Do_while_loop_statementContext) IsDo_while_loop_statementContext() {}

func NewDo_while_loop_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Do_while_loop_statementContext {
	var p = new(Do_while_loop_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_do_while_loop_statement

	return p
}

func (s *Do_while_loop_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Do_while_loop_statementContext) DO() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDO, 0)
}

func (s *Do_while_loop_statementContext) Boolean_expression() IBoolean_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBoolean_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBoolean_expressionContext)
}

func (s *Do_while_loop_statementContext) LOOP() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLOOP, 0)
}

func (s *Do_while_loop_statementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserWHILE, 0)
}

func (s *Do_while_loop_statementContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserUNTIL, 0)
}

func (s *Do_while_loop_statementContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Do_while_loop_statementContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Do_while_loop_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Do_while_loop_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Do_while_loop_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterDo_while_loop_statement(s)
	}
}

func (s *Do_while_loop_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitDo_while_loop_statement(s)
	}
}

func (p *powerbuilderParser) Do_while_loop_statement() (localctx IDo_while_loop_statementContext) {
	localctx = NewDo_while_loop_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, powerbuilderParserRULE_do_while_loop_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(937)
		p.Match(powerbuilderParserDO)
	}
	{
		p.SetState(938)
		_la = p.GetTokenStream().LA(1)

		if !(_la == powerbuilderParserWHILE || _la == powerbuilderParserUNTIL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(939)
		p.Boolean_expression()
	}
	p.SetState(943)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserDATA_TYPE_SUB)|(1<<powerbuilderParserBOOLEAN_ATOM)|(1<<powerbuilderParserGLOBAL)|(1<<powerbuilderParserINDIRECT)|(1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserPRIVATEWRITE)|(1<<powerbuilderParserPROTECTED)|(1<<powerbuilderParserPRIVATEREAD)|(1<<powerbuilderParserPROTECTEDREAD)|(1<<powerbuilderParserPROTECTEDWRITE)|(1<<powerbuilderParserLOCAL)|(1<<powerbuilderParserEVENT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(powerbuilderParserOPEN-32))|(1<<(powerbuilderParserGOTO-32))|(1<<(powerbuilderParserIF-32))|(1<<(powerbuilderParserTRY-32))|(1<<(powerbuilderParserEXIT-32))|(1<<(powerbuilderParserCHOOSE-32))|(1<<(powerbuilderParserCONTINUE-32))|(1<<(powerbuilderParserDO-32))|(1<<(powerbuilderParserFOR-32))|(1<<(powerbuilderParserCLOSE-32))|(1<<(powerbuilderParserTHROW-32))|(1<<(powerbuilderParserCREATE-32))|(1<<(powerbuilderParserDESTROY-32))|(1<<(powerbuilderParserPOST-32))|(1<<(powerbuilderParserTRIGGER-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(powerbuilderParserDESCRIBE-64))|(1<<(powerbuilderParserRETURN-64))|(1<<(powerbuilderParserCALL-64))|(1<<(powerbuilderParserHALT-64))|(1<<(powerbuilderParserSUPER-64)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(powerbuilderParserDQUOTED_STRING-101))|(1<<(powerbuilderParserQUOTED_STRING-101))|(1<<(powerbuilderParserENUM-101))|(1<<(powerbuilderParserID-101))|(1<<(powerbuilderParserSEMI-101))|(1<<(powerbuilderParserNUMBER-101))|(1<<(powerbuilderParserDATE-101))|(1<<(powerbuilderParserTIME-101)))) != 0) {
		{
			p.SetState(940)
			p.Statement()
		}

		p.SetState(945)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(946)
		p.Match(powerbuilderParserLOOP)
	}

	return localctx
}

// IDo_loop_while_statementContext is an interface to support dynamic dispatch.
type IDo_loop_while_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDo_loop_while_statementContext differentiates from other interfaces.
	IsDo_loop_while_statementContext()
}

type Do_loop_while_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDo_loop_while_statementContext() *Do_loop_while_statementContext {
	var p = new(Do_loop_while_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_do_loop_while_statement
	return p
}

func (*Do_loop_while_statementContext) IsDo_loop_while_statementContext() {}

func NewDo_loop_while_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Do_loop_while_statementContext {
	var p = new(Do_loop_while_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_do_loop_while_statement

	return p
}

func (s *Do_loop_while_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Do_loop_while_statementContext) DO() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDO, 0)
}

func (s *Do_loop_while_statementContext) LOOP() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLOOP, 0)
}

func (s *Do_loop_while_statementContext) Boolean_expression() IBoolean_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBoolean_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBoolean_expressionContext)
}

func (s *Do_loop_while_statementContext) WHILE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserWHILE, 0)
}

func (s *Do_loop_while_statementContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserUNTIL, 0)
}

func (s *Do_loop_while_statementContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Do_loop_while_statementContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Do_loop_while_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Do_loop_while_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Do_loop_while_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterDo_loop_while_statement(s)
	}
}

func (s *Do_loop_while_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitDo_loop_while_statement(s)
	}
}

func (p *powerbuilderParser) Do_loop_while_statement() (localctx IDo_loop_while_statementContext) {
	localctx = NewDo_loop_while_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, powerbuilderParserRULE_do_loop_while_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(948)
		p.Match(powerbuilderParserDO)
	}
	p.SetState(952)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserDATA_TYPE_SUB)|(1<<powerbuilderParserBOOLEAN_ATOM)|(1<<powerbuilderParserGLOBAL)|(1<<powerbuilderParserINDIRECT)|(1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserPRIVATEWRITE)|(1<<powerbuilderParserPROTECTED)|(1<<powerbuilderParserPRIVATEREAD)|(1<<powerbuilderParserPROTECTEDREAD)|(1<<powerbuilderParserPROTECTEDWRITE)|(1<<powerbuilderParserLOCAL)|(1<<powerbuilderParserEVENT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(powerbuilderParserOPEN-32))|(1<<(powerbuilderParserGOTO-32))|(1<<(powerbuilderParserIF-32))|(1<<(powerbuilderParserTRY-32))|(1<<(powerbuilderParserEXIT-32))|(1<<(powerbuilderParserCHOOSE-32))|(1<<(powerbuilderParserCONTINUE-32))|(1<<(powerbuilderParserDO-32))|(1<<(powerbuilderParserFOR-32))|(1<<(powerbuilderParserCLOSE-32))|(1<<(powerbuilderParserTHROW-32))|(1<<(powerbuilderParserCREATE-32))|(1<<(powerbuilderParserDESTROY-32))|(1<<(powerbuilderParserPOST-32))|(1<<(powerbuilderParserTRIGGER-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(powerbuilderParserDESCRIBE-64))|(1<<(powerbuilderParserRETURN-64))|(1<<(powerbuilderParserCALL-64))|(1<<(powerbuilderParserHALT-64))|(1<<(powerbuilderParserSUPER-64)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(powerbuilderParserDQUOTED_STRING-101))|(1<<(powerbuilderParserQUOTED_STRING-101))|(1<<(powerbuilderParserENUM-101))|(1<<(powerbuilderParserID-101))|(1<<(powerbuilderParserSEMI-101))|(1<<(powerbuilderParserNUMBER-101))|(1<<(powerbuilderParserDATE-101))|(1<<(powerbuilderParserTIME-101)))) != 0) {
		{
			p.SetState(949)
			p.Statement()
		}

		p.SetState(954)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(955)
		p.Match(powerbuilderParserLOOP)
	}
	{
		p.SetState(956)
		_la = p.GetTokenStream().LA(1)

		if !(_la == powerbuilderParserWHILE || _la == powerbuilderParserUNTIL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(957)
		p.Boolean_expression()
	}

	return localctx
}

// IIf_statementContext is an interface to support dynamic dispatch.
type IIf_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_statementContext differentiates from other interfaces.
	IsIf_statementContext()
}

type If_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_statementContext() *If_statementContext {
	var p = new(If_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_if_statement
	return p
}

func (*If_statementContext) IsIf_statementContext() {}

func NewIf_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_statementContext {
	var p = new(If_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_if_statement

	return p
}

func (s *If_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *If_statementContext) AllIF() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserIF)
}

func (s *If_statementContext) IF(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserIF, i)
}

func (s *If_statementContext) AllBoolean_expression() []IBoolean_expressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IBoolean_expressionContext)(nil)).Elem())
	var tst = make([]IBoolean_expressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IBoolean_expressionContext)
		}
	}

	return tst
}

func (s *If_statementContext) Boolean_expression(i int) IBoolean_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBoolean_expressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IBoolean_expressionContext)
}

func (s *If_statementContext) AllTHEN() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserTHEN)
}

func (s *If_statementContext) THEN(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTHEN, i)
}

func (s *If_statementContext) END() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEND, 0)
}

func (s *If_statementContext) SEMI() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserSEMI, 0)
}

func (s *If_statementContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *If_statementContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *If_statementContext) AllELSEIF() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserELSEIF)
}

func (s *If_statementContext) ELSEIF(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserELSEIF, i)
}

func (s *If_statementContext) ELSE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserELSE, 0)
}

func (s *If_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterIf_statement(s)
	}
}

func (s *If_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitIf_statement(s)
	}
}

func (p *powerbuilderParser) If_statement() (localctx IIf_statementContext) {
	localctx = NewIf_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, powerbuilderParserRULE_if_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(959)
		p.Match(powerbuilderParserIF)
	}
	{
		p.SetState(960)
		p.Boolean_expression()
	}
	{
		p.SetState(961)
		p.Match(powerbuilderParserTHEN)
	}
	p.SetState(965)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserDATA_TYPE_SUB)|(1<<powerbuilderParserBOOLEAN_ATOM)|(1<<powerbuilderParserGLOBAL)|(1<<powerbuilderParserINDIRECT)|(1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserPRIVATEWRITE)|(1<<powerbuilderParserPROTECTED)|(1<<powerbuilderParserPRIVATEREAD)|(1<<powerbuilderParserPROTECTEDREAD)|(1<<powerbuilderParserPROTECTEDWRITE)|(1<<powerbuilderParserLOCAL)|(1<<powerbuilderParserEVENT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(powerbuilderParserOPEN-32))|(1<<(powerbuilderParserGOTO-32))|(1<<(powerbuilderParserIF-32))|(1<<(powerbuilderParserTRY-32))|(1<<(powerbuilderParserEXIT-32))|(1<<(powerbuilderParserCHOOSE-32))|(1<<(powerbuilderParserCONTINUE-32))|(1<<(powerbuilderParserDO-32))|(1<<(powerbuilderParserFOR-32))|(1<<(powerbuilderParserCLOSE-32))|(1<<(powerbuilderParserTHROW-32))|(1<<(powerbuilderParserCREATE-32))|(1<<(powerbuilderParserDESTROY-32))|(1<<(powerbuilderParserPOST-32))|(1<<(powerbuilderParserTRIGGER-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(powerbuilderParserDESCRIBE-64))|(1<<(powerbuilderParserRETURN-64))|(1<<(powerbuilderParserCALL-64))|(1<<(powerbuilderParserHALT-64))|(1<<(powerbuilderParserSUPER-64)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(powerbuilderParserDQUOTED_STRING-101))|(1<<(powerbuilderParserQUOTED_STRING-101))|(1<<(powerbuilderParserENUM-101))|(1<<(powerbuilderParserID-101))|(1<<(powerbuilderParserSEMI-101))|(1<<(powerbuilderParserNUMBER-101))|(1<<(powerbuilderParserDATE-101))|(1<<(powerbuilderParserTIME-101)))) != 0) {
		{
			p.SetState(962)
			p.Statement()
		}

		p.SetState(967)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(979)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == powerbuilderParserELSEIF {
		{
			p.SetState(968)
			p.Match(powerbuilderParserELSEIF)
		}
		{
			p.SetState(969)
			p.Boolean_expression()
		}
		{
			p.SetState(970)
			p.Match(powerbuilderParserTHEN)
		}
		p.SetState(974)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserDATA_TYPE_SUB)|(1<<powerbuilderParserBOOLEAN_ATOM)|(1<<powerbuilderParserGLOBAL)|(1<<powerbuilderParserINDIRECT)|(1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserPRIVATEWRITE)|(1<<powerbuilderParserPROTECTED)|(1<<powerbuilderParserPRIVATEREAD)|(1<<powerbuilderParserPROTECTEDREAD)|(1<<powerbuilderParserPROTECTEDWRITE)|(1<<powerbuilderParserLOCAL)|(1<<powerbuilderParserEVENT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(powerbuilderParserOPEN-32))|(1<<(powerbuilderParserGOTO-32))|(1<<(powerbuilderParserIF-32))|(1<<(powerbuilderParserTRY-32))|(1<<(powerbuilderParserEXIT-32))|(1<<(powerbuilderParserCHOOSE-32))|(1<<(powerbuilderParserCONTINUE-32))|(1<<(powerbuilderParserDO-32))|(1<<(powerbuilderParserFOR-32))|(1<<(powerbuilderParserCLOSE-32))|(1<<(powerbuilderParserTHROW-32))|(1<<(powerbuilderParserCREATE-32))|(1<<(powerbuilderParserDESTROY-32))|(1<<(powerbuilderParserPOST-32))|(1<<(powerbuilderParserTRIGGER-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(powerbuilderParserDESCRIBE-64))|(1<<(powerbuilderParserRETURN-64))|(1<<(powerbuilderParserCALL-64))|(1<<(powerbuilderParserHALT-64))|(1<<(powerbuilderParserSUPER-64)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(powerbuilderParserDQUOTED_STRING-101))|(1<<(powerbuilderParserQUOTED_STRING-101))|(1<<(powerbuilderParserENUM-101))|(1<<(powerbuilderParserID-101))|(1<<(powerbuilderParserSEMI-101))|(1<<(powerbuilderParserNUMBER-101))|(1<<(powerbuilderParserDATE-101))|(1<<(powerbuilderParserTIME-101)))) != 0) {
			{
				p.SetState(971)
				p.Statement()
			}

			p.SetState(976)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

		p.SetState(981)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(989)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserELSE {
		{
			p.SetState(982)
			p.Match(powerbuilderParserELSE)
		}
		p.SetState(986)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserDATA_TYPE_SUB)|(1<<powerbuilderParserBOOLEAN_ATOM)|(1<<powerbuilderParserGLOBAL)|(1<<powerbuilderParserINDIRECT)|(1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserPRIVATEWRITE)|(1<<powerbuilderParserPROTECTED)|(1<<powerbuilderParserPRIVATEREAD)|(1<<powerbuilderParserPROTECTEDREAD)|(1<<powerbuilderParserPROTECTEDWRITE)|(1<<powerbuilderParserLOCAL)|(1<<powerbuilderParserEVENT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(powerbuilderParserOPEN-32))|(1<<(powerbuilderParserGOTO-32))|(1<<(powerbuilderParserIF-32))|(1<<(powerbuilderParserTRY-32))|(1<<(powerbuilderParserEXIT-32))|(1<<(powerbuilderParserCHOOSE-32))|(1<<(powerbuilderParserCONTINUE-32))|(1<<(powerbuilderParserDO-32))|(1<<(powerbuilderParserFOR-32))|(1<<(powerbuilderParserCLOSE-32))|(1<<(powerbuilderParserTHROW-32))|(1<<(powerbuilderParserCREATE-32))|(1<<(powerbuilderParserDESTROY-32))|(1<<(powerbuilderParserPOST-32))|(1<<(powerbuilderParserTRIGGER-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(powerbuilderParserDESCRIBE-64))|(1<<(powerbuilderParserRETURN-64))|(1<<(powerbuilderParserCALL-64))|(1<<(powerbuilderParserHALT-64))|(1<<(powerbuilderParserSUPER-64)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(powerbuilderParserDQUOTED_STRING-101))|(1<<(powerbuilderParserQUOTED_STRING-101))|(1<<(powerbuilderParserENUM-101))|(1<<(powerbuilderParserID-101))|(1<<(powerbuilderParserSEMI-101))|(1<<(powerbuilderParserNUMBER-101))|(1<<(powerbuilderParserDATE-101))|(1<<(powerbuilderParserTIME-101)))) != 0) {
			{
				p.SetState(983)
				p.Statement()
			}

			p.SetState(988)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(991)
		p.Match(powerbuilderParserEND)
	}
	{
		p.SetState(992)
		p.Match(powerbuilderParserIF)
	}
	p.SetState(995)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 128, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(993)
			p.Match(powerbuilderParserSEMI)
		}

	case 2:

	}

	return localctx
}

// IIf_simple_statementContext is an interface to support dynamic dispatch.
type IIf_simple_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIf_simple_statementContext differentiates from other interfaces.
	IsIf_simple_statementContext()
}

type If_simple_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIf_simple_statementContext() *If_simple_statementContext {
	var p = new(If_simple_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_if_simple_statement
	return p
}

func (*If_simple_statementContext) IsIf_simple_statementContext() {}

func NewIf_simple_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *If_simple_statementContext {
	var p = new(If_simple_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_if_simple_statement

	return p
}

func (s *If_simple_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *If_simple_statementContext) IF() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserIF, 0)
}

func (s *If_simple_statementContext) Boolean_expression() IBoolean_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBoolean_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBoolean_expressionContext)
}

func (s *If_simple_statementContext) THEN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTHEN, 0)
}

func (s *If_simple_statementContext) Statement() IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *If_simple_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *If_simple_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *If_simple_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterIf_simple_statement(s)
	}
}

func (s *If_simple_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitIf_simple_statement(s)
	}
}

func (p *powerbuilderParser) If_simple_statement() (localctx IIf_simple_statementContext) {
	localctx = NewIf_simple_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, powerbuilderParserRULE_if_simple_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(997)
		p.Match(powerbuilderParserIF)
	}
	{
		p.SetState(998)
		p.Boolean_expression()
	}
	{
		p.SetState(999)
		p.Match(powerbuilderParserTHEN)
	}
	{
		p.SetState(1000)
		p.Statement()
	}

	return localctx
}

// IContinue_subContext is an interface to support dynamic dispatch.
type IContinue_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinue_subContext differentiates from other interfaces.
	IsContinue_subContext()
}

type Continue_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinue_subContext() *Continue_subContext {
	var p = new(Continue_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_continue_sub
	return p
}

func (*Continue_subContext) IsContinue_subContext() {}

func NewContinue_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Continue_subContext {
	var p = new(Continue_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_continue_sub

	return p
}

func (s *Continue_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Continue_subContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCONTINUE, 0)
}

func (s *Continue_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Continue_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Continue_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterContinue_sub(s)
	}
}

func (s *Continue_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitContinue_sub(s)
	}
}

func (p *powerbuilderParser) Continue_sub() (localctx IContinue_subContext) {
	localctx = NewContinue_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, powerbuilderParserRULE_continue_sub)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1002)
		p.Match(powerbuilderParserCONTINUE)
	}

	return localctx
}

// IContinue_statementContext is an interface to support dynamic dispatch.
type IContinue_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinue_statementContext differentiates from other interfaces.
	IsContinue_statementContext()
}

type Continue_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinue_statementContext() *Continue_statementContext {
	var p = new(Continue_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_continue_statement
	return p
}

func (*Continue_statementContext) IsContinue_statementContext() {}

func NewContinue_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Continue_statementContext {
	var p = new(Continue_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_continue_statement

	return p
}

func (s *Continue_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Continue_statementContext) Continue_sub() IContinue_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IContinue_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IContinue_subContext)
}

func (s *Continue_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Continue_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Continue_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterContinue_statement(s)
	}
}

func (s *Continue_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitContinue_statement(s)
	}
}

func (p *powerbuilderParser) Continue_statement() (localctx IContinue_statementContext) {
	localctx = NewContinue_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, powerbuilderParserRULE_continue_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1004)
		p.Continue_sub()
	}

	return localctx
}

// IPost_event_subContext is an interface to support dynamic dispatch.
type IPost_event_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPost_event_subContext differentiates from other interfaces.
	IsPost_event_subContext()
}

type Post_event_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPost_event_subContext() *Post_event_subContext {
	var p = new(Post_event_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_post_event_sub
	return p
}

func (*Post_event_subContext) IsPost_event_subContext() {}

func NewPost_event_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Post_event_subContext {
	var p = new(Post_event_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_post_event_sub

	return p
}

func (s *Post_event_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Post_event_subContext) Identifier_name_ex() IIdentifier_name_exContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_name_exContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_name_exContext)
}

func (s *Post_event_subContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLPAREN, 0)
}

func (s *Post_event_subContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRPAREN, 0)
}

func (s *Post_event_subContext) POST() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserPOST, 0)
}

func (s *Post_event_subContext) TRIGGER() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTRIGGER, 0)
}

func (s *Post_event_subContext) Atom_sub_member1() IAtom_sub_member1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_sub_member1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_sub_member1Context)
}

func (s *Post_event_subContext) DOT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDOT, 0)
}

func (s *Post_event_subContext) EVENT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEVENT, 0)
}

func (s *Post_event_subContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *Post_event_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Post_event_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Post_event_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterPost_event_sub(s)
	}
}

func (s *Post_event_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitPost_event_sub(s)
	}
}

func (p *powerbuilderParser) Post_event_sub() (localctx IPost_event_subContext) {
	localctx = NewPost_event_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, powerbuilderParserRULE_post_event_sub)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1009)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserSUPER || _la == powerbuilderParserID {
		{
			p.SetState(1006)
			p.Atom_sub_member1()
		}
		{
			p.SetState(1007)
			p.Match(powerbuilderParserDOT)
		}

	}
	{
		p.SetState(1011)
		_la = p.GetTokenStream().LA(1)

		if !(_la == powerbuilderParserPOST || _la == powerbuilderParserTRIGGER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1013)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserEVENT {
		{
			p.SetState(1012)
			p.Match(powerbuilderParserEVENT)
		}

	}
	{
		p.SetState(1015)
		p.Identifier_name_ex()
	}
	{
		p.SetState(1016)
		p.Match(powerbuilderParserLPAREN)
	}
	p.SetState(1018)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserREF || _la == powerbuilderParserCLOSE || _la == powerbuilderParserHALT || _la == powerbuilderParserLCURLY {
		{
			p.SetState(1017)
			p.Expression_list()
		}

	}
	{
		p.SetState(1020)
		p.Match(powerbuilderParserRPAREN)
	}

	return localctx
}

// IPost_eventContext is an interface to support dynamic dispatch.
type IPost_eventContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPost_eventContext differentiates from other interfaces.
	IsPost_eventContext()
}

type Post_eventContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPost_eventContext() *Post_eventContext {
	var p = new(Post_eventContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_post_event
	return p
}

func (*Post_eventContext) IsPost_eventContext() {}

func NewPost_eventContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Post_eventContext {
	var p = new(Post_eventContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_post_event

	return p
}

func (s *Post_eventContext) GetParser() antlr.Parser { return s.parser }

func (s *Post_eventContext) Post_event_sub() IPost_event_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPost_event_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPost_event_subContext)
}

func (s *Post_eventContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Post_eventContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Post_eventContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterPost_event(s)
	}
}

func (s *Post_eventContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitPost_event(s)
	}
}

func (p *powerbuilderParser) Post_event() (localctx IPost_eventContext) {
	localctx = NewPost_eventContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, powerbuilderParserRULE_post_event)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1022)
		p.Post_event_sub()
	}

	return localctx
}

// IExit_statement_subContext is an interface to support dynamic dispatch.
type IExit_statement_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExit_statement_subContext differentiates from other interfaces.
	IsExit_statement_subContext()
}

type Exit_statement_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExit_statement_subContext() *Exit_statement_subContext {
	var p = new(Exit_statement_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_exit_statement_sub
	return p
}

func (*Exit_statement_subContext) IsExit_statement_subContext() {}

func NewExit_statement_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exit_statement_subContext {
	var p = new(Exit_statement_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_exit_statement_sub

	return p
}

func (s *Exit_statement_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Exit_statement_subContext) EXIT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEXIT, 0)
}

func (s *Exit_statement_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exit_statement_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exit_statement_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterExit_statement_sub(s)
	}
}

func (s *Exit_statement_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitExit_statement_sub(s)
	}
}

func (p *powerbuilderParser) Exit_statement_sub() (localctx IExit_statement_subContext) {
	localctx = NewExit_statement_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, powerbuilderParserRULE_exit_statement_sub)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1024)
		p.Match(powerbuilderParserEXIT)
	}

	return localctx
}

// IExit_statementContext is an interface to support dynamic dispatch.
type IExit_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExit_statementContext differentiates from other interfaces.
	IsExit_statementContext()
}

type Exit_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExit_statementContext() *Exit_statementContext {
	var p = new(Exit_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_exit_statement
	return p
}

func (*Exit_statementContext) IsExit_statementContext() {}

func NewExit_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Exit_statementContext {
	var p = new(Exit_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_exit_statement

	return p
}

func (s *Exit_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Exit_statementContext) Exit_statement_sub() IExit_statement_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExit_statement_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExit_statement_subContext)
}

func (s *Exit_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Exit_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Exit_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterExit_statement(s)
	}
}

func (s *Exit_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitExit_statement(s)
	}
}

func (p *powerbuilderParser) Exit_statement() (localctx IExit_statementContext) {
	localctx = NewExit_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, powerbuilderParserRULE_exit_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1026)
		p.Exit_statement_sub()
	}

	return localctx
}

// IChoose_statementContext is an interface to support dynamic dispatch.
type IChoose_statementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChoose_statementContext differentiates from other interfaces.
	IsChoose_statementContext()
}

type Choose_statementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChoose_statementContext() *Choose_statementContext {
	var p = new(Choose_statementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_choose_statement
	return p
}

func (*Choose_statementContext) IsChoose_statementContext() {}

func NewChoose_statementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Choose_statementContext {
	var p = new(Choose_statementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_choose_statement

	return p
}

func (s *Choose_statementContext) GetParser() antlr.Parser { return s.parser }

func (s *Choose_statementContext) AllCHOOSE() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserCHOOSE)
}

func (s *Choose_statementContext) CHOOSE(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCHOOSE, i)
}

func (s *Choose_statementContext) CASE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCASE, 0)
}

func (s *Choose_statementContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Choose_statementContext) END() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEND, 0)
}

func (s *Choose_statementContext) AllChoose_case_value_sub() []IChoose_case_value_subContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IChoose_case_value_subContext)(nil)).Elem())
	var tst = make([]IChoose_case_value_subContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IChoose_case_value_subContext)
		}
	}

	return tst
}

func (s *Choose_statementContext) Choose_case_value_sub(i int) IChoose_case_value_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChoose_case_value_subContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IChoose_case_value_subContext)
}

func (s *Choose_statementContext) AllChoose_case_range_sub() []IChoose_case_range_subContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IChoose_case_range_subContext)(nil)).Elem())
	var tst = make([]IChoose_case_range_subContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IChoose_case_range_subContext)
		}
	}

	return tst
}

func (s *Choose_statementContext) Choose_case_range_sub(i int) IChoose_case_range_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChoose_case_range_subContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IChoose_case_range_subContext)
}

func (s *Choose_statementContext) AllChoose_case_cond_sub() []IChoose_case_cond_subContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IChoose_case_cond_subContext)(nil)).Elem())
	var tst = make([]IChoose_case_cond_subContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IChoose_case_cond_subContext)
		}
	}

	return tst
}

func (s *Choose_statementContext) Choose_case_cond_sub(i int) IChoose_case_cond_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChoose_case_cond_subContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IChoose_case_cond_subContext)
}

func (s *Choose_statementContext) AllChoose_case_else_sub() []IChoose_case_else_subContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IChoose_case_else_subContext)(nil)).Elem())
	var tst = make([]IChoose_case_else_subContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IChoose_case_else_subContext)
		}
	}

	return tst
}

func (s *Choose_statementContext) Choose_case_else_sub(i int) IChoose_case_else_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IChoose_case_else_subContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IChoose_case_else_subContext)
}

func (s *Choose_statementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Choose_statementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Choose_statementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterChoose_statement(s)
	}
}

func (s *Choose_statementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitChoose_statement(s)
	}
}

func (p *powerbuilderParser) Choose_statement() (localctx IChoose_statementContext) {
	localctx = NewChoose_statementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, powerbuilderParserRULE_choose_statement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1028)
		p.Match(powerbuilderParserCHOOSE)
	}
	{
		p.SetState(1029)
		p.Match(powerbuilderParserCASE)
	}
	{
		p.SetState(1030)
		p.Expression()
	}
	p.SetState(1035)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == powerbuilderParserCASE {
		p.SetState(1035)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1031)
				p.Choose_case_range_sub()
			}

		case 2:
			{
				p.SetState(1032)
				p.Choose_case_cond_sub()
			}

		case 3:
			{
				p.SetState(1033)
				p.Choose_case_else_sub()
			}

		case 4:
			{
				p.SetState(1034)
				p.Choose_case_value_sub()
			}

		}

		p.SetState(1037)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1039)
		p.Match(powerbuilderParserEND)
	}
	{
		p.SetState(1040)
		p.Match(powerbuilderParserCHOOSE)
	}

	return localctx
}

// IChoose_case_value_subContext is an interface to support dynamic dispatch.
type IChoose_case_value_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChoose_case_value_subContext differentiates from other interfaces.
	IsChoose_case_value_subContext()
}

type Choose_case_value_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChoose_case_value_subContext() *Choose_case_value_subContext {
	var p = new(Choose_case_value_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_choose_case_value_sub
	return p
}

func (*Choose_case_value_subContext) IsChoose_case_value_subContext() {}

func NewChoose_case_value_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Choose_case_value_subContext {
	var p = new(Choose_case_value_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_choose_case_value_sub

	return p
}

func (s *Choose_case_value_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Choose_case_value_subContext) CASE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCASE, 0)
}

func (s *Choose_case_value_subContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Choose_case_value_subContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Choose_case_value_subContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserCOMMA)
}

func (s *Choose_case_value_subContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCOMMA, i)
}

func (s *Choose_case_value_subContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Choose_case_value_subContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Choose_case_value_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Choose_case_value_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Choose_case_value_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterChoose_case_value_sub(s)
	}
}

func (s *Choose_case_value_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitChoose_case_value_sub(s)
	}
}

func (p *powerbuilderParser) Choose_case_value_sub() (localctx IChoose_case_value_subContext) {
	localctx = NewChoose_case_value_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, powerbuilderParserRULE_choose_case_value_sub)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1042)
		p.Match(powerbuilderParserCASE)
	}
	{
		p.SetState(1043)
		p.Expression()
	}
	p.SetState(1048)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == powerbuilderParserCOMMA {
		{
			p.SetState(1044)
			p.Match(powerbuilderParserCOMMA)
		}
		{
			p.SetState(1045)
			p.Expression()
		}

		p.SetState(1050)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1054)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserDATA_TYPE_SUB)|(1<<powerbuilderParserBOOLEAN_ATOM)|(1<<powerbuilderParserGLOBAL)|(1<<powerbuilderParserINDIRECT)|(1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserPRIVATEWRITE)|(1<<powerbuilderParserPROTECTED)|(1<<powerbuilderParserPRIVATEREAD)|(1<<powerbuilderParserPROTECTEDREAD)|(1<<powerbuilderParserPROTECTEDWRITE)|(1<<powerbuilderParserLOCAL)|(1<<powerbuilderParserEVENT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(powerbuilderParserOPEN-32))|(1<<(powerbuilderParserGOTO-32))|(1<<(powerbuilderParserIF-32))|(1<<(powerbuilderParserTRY-32))|(1<<(powerbuilderParserEXIT-32))|(1<<(powerbuilderParserCHOOSE-32))|(1<<(powerbuilderParserCONTINUE-32))|(1<<(powerbuilderParserDO-32))|(1<<(powerbuilderParserFOR-32))|(1<<(powerbuilderParserCLOSE-32))|(1<<(powerbuilderParserTHROW-32))|(1<<(powerbuilderParserCREATE-32))|(1<<(powerbuilderParserDESTROY-32))|(1<<(powerbuilderParserPOST-32))|(1<<(powerbuilderParserTRIGGER-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(powerbuilderParserDESCRIBE-64))|(1<<(powerbuilderParserRETURN-64))|(1<<(powerbuilderParserCALL-64))|(1<<(powerbuilderParserHALT-64))|(1<<(powerbuilderParserSUPER-64)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(powerbuilderParserDQUOTED_STRING-101))|(1<<(powerbuilderParserQUOTED_STRING-101))|(1<<(powerbuilderParserENUM-101))|(1<<(powerbuilderParserID-101))|(1<<(powerbuilderParserSEMI-101))|(1<<(powerbuilderParserNUMBER-101))|(1<<(powerbuilderParserDATE-101))|(1<<(powerbuilderParserTIME-101)))) != 0) {
		{
			p.SetState(1051)
			p.Statement()
		}

		p.SetState(1056)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IChoose_case_cond_subContext is an interface to support dynamic dispatch.
type IChoose_case_cond_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChoose_case_cond_subContext differentiates from other interfaces.
	IsChoose_case_cond_subContext()
}

type Choose_case_cond_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChoose_case_cond_subContext() *Choose_case_cond_subContext {
	var p = new(Choose_case_cond_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_choose_case_cond_sub
	return p
}

func (*Choose_case_cond_subContext) IsChoose_case_cond_subContext() {}

func NewChoose_case_cond_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Choose_case_cond_subContext {
	var p = new(Choose_case_cond_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_choose_case_cond_sub

	return p
}

func (s *Choose_case_cond_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Choose_case_cond_subContext) CASE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCASE, 0)
}

func (s *Choose_case_cond_subContext) IS() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserIS, 0)
}

func (s *Choose_case_cond_subContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Choose_case_cond_subContext) EQ() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEQ, 0)
}

func (s *Choose_case_cond_subContext) GT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserGT, 0)
}

func (s *Choose_case_cond_subContext) LT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLT, 0)
}

func (s *Choose_case_cond_subContext) GTLT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserGTLT, 0)
}

func (s *Choose_case_cond_subContext) GTE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserGTE, 0)
}

func (s *Choose_case_cond_subContext) LTE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLTE, 0)
}

func (s *Choose_case_cond_subContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Choose_case_cond_subContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Choose_case_cond_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Choose_case_cond_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Choose_case_cond_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterChoose_case_cond_sub(s)
	}
}

func (s *Choose_case_cond_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitChoose_case_cond_sub(s)
	}
}

func (p *powerbuilderParser) Choose_case_cond_sub() (localctx IChoose_case_cond_subContext) {
	localctx = NewChoose_case_cond_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, powerbuilderParserRULE_choose_case_cond_sub)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1057)
		p.Match(powerbuilderParserCASE)
	}
	{
		p.SetState(1058)
		p.Match(powerbuilderParserIS)
	}
	{
		p.SetState(1059)
		_la = p.GetTokenStream().LA(1)

		if !(((_la-77)&-(0x1f+1)) == 0 && ((1<<uint((_la-77)))&((1<<(powerbuilderParserEQ-77))|(1<<(powerbuilderParserGT-77))|(1<<(powerbuilderParserGTE-77))|(1<<(powerbuilderParserLT-77))|(1<<(powerbuilderParserLTE-77))|(1<<(powerbuilderParserGTLT-77)))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1060)
		p.Expression()
	}
	p.SetState(1064)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserDATA_TYPE_SUB)|(1<<powerbuilderParserBOOLEAN_ATOM)|(1<<powerbuilderParserGLOBAL)|(1<<powerbuilderParserINDIRECT)|(1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserPRIVATEWRITE)|(1<<powerbuilderParserPROTECTED)|(1<<powerbuilderParserPRIVATEREAD)|(1<<powerbuilderParserPROTECTEDREAD)|(1<<powerbuilderParserPROTECTEDWRITE)|(1<<powerbuilderParserLOCAL)|(1<<powerbuilderParserEVENT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(powerbuilderParserOPEN-32))|(1<<(powerbuilderParserGOTO-32))|(1<<(powerbuilderParserIF-32))|(1<<(powerbuilderParserTRY-32))|(1<<(powerbuilderParserEXIT-32))|(1<<(powerbuilderParserCHOOSE-32))|(1<<(powerbuilderParserCONTINUE-32))|(1<<(powerbuilderParserDO-32))|(1<<(powerbuilderParserFOR-32))|(1<<(powerbuilderParserCLOSE-32))|(1<<(powerbuilderParserTHROW-32))|(1<<(powerbuilderParserCREATE-32))|(1<<(powerbuilderParserDESTROY-32))|(1<<(powerbuilderParserPOST-32))|(1<<(powerbuilderParserTRIGGER-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(powerbuilderParserDESCRIBE-64))|(1<<(powerbuilderParserRETURN-64))|(1<<(powerbuilderParserCALL-64))|(1<<(powerbuilderParserHALT-64))|(1<<(powerbuilderParserSUPER-64)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(powerbuilderParserDQUOTED_STRING-101))|(1<<(powerbuilderParserQUOTED_STRING-101))|(1<<(powerbuilderParserENUM-101))|(1<<(powerbuilderParserID-101))|(1<<(powerbuilderParserSEMI-101))|(1<<(powerbuilderParserNUMBER-101))|(1<<(powerbuilderParserDATE-101))|(1<<(powerbuilderParserTIME-101)))) != 0) {
		{
			p.SetState(1061)
			p.Statement()
		}

		p.SetState(1066)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IChoose_case_range_subContext is an interface to support dynamic dispatch.
type IChoose_case_range_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChoose_case_range_subContext differentiates from other interfaces.
	IsChoose_case_range_subContext()
}

type Choose_case_range_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChoose_case_range_subContext() *Choose_case_range_subContext {
	var p = new(Choose_case_range_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_choose_case_range_sub
	return p
}

func (*Choose_case_range_subContext) IsChoose_case_range_subContext() {}

func NewChoose_case_range_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Choose_case_range_subContext {
	var p = new(Choose_case_range_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_choose_case_range_sub

	return p
}

func (s *Choose_case_range_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Choose_case_range_subContext) CASE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCASE, 0)
}

func (s *Choose_case_range_subContext) AllAtom() []IAtomContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAtomContext)(nil)).Elem())
	var tst = make([]IAtomContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAtomContext)
		}
	}

	return tst
}

func (s *Choose_case_range_subContext) Atom(i int) IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *Choose_case_range_subContext) TO() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTO, 0)
}

func (s *Choose_case_range_subContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Choose_case_range_subContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Choose_case_range_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Choose_case_range_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Choose_case_range_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterChoose_case_range_sub(s)
	}
}

func (s *Choose_case_range_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitChoose_case_range_sub(s)
	}
}

func (p *powerbuilderParser) Choose_case_range_sub() (localctx IChoose_case_range_subContext) {
	localctx = NewChoose_case_range_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, powerbuilderParserRULE_choose_case_range_sub)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1067)
		p.Match(powerbuilderParserCASE)
	}
	{
		p.SetState(1068)
		p.Atom()
	}
	{
		p.SetState(1069)
		p.Match(powerbuilderParserTO)
	}
	{
		p.SetState(1070)
		p.Atom()
	}
	p.SetState(1074)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserDATA_TYPE_SUB)|(1<<powerbuilderParserBOOLEAN_ATOM)|(1<<powerbuilderParserGLOBAL)|(1<<powerbuilderParserINDIRECT)|(1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserPRIVATEWRITE)|(1<<powerbuilderParserPROTECTED)|(1<<powerbuilderParserPRIVATEREAD)|(1<<powerbuilderParserPROTECTEDREAD)|(1<<powerbuilderParserPROTECTEDWRITE)|(1<<powerbuilderParserLOCAL)|(1<<powerbuilderParserEVENT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(powerbuilderParserOPEN-32))|(1<<(powerbuilderParserGOTO-32))|(1<<(powerbuilderParserIF-32))|(1<<(powerbuilderParserTRY-32))|(1<<(powerbuilderParserEXIT-32))|(1<<(powerbuilderParserCHOOSE-32))|(1<<(powerbuilderParserCONTINUE-32))|(1<<(powerbuilderParserDO-32))|(1<<(powerbuilderParserFOR-32))|(1<<(powerbuilderParserCLOSE-32))|(1<<(powerbuilderParserTHROW-32))|(1<<(powerbuilderParserCREATE-32))|(1<<(powerbuilderParserDESTROY-32))|(1<<(powerbuilderParserPOST-32))|(1<<(powerbuilderParserTRIGGER-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(powerbuilderParserDESCRIBE-64))|(1<<(powerbuilderParserRETURN-64))|(1<<(powerbuilderParserCALL-64))|(1<<(powerbuilderParserHALT-64))|(1<<(powerbuilderParserSUPER-64)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(powerbuilderParserDQUOTED_STRING-101))|(1<<(powerbuilderParserQUOTED_STRING-101))|(1<<(powerbuilderParserENUM-101))|(1<<(powerbuilderParserID-101))|(1<<(powerbuilderParserSEMI-101))|(1<<(powerbuilderParserNUMBER-101))|(1<<(powerbuilderParserDATE-101))|(1<<(powerbuilderParserTIME-101)))) != 0) {
		{
			p.SetState(1071)
			p.Statement()
		}

		p.SetState(1076)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IChoose_case_else_subContext is an interface to support dynamic dispatch.
type IChoose_case_else_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChoose_case_else_subContext differentiates from other interfaces.
	IsChoose_case_else_subContext()
}

type Choose_case_else_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChoose_case_else_subContext() *Choose_case_else_subContext {
	var p = new(Choose_case_else_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_choose_case_else_sub
	return p
}

func (*Choose_case_else_subContext) IsChoose_case_else_subContext() {}

func NewChoose_case_else_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Choose_case_else_subContext {
	var p = new(Choose_case_else_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_choose_case_else_sub

	return p
}

func (s *Choose_case_else_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Choose_case_else_subContext) CASE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCASE, 0)
}

func (s *Choose_case_else_subContext) ELSE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserELSE, 0)
}

func (s *Choose_case_else_subContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Choose_case_else_subContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Choose_case_else_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Choose_case_else_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Choose_case_else_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterChoose_case_else_sub(s)
	}
}

func (s *Choose_case_else_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitChoose_case_else_sub(s)
	}
}

func (p *powerbuilderParser) Choose_case_else_sub() (localctx IChoose_case_else_subContext) {
	localctx = NewChoose_case_else_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, powerbuilderParserRULE_choose_case_else_sub)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1077)
		p.Match(powerbuilderParserCASE)
	}
	{
		p.SetState(1078)
		p.Match(powerbuilderParserELSE)
	}
	p.SetState(1082)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserDATA_TYPE_SUB)|(1<<powerbuilderParserBOOLEAN_ATOM)|(1<<powerbuilderParserGLOBAL)|(1<<powerbuilderParserINDIRECT)|(1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserPRIVATEWRITE)|(1<<powerbuilderParserPROTECTED)|(1<<powerbuilderParserPRIVATEREAD)|(1<<powerbuilderParserPROTECTEDREAD)|(1<<powerbuilderParserPROTECTEDWRITE)|(1<<powerbuilderParserLOCAL)|(1<<powerbuilderParserEVENT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(powerbuilderParserOPEN-32))|(1<<(powerbuilderParserGOTO-32))|(1<<(powerbuilderParserIF-32))|(1<<(powerbuilderParserTRY-32))|(1<<(powerbuilderParserEXIT-32))|(1<<(powerbuilderParserCHOOSE-32))|(1<<(powerbuilderParserCONTINUE-32))|(1<<(powerbuilderParserDO-32))|(1<<(powerbuilderParserFOR-32))|(1<<(powerbuilderParserCLOSE-32))|(1<<(powerbuilderParserTHROW-32))|(1<<(powerbuilderParserCREATE-32))|(1<<(powerbuilderParserDESTROY-32))|(1<<(powerbuilderParserPOST-32))|(1<<(powerbuilderParserTRIGGER-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(powerbuilderParserDESCRIBE-64))|(1<<(powerbuilderParserRETURN-64))|(1<<(powerbuilderParserCALL-64))|(1<<(powerbuilderParserHALT-64))|(1<<(powerbuilderParserSUPER-64)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(powerbuilderParserDQUOTED_STRING-101))|(1<<(powerbuilderParserQUOTED_STRING-101))|(1<<(powerbuilderParserENUM-101))|(1<<(powerbuilderParserID-101))|(1<<(powerbuilderParserSEMI-101))|(1<<(powerbuilderParserNUMBER-101))|(1<<(powerbuilderParserDATE-101))|(1<<(powerbuilderParserTIME-101)))) != 0) {
		{
			p.SetState(1079)
			p.Statement()
		}

		p.SetState(1084)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IGoto_stat_subContext is an interface to support dynamic dispatch.
type IGoto_stat_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGoto_stat_subContext differentiates from other interfaces.
	IsGoto_stat_subContext()
}

type Goto_stat_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGoto_stat_subContext() *Goto_stat_subContext {
	var p = new(Goto_stat_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_goto_stat_sub
	return p
}

func (*Goto_stat_subContext) IsGoto_stat_subContext() {}

func NewGoto_stat_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Goto_stat_subContext {
	var p = new(Goto_stat_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_goto_stat_sub

	return p
}

func (s *Goto_stat_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Goto_stat_subContext) GOTO() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserGOTO, 0)
}

func (s *Goto_stat_subContext) Identifier_name() IIdentifier_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_nameContext)
}

func (s *Goto_stat_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Goto_stat_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Goto_stat_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterGoto_stat_sub(s)
	}
}

func (s *Goto_stat_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitGoto_stat_sub(s)
	}
}

func (p *powerbuilderParser) Goto_stat_sub() (localctx IGoto_stat_subContext) {
	localctx = NewGoto_stat_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, powerbuilderParserRULE_goto_stat_sub)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1085)
		p.Match(powerbuilderParserGOTO)
	}
	{
		p.SetState(1086)
		p.Identifier_name()
	}

	return localctx
}

// IGoto_statContext is an interface to support dynamic dispatch.
type IGoto_statContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGoto_statContext differentiates from other interfaces.
	IsGoto_statContext()
}

type Goto_statContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGoto_statContext() *Goto_statContext {
	var p = new(Goto_statContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_goto_stat
	return p
}

func (*Goto_statContext) IsGoto_statContext() {}

func NewGoto_statContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Goto_statContext {
	var p = new(Goto_statContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_goto_stat

	return p
}

func (s *Goto_statContext) GetParser() antlr.Parser { return s.parser }

func (s *Goto_statContext) Goto_stat_sub() IGoto_stat_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGoto_stat_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGoto_stat_subContext)
}

func (s *Goto_statContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Goto_statContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Goto_statContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterGoto_stat(s)
	}
}

func (s *Goto_statContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitGoto_stat(s)
	}
}

func (p *powerbuilderParser) Goto_stat() (localctx IGoto_statContext) {
	localctx = NewGoto_statContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, powerbuilderParserRULE_goto_stat)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1088)
		p.Goto_stat_sub()
	}

	return localctx
}

// ILabel_statContext is an interface to support dynamic dispatch.
type ILabel_statContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabel_statContext differentiates from other interfaces.
	IsLabel_statContext()
}

type Label_statContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabel_statContext() *Label_statContext {
	var p = new(Label_statContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_label_stat
	return p
}

func (*Label_statContext) IsLabel_statContext() {}

func NewLabel_statContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Label_statContext {
	var p = new(Label_statContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_label_stat

	return p
}

func (s *Label_statContext) GetParser() antlr.Parser { return s.parser }

func (s *Label_statContext) Identifier_name() IIdentifier_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_nameContext)
}

func (s *Label_statContext) COLON() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCOLON, 0)
}

func (s *Label_statContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Label_statContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Label_statContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterLabel_stat(s)
	}
}

func (s *Label_statContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitLabel_stat(s)
	}
}

func (p *powerbuilderParser) Label_stat() (localctx ILabel_statContext) {
	localctx = NewLabel_statContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, powerbuilderParserRULE_label_stat)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1090)
		p.Identifier_name()
	}
	{
		p.SetState(1091)
		p.Match(powerbuilderParserCOLON)
	}

	return localctx
}

// ITry_catch_blockContext is an interface to support dynamic dispatch.
type ITry_catch_blockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTry_catch_blockContext differentiates from other interfaces.
	IsTry_catch_blockContext()
}

type Try_catch_blockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTry_catch_blockContext() *Try_catch_blockContext {
	var p = new(Try_catch_blockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_try_catch_block
	return p
}

func (*Try_catch_blockContext) IsTry_catch_blockContext() {}

func NewTry_catch_blockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Try_catch_blockContext {
	var p = new(Try_catch_blockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_try_catch_block

	return p
}

func (s *Try_catch_blockContext) GetParser() antlr.Parser { return s.parser }

func (s *Try_catch_blockContext) AllTRY() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserTRY)
}

func (s *Try_catch_blockContext) TRY(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTRY, i)
}

func (s *Try_catch_blockContext) END() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserEND, 0)
}

func (s *Try_catch_blockContext) AllStatement() []IStatementContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IStatementContext)(nil)).Elem())
	var tst = make([]IStatementContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IStatementContext)
		}
	}

	return tst
}

func (s *Try_catch_blockContext) Statement(i int) IStatementContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IStatementContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *Try_catch_blockContext) AllCATCH() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserCATCH)
}

func (s *Try_catch_blockContext) CATCH(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCATCH, i)
}

func (s *Try_catch_blockContext) AllLPAREN() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserLPAREN)
}

func (s *Try_catch_blockContext) LPAREN(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLPAREN, i)
}

func (s *Try_catch_blockContext) AllVariable_decl_sub() []IVariable_decl_subContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IVariable_decl_subContext)(nil)).Elem())
	var tst = make([]IVariable_decl_subContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IVariable_decl_subContext)
		}
	}

	return tst
}

func (s *Try_catch_blockContext) Variable_decl_sub(i int) IVariable_decl_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVariable_decl_subContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IVariable_decl_subContext)
}

func (s *Try_catch_blockContext) AllRPAREN() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserRPAREN)
}

func (s *Try_catch_blockContext) RPAREN(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRPAREN, i)
}

func (s *Try_catch_blockContext) FINALLY() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserFINALLY, 0)
}

func (s *Try_catch_blockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Try_catch_blockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Try_catch_blockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterTry_catch_block(s)
	}
}

func (s *Try_catch_blockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitTry_catch_block(s)
	}
}

func (p *powerbuilderParser) Try_catch_block() (localctx ITry_catch_blockContext) {
	localctx = NewTry_catch_blockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, powerbuilderParserRULE_try_catch_block)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1093)
		p.Match(powerbuilderParserTRY)
	}
	p.SetState(1097)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserDATA_TYPE_SUB)|(1<<powerbuilderParserBOOLEAN_ATOM)|(1<<powerbuilderParserGLOBAL)|(1<<powerbuilderParserINDIRECT)|(1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserPRIVATEWRITE)|(1<<powerbuilderParserPROTECTED)|(1<<powerbuilderParserPRIVATEREAD)|(1<<powerbuilderParserPROTECTEDREAD)|(1<<powerbuilderParserPROTECTEDWRITE)|(1<<powerbuilderParserLOCAL)|(1<<powerbuilderParserEVENT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(powerbuilderParserOPEN-32))|(1<<(powerbuilderParserGOTO-32))|(1<<(powerbuilderParserIF-32))|(1<<(powerbuilderParserTRY-32))|(1<<(powerbuilderParserEXIT-32))|(1<<(powerbuilderParserCHOOSE-32))|(1<<(powerbuilderParserCONTINUE-32))|(1<<(powerbuilderParserDO-32))|(1<<(powerbuilderParserFOR-32))|(1<<(powerbuilderParserCLOSE-32))|(1<<(powerbuilderParserTHROW-32))|(1<<(powerbuilderParserCREATE-32))|(1<<(powerbuilderParserDESTROY-32))|(1<<(powerbuilderParserPOST-32))|(1<<(powerbuilderParserTRIGGER-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(powerbuilderParserDESCRIBE-64))|(1<<(powerbuilderParserRETURN-64))|(1<<(powerbuilderParserCALL-64))|(1<<(powerbuilderParserHALT-64))|(1<<(powerbuilderParserSUPER-64)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(powerbuilderParserDQUOTED_STRING-101))|(1<<(powerbuilderParserQUOTED_STRING-101))|(1<<(powerbuilderParserENUM-101))|(1<<(powerbuilderParserID-101))|(1<<(powerbuilderParserSEMI-101))|(1<<(powerbuilderParserNUMBER-101))|(1<<(powerbuilderParserDATE-101))|(1<<(powerbuilderParserTIME-101)))) != 0) {
		{
			p.SetState(1094)
			p.Statement()
		}

		p.SetState(1099)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1112)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == powerbuilderParserCATCH {
		{
			p.SetState(1100)
			p.Match(powerbuilderParserCATCH)
		}
		{
			p.SetState(1101)
			p.Match(powerbuilderParserLPAREN)
		}
		{
			p.SetState(1102)
			p.Variable_decl_sub()
		}
		{
			p.SetState(1103)
			p.Match(powerbuilderParserRPAREN)
		}
		p.SetState(1107)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserDATA_TYPE_SUB)|(1<<powerbuilderParserBOOLEAN_ATOM)|(1<<powerbuilderParserGLOBAL)|(1<<powerbuilderParserINDIRECT)|(1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserPRIVATEWRITE)|(1<<powerbuilderParserPROTECTED)|(1<<powerbuilderParserPRIVATEREAD)|(1<<powerbuilderParserPROTECTEDREAD)|(1<<powerbuilderParserPROTECTEDWRITE)|(1<<powerbuilderParserLOCAL)|(1<<powerbuilderParserEVENT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(powerbuilderParserOPEN-32))|(1<<(powerbuilderParserGOTO-32))|(1<<(powerbuilderParserIF-32))|(1<<(powerbuilderParserTRY-32))|(1<<(powerbuilderParserEXIT-32))|(1<<(powerbuilderParserCHOOSE-32))|(1<<(powerbuilderParserCONTINUE-32))|(1<<(powerbuilderParserDO-32))|(1<<(powerbuilderParserFOR-32))|(1<<(powerbuilderParserCLOSE-32))|(1<<(powerbuilderParserTHROW-32))|(1<<(powerbuilderParserCREATE-32))|(1<<(powerbuilderParserDESTROY-32))|(1<<(powerbuilderParserPOST-32))|(1<<(powerbuilderParserTRIGGER-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(powerbuilderParserDESCRIBE-64))|(1<<(powerbuilderParserRETURN-64))|(1<<(powerbuilderParserCALL-64))|(1<<(powerbuilderParserHALT-64))|(1<<(powerbuilderParserSUPER-64)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(powerbuilderParserDQUOTED_STRING-101))|(1<<(powerbuilderParserQUOTED_STRING-101))|(1<<(powerbuilderParserENUM-101))|(1<<(powerbuilderParserID-101))|(1<<(powerbuilderParserSEMI-101))|(1<<(powerbuilderParserNUMBER-101))|(1<<(powerbuilderParserDATE-101))|(1<<(powerbuilderParserTIME-101)))) != 0) {
			{
				p.SetState(1104)
				p.Statement()
			}

			p.SetState(1109)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

		p.SetState(1114)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1122)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserFINALLY {
		{
			p.SetState(1115)
			p.Match(powerbuilderParserFINALLY)
		}
		p.SetState(1119)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<powerbuilderParserDATA_TYPE_SUB)|(1<<powerbuilderParserBOOLEAN_ATOM)|(1<<powerbuilderParserGLOBAL)|(1<<powerbuilderParserINDIRECT)|(1<<powerbuilderParserPUBLIC)|(1<<powerbuilderParserPRIVATE)|(1<<powerbuilderParserPRIVATEWRITE)|(1<<powerbuilderParserPROTECTED)|(1<<powerbuilderParserPRIVATEREAD)|(1<<powerbuilderParserPROTECTEDREAD)|(1<<powerbuilderParserPROTECTEDWRITE)|(1<<powerbuilderParserLOCAL)|(1<<powerbuilderParserEVENT))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(powerbuilderParserOPEN-32))|(1<<(powerbuilderParserGOTO-32))|(1<<(powerbuilderParserIF-32))|(1<<(powerbuilderParserTRY-32))|(1<<(powerbuilderParserEXIT-32))|(1<<(powerbuilderParserCHOOSE-32))|(1<<(powerbuilderParserCONTINUE-32))|(1<<(powerbuilderParserDO-32))|(1<<(powerbuilderParserFOR-32))|(1<<(powerbuilderParserCLOSE-32))|(1<<(powerbuilderParserTHROW-32))|(1<<(powerbuilderParserCREATE-32))|(1<<(powerbuilderParserDESTROY-32))|(1<<(powerbuilderParserPOST-32))|(1<<(powerbuilderParserTRIGGER-32)))) != 0) || (((_la-64)&-(0x1f+1)) == 0 && ((1<<uint((_la-64)))&((1<<(powerbuilderParserDESCRIBE-64))|(1<<(powerbuilderParserRETURN-64))|(1<<(powerbuilderParserCALL-64))|(1<<(powerbuilderParserHALT-64))|(1<<(powerbuilderParserSUPER-64)))) != 0) || (((_la-101)&-(0x1f+1)) == 0 && ((1<<uint((_la-101)))&((1<<(powerbuilderParserDQUOTED_STRING-101))|(1<<(powerbuilderParserQUOTED_STRING-101))|(1<<(powerbuilderParserENUM-101))|(1<<(powerbuilderParserID-101))|(1<<(powerbuilderParserSEMI-101))|(1<<(powerbuilderParserNUMBER-101))|(1<<(powerbuilderParserDATE-101))|(1<<(powerbuilderParserTIME-101)))) != 0) {
			{
				p.SetState(1116)
				p.Statement()
			}

			p.SetState(1121)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1124)
		p.Match(powerbuilderParserEND)
	}
	{
		p.SetState(1125)
		p.Match(powerbuilderParserTRY)
	}

	return localctx
}

// IThrow_stat_subContext is an interface to support dynamic dispatch.
type IThrow_stat_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThrow_stat_subContext differentiates from other interfaces.
	IsThrow_stat_subContext()
}

type Throw_stat_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrow_stat_subContext() *Throw_stat_subContext {
	var p = new(Throw_stat_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_throw_stat_sub
	return p
}

func (*Throw_stat_subContext) IsThrow_stat_subContext() {}

func NewThrow_stat_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Throw_stat_subContext {
	var p = new(Throw_stat_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_throw_stat_sub

	return p
}

func (s *Throw_stat_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Throw_stat_subContext) THROW() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTHROW, 0)
}

func (s *Throw_stat_subContext) Expression() IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Throw_stat_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Throw_stat_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Throw_stat_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterThrow_stat_sub(s)
	}
}

func (s *Throw_stat_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitThrow_stat_sub(s)
	}
}

func (p *powerbuilderParser) Throw_stat_sub() (localctx IThrow_stat_subContext) {
	localctx = NewThrow_stat_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, powerbuilderParserRULE_throw_stat_sub)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1127)
		p.Match(powerbuilderParserTHROW)
	}
	{
		p.SetState(1128)
		p.Expression()
	}

	return localctx
}

// IThrow_statContext is an interface to support dynamic dispatch.
type IThrow_statContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsThrow_statContext differentiates from other interfaces.
	IsThrow_statContext()
}

type Throw_statContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThrow_statContext() *Throw_statContext {
	var p = new(Throw_statContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_throw_stat
	return p
}

func (*Throw_statContext) IsThrow_statContext() {}

func NewThrow_statContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Throw_statContext {
	var p = new(Throw_statContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_throw_stat

	return p
}

func (s *Throw_statContext) GetParser() antlr.Parser { return s.parser }

func (s *Throw_statContext) Throw_stat_sub() IThrow_stat_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IThrow_stat_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IThrow_stat_subContext)
}

func (s *Throw_statContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Throw_statContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Throw_statContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterThrow_stat(s)
	}
}

func (s *Throw_statContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitThrow_stat(s)
	}
}

func (p *powerbuilderParser) Throw_stat() (localctx IThrow_statContext) {
	localctx = NewThrow_statContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, powerbuilderParserRULE_throw_stat)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1130)
		p.Throw_stat_sub()
	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) Identifier_name() IIdentifier_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_nameContext)
}

func (s *IdentifierContext) SUPER() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserSUPER, 0)
}

func (s *IdentifierContext) COLONCOLON() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCOLONCOLON, 0)
}

func (s *IdentifierContext) CREATE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCREATE, 0)
}

func (s *IdentifierContext) DESTROY() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDESTROY, 0)
}

func (s *IdentifierContext) Identifier_name_ex() IIdentifier_name_exContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_name_exContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_name_exContext)
}

func (s *IdentifierContext) DOT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDOT, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (p *powerbuilderParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, powerbuilderParserRULE_identifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1152)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 145, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1132)
			p.Identifier_name()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1133)
			p.Match(powerbuilderParserSUPER)
		}
		{
			p.SetState(1134)
			p.Match(powerbuilderParserCOLONCOLON)
		}
		p.SetState(1138)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case powerbuilderParserCREATE:
			{
				p.SetState(1135)
				p.Match(powerbuilderParserCREATE)
			}

		case powerbuilderParserDESTROY:
			{
				p.SetState(1136)
				p.Match(powerbuilderParserDESTROY)
			}

		case powerbuilderParserREADONLY, powerbuilderParserTYPE, powerbuilderParserUPDATE, powerbuilderParserOPEN, powerbuilderParserGOTO, powerbuilderParserCLOSE, powerbuilderParserSELECT, powerbuilderParserDELETE, powerbuilderParserINSERT, powerbuilderParserTIME2, powerbuilderParserDESCRIBE, powerbuilderParserID:
			{
				p.SetState(1137)
				p.Identifier_name_ex()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1140)
			p.Identifier_name()
		}
		{
			p.SetState(1141)
			p.Match(powerbuilderParserCOLONCOLON)
		}
		{
			p.SetState(1142)
			_la = p.GetTokenStream().LA(1)

			if !(_la == powerbuilderParserCREATE || _la == powerbuilderParserDESTROY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1144)
			p.Identifier_name()
		}
		{
			p.SetState(1145)
			p.Match(powerbuilderParserDOT)
		}
		{
			p.SetState(1146)
			_la = p.GetTokenStream().LA(1)

			if !(_la == powerbuilderParserCREATE || _la == powerbuilderParserDESTROY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1148)
			p.Identifier_name()
		}
		{
			p.SetState(1149)
			p.Match(powerbuilderParserCOLONCOLON)
		}
		{
			p.SetState(1150)
			p.Identifier_name_ex()
		}

	}

	return localctx
}

// IIdentifier_nameContext is an interface to support dynamic dispatch.
type IIdentifier_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifier_nameContext differentiates from other interfaces.
	IsIdentifier_nameContext()
}

type Identifier_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifier_nameContext() *Identifier_nameContext {
	var p = new(Identifier_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_identifier_name
	return p
}

func (*Identifier_nameContext) IsIdentifier_nameContext() {}

func NewIdentifier_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Identifier_nameContext {
	var p = new(Identifier_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_identifier_name

	return p
}

func (s *Identifier_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Identifier_nameContext) ID() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserID, 0)
}

func (s *Identifier_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Identifier_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Identifier_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterIdentifier_name(s)
	}
}

func (s *Identifier_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitIdentifier_name(s)
	}
}

func (p *powerbuilderParser) Identifier_name() (localctx IIdentifier_nameContext) {
	localctx = NewIdentifier_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, powerbuilderParserRULE_identifier_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1154)
		p.Match(powerbuilderParserID)
	}

	return localctx
}

// IIdentifier_name_exContext is an interface to support dynamic dispatch.
type IIdentifier_name_exContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifier_name_exContext differentiates from other interfaces.
	IsIdentifier_name_exContext()
}

type Identifier_name_exContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifier_name_exContext() *Identifier_name_exContext {
	var p = new(Identifier_name_exContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_identifier_name_ex
	return p
}

func (*Identifier_name_exContext) IsIdentifier_name_exContext() {}

func NewIdentifier_name_exContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Identifier_name_exContext {
	var p = new(Identifier_name_exContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_identifier_name_ex

	return p
}

func (s *Identifier_name_exContext) GetParser() antlr.Parser { return s.parser }

func (s *Identifier_name_exContext) Identifier_name() IIdentifier_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_nameContext)
}

func (s *Identifier_name_exContext) SELECT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserSELECT, 0)
}

func (s *Identifier_name_exContext) TYPE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTYPE, 0)
}

func (s *Identifier_name_exContext) UPDATE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserUPDATE, 0)
}

func (s *Identifier_name_exContext) DELETE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDELETE, 0)
}

func (s *Identifier_name_exContext) OPEN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserOPEN, 0)
}

func (s *Identifier_name_exContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCLOSE, 0)
}

func (s *Identifier_name_exContext) GOTO() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserGOTO, 0)
}

func (s *Identifier_name_exContext) INSERT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserINSERT, 0)
}

func (s *Identifier_name_exContext) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDESCRIBE, 0)
}

func (s *Identifier_name_exContext) TIME2() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTIME2, 0)
}

func (s *Identifier_name_exContext) READONLY() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserREADONLY, 0)
}

func (s *Identifier_name_exContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Identifier_name_exContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Identifier_name_exContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterIdentifier_name_ex(s)
	}
}

func (s *Identifier_name_exContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitIdentifier_name_ex(s)
	}
}

func (p *powerbuilderParser) Identifier_name_ex() (localctx IIdentifier_name_exContext) {
	localctx = NewIdentifier_name_exContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, powerbuilderParserRULE_identifier_name_ex)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1168)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case powerbuilderParserID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1156)
			p.Identifier_name()
		}

	case powerbuilderParserSELECT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1157)
			p.Match(powerbuilderParserSELECT)
		}

	case powerbuilderParserTYPE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1158)
			p.Match(powerbuilderParserTYPE)
		}

	case powerbuilderParserUPDATE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1159)
			p.Match(powerbuilderParserUPDATE)
		}

	case powerbuilderParserDELETE:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1160)
			p.Match(powerbuilderParserDELETE)
		}

	case powerbuilderParserOPEN:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1161)
			p.Match(powerbuilderParserOPEN)
		}

	case powerbuilderParserCLOSE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1162)
			p.Match(powerbuilderParserCLOSE)
		}

	case powerbuilderParserGOTO:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1163)
			p.Match(powerbuilderParserGOTO)
		}

	case powerbuilderParserINSERT:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1164)
			p.Match(powerbuilderParserINSERT)
		}

	case powerbuilderParserDESCRIBE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1165)
			p.Match(powerbuilderParserDESCRIBE)
		}

	case powerbuilderParserTIME2:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1166)
			p.Match(powerbuilderParserTIME2)
		}

	case powerbuilderParserREADONLY:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1167)
			p.Match(powerbuilderParserREADONLY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAtom_subContext is an interface to support dynamic dispatch.
type IAtom_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtom_subContext differentiates from other interfaces.
	IsAtom_subContext()
}

type Atom_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtom_subContext() *Atom_subContext {
	var p = new(Atom_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_atom_sub
	return p
}

func (*Atom_subContext) IsAtom_subContext() {}

func NewAtom_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Atom_subContext {
	var p = new(Atom_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_atom_sub

	return p
}

func (s *Atom_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Atom_subContext) Identifier_name() IIdentifier_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_nameContext)
}

func (s *Atom_subContext) Array_access_atom() IArray_access_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IArray_access_atomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IArray_access_atomContext)
}

func (s *Atom_subContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLPAREN, 0)
}

func (s *Atom_subContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRPAREN, 0)
}

func (s *Atom_subContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *Atom_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Atom_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Atom_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterAtom_sub(s)
	}
}

func (s *Atom_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitAtom_sub(s)
	}
}

func (p *powerbuilderParser) Atom_sub() (localctx IAtom_subContext) {
	localctx = NewAtom_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, powerbuilderParserRULE_atom_sub)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1179)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 148, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1170)
			p.Array_access_atom()
		}

	case 2:
		{
			p.SetState(1171)
			p.Identifier_name()
		}
		{
			p.SetState(1172)
			p.Match(powerbuilderParserLPAREN)
		}
		p.SetState(1174)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == powerbuilderParserREF || _la == powerbuilderParserCLOSE || _la == powerbuilderParserHALT || _la == powerbuilderParserLCURLY {
			{
				p.SetState(1173)
				p.Expression_list()
			}

		}
		{
			p.SetState(1176)
			p.Match(powerbuilderParserRPAREN)
		}

	case 3:
		{
			p.SetState(1178)
			p.Identifier_name()
		}

	}

	return localctx
}

// IAtom_sub_call1Context is an interface to support dynamic dispatch.
type IAtom_sub_call1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtom_sub_call1Context differentiates from other interfaces.
	IsAtom_sub_call1Context()
}

type Atom_sub_call1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtom_sub_call1Context() *Atom_sub_call1Context {
	var p = new(Atom_sub_call1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_atom_sub_call1
	return p
}

func (*Atom_sub_call1Context) IsAtom_sub_call1Context() {}

func NewAtom_sub_call1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Atom_sub_call1Context {
	var p = new(Atom_sub_call1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_atom_sub_call1

	return p
}

func (s *Atom_sub_call1Context) GetParser() antlr.Parser { return s.parser }

func (s *Atom_sub_call1Context) LPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLPAREN, 0)
}

func (s *Atom_sub_call1Context) RPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRPAREN, 0)
}

func (s *Atom_sub_call1Context) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Atom_sub_call1Context) DESCRIBE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDESCRIBE, 0)
}

func (s *Atom_sub_call1Context) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *Atom_sub_call1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Atom_sub_call1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Atom_sub_call1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterAtom_sub_call1(s)
	}
}

func (s *Atom_sub_call1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitAtom_sub_call1(s)
	}
}

func (p *powerbuilderParser) Atom_sub_call1() (localctx IAtom_sub_call1Context) {
	localctx = NewAtom_sub_call1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, powerbuilderParserRULE_atom_sub_call1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1183)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case powerbuilderParserSUPER, powerbuilderParserID:
		{
			p.SetState(1181)
			p.Identifier()
		}

	case powerbuilderParserDESCRIBE:
		{
			p.SetState(1182)
			p.Match(powerbuilderParserDESCRIBE)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(1185)
		p.Match(powerbuilderParserLPAREN)
	}
	p.SetState(1187)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == powerbuilderParserREF || _la == powerbuilderParserCLOSE || _la == powerbuilderParserHALT || _la == powerbuilderParserLCURLY {
		{
			p.SetState(1186)
			p.Expression_list()
		}

	}
	{
		p.SetState(1189)
		p.Match(powerbuilderParserRPAREN)
	}

	return localctx
}

// IAtom_sub_array1Context is an interface to support dynamic dispatch.
type IAtom_sub_array1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtom_sub_array1Context differentiates from other interfaces.
	IsAtom_sub_array1Context()
}

type Atom_sub_array1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtom_sub_array1Context() *Atom_sub_array1Context {
	var p = new(Atom_sub_array1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_atom_sub_array1
	return p
}

func (*Atom_sub_array1Context) IsAtom_sub_array1Context() {}

func NewAtom_sub_array1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Atom_sub_array1Context {
	var p = new(Atom_sub_array1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_atom_sub_array1

	return p
}

func (s *Atom_sub_array1Context) GetParser() antlr.Parser { return s.parser }

func (s *Atom_sub_array1Context) Identifier_name() IIdentifier_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_nameContext)
}

func (s *Atom_sub_array1Context) LBRACE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLBRACE, 0)
}

func (s *Atom_sub_array1Context) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *Atom_sub_array1Context) RBRACE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRBRACE, 0)
}

func (s *Atom_sub_array1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Atom_sub_array1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Atom_sub_array1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterAtom_sub_array1(s)
	}
}

func (s *Atom_sub_array1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitAtom_sub_array1(s)
	}
}

func (p *powerbuilderParser) Atom_sub_array1() (localctx IAtom_sub_array1Context) {
	localctx = NewAtom_sub_array1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, powerbuilderParserRULE_atom_sub_array1)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1191)
		p.Identifier_name()
	}
	{
		p.SetState(1192)
		p.Match(powerbuilderParserLBRACE)
	}
	{
		p.SetState(1193)
		p.Expression_list()
	}
	{
		p.SetState(1194)
		p.Match(powerbuilderParserRBRACE)
	}

	return localctx
}

// IAtom_sub_ref1Context is an interface to support dynamic dispatch.
type IAtom_sub_ref1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtom_sub_ref1Context differentiates from other interfaces.
	IsAtom_sub_ref1Context()
}

type Atom_sub_ref1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtom_sub_ref1Context() *Atom_sub_ref1Context {
	var p = new(Atom_sub_ref1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_atom_sub_ref1
	return p
}

func (*Atom_sub_ref1Context) IsAtom_sub_ref1Context() {}

func NewAtom_sub_ref1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Atom_sub_ref1Context {
	var p = new(Atom_sub_ref1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_atom_sub_ref1

	return p
}

func (s *Atom_sub_ref1Context) GetParser() antlr.Parser { return s.parser }

func (s *Atom_sub_ref1Context) Identifier_name() IIdentifier_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_nameContext)
}

func (s *Atom_sub_ref1Context) BRACES() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserBRACES, 0)
}

func (s *Atom_sub_ref1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Atom_sub_ref1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Atom_sub_ref1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterAtom_sub_ref1(s)
	}
}

func (s *Atom_sub_ref1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitAtom_sub_ref1(s)
	}
}

func (p *powerbuilderParser) Atom_sub_ref1() (localctx IAtom_sub_ref1Context) {
	localctx = NewAtom_sub_ref1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, powerbuilderParserRULE_atom_sub_ref1)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1196)
		p.Identifier_name()
	}
	{
		p.SetState(1197)
		p.Match(powerbuilderParserBRACES)
	}

	return localctx
}

// IAtom_sub_member1Context is an interface to support dynamic dispatch.
type IAtom_sub_member1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtom_sub_member1Context differentiates from other interfaces.
	IsAtom_sub_member1Context()
}

type Atom_sub_member1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtom_sub_member1Context() *Atom_sub_member1Context {
	var p = new(Atom_sub_member1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_atom_sub_member1
	return p
}

func (*Atom_sub_member1Context) IsAtom_sub_member1Context() {}

func NewAtom_sub_member1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Atom_sub_member1Context {
	var p = new(Atom_sub_member1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_atom_sub_member1

	return p
}

func (s *Atom_sub_member1Context) GetParser() antlr.Parser { return s.parser }

func (s *Atom_sub_member1Context) Identifier() IIdentifierContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifierContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *Atom_sub_member1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Atom_sub_member1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Atom_sub_member1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterAtom_sub_member1(s)
	}
}

func (s *Atom_sub_member1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitAtom_sub_member1(s)
	}
}

func (p *powerbuilderParser) Atom_sub_member1() (localctx IAtom_sub_member1Context) {
	localctx = NewAtom_sub_member1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, powerbuilderParserRULE_atom_sub_member1)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1199)
		p.Identifier()
	}

	return localctx
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_atom
	return p
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) Event_call_statement_sub() IEvent_call_statement_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEvent_call_statement_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEvent_call_statement_subContext)
}

func (s *AtomContext) Atom_sub() IAtom_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_subContext)
}

func (s *AtomContext) DOT() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDOT, 0)
}

func (s *AtomContext) Identifier_name_ex() IIdentifier_name_exContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_name_exContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_name_exContext)
}

func (s *AtomContext) Cast_expression() ICast_expressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICast_expressionContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICast_expressionContext)
}

func (s *AtomContext) Atom_sub_call1() IAtom_sub_call1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_sub_call1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_sub_call1Context)
}

func (s *AtomContext) Atom_sub_array1() IAtom_sub_array1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_sub_array1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_sub_array1Context)
}

func (s *AtomContext) Atom_sub_ref1() IAtom_sub_ref1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_sub_ref1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_sub_ref1Context)
}

func (s *AtomContext) Atom_sub_member1() IAtom_sub_member1Context {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtom_sub_member1Context)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtom_sub_member1Context)
}

func (s *AtomContext) Numeric_atom() INumeric_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*INumeric_atomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(INumeric_atomContext)
}

func (s *AtomContext) Boolean_atom() IBoolean_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IBoolean_atomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IBoolean_atomContext)
}

func (s *AtomContext) ENUM() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserENUM, 0)
}

func (s *AtomContext) DQUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDQUOTED_STRING, 0)
}

func (s *AtomContext) QUOTED_STRING() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserQUOTED_STRING, 0)
}

func (s *AtomContext) DATE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDATE, 0)
}

func (s *AtomContext) TIME() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserTIME, 0)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitAtom(s)
	}
}

func (p *powerbuilderParser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, powerbuilderParserRULE_atom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1218)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 151, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1201)
			p.Event_call_statement_sub()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1202)
			p.Atom_sub()
		}

		{
			p.SetState(1203)
			p.Match(powerbuilderParserDOT)
		}
		{
			p.SetState(1204)
			p.Identifier_name_ex()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1206)
			p.Cast_expression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1207)
			p.Atom_sub_call1()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1208)
			p.Atom_sub_array1()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1209)
			p.Atom_sub_ref1()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1210)
			p.Atom_sub_member1()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1211)
			p.Numeric_atom()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1212)
			p.Boolean_atom()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1213)
			p.Match(powerbuilderParserENUM)
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1214)
			p.Match(powerbuilderParserDQUOTED_STRING)
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1215)
			p.Match(powerbuilderParserQUOTED_STRING)
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1216)
			p.Match(powerbuilderParserDATE)
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1217)
			p.Match(powerbuilderParserTIME)
		}

	}

	return localctx
}

// IArray_access_atomContext is an interface to support dynamic dispatch.
type IArray_access_atomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArray_access_atomContext differentiates from other interfaces.
	IsArray_access_atomContext()
}

type Array_access_atomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArray_access_atomContext() *Array_access_atomContext {
	var p = new(Array_access_atomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_array_access_atom
	return p
}

func (*Array_access_atomContext) IsArray_access_atomContext() {}

func NewArray_access_atomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Array_access_atomContext {
	var p = new(Array_access_atomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_array_access_atom

	return p
}

func (s *Array_access_atomContext) GetParser() antlr.Parser { return s.parser }

func (s *Array_access_atomContext) Identifier_name() IIdentifier_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_nameContext)
}

func (s *Array_access_atomContext) LBRACE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLBRACE, 0)
}

func (s *Array_access_atomContext) Expression_list() IExpression_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpression_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IExpression_listContext)
}

func (s *Array_access_atomContext) RBRACE() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRBRACE, 0)
}

func (s *Array_access_atomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Array_access_atomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Array_access_atomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterArray_access_atom(s)
	}
}

func (s *Array_access_atomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitArray_access_atom(s)
	}
}

func (p *powerbuilderParser) Array_access_atom() (localctx IArray_access_atomContext) {
	localctx = NewArray_access_atomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, powerbuilderParserRULE_array_access_atom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1220)
		p.Identifier_name()
	}
	{
		p.SetState(1221)
		p.Match(powerbuilderParserLBRACE)
	}
	{
		p.SetState(1222)
		p.Expression_list()
	}
	{
		p.SetState(1223)
		p.Match(powerbuilderParserRBRACE)
	}

	return localctx
}

// INumeric_atomContext is an interface to support dynamic dispatch.
type INumeric_atomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumeric_atomContext differentiates from other interfaces.
	IsNumeric_atomContext()
}

type Numeric_atomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumeric_atomContext() *Numeric_atomContext {
	var p = new(Numeric_atomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_numeric_atom
	return p
}

func (*Numeric_atomContext) IsNumeric_atomContext() {}

func NewNumeric_atomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Numeric_atomContext {
	var p = new(Numeric_atomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_numeric_atom

	return p
}

func (s *Numeric_atomContext) GetParser() antlr.Parser { return s.parser }

func (s *Numeric_atomContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserNUMBER, 0)
}

func (s *Numeric_atomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Numeric_atomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Numeric_atomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterNumeric_atom(s)
	}
}

func (s *Numeric_atomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitNumeric_atom(s)
	}
}

func (p *powerbuilderParser) Numeric_atom() (localctx INumeric_atomContext) {
	localctx = NewNumeric_atomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, powerbuilderParserRULE_numeric_atom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1225)
		p.Match(powerbuilderParserNUMBER)
	}

	return localctx
}

// IBoolean_atomContext is an interface to support dynamic dispatch.
type IBoolean_atomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBoolean_atomContext differentiates from other interfaces.
	IsBoolean_atomContext()
}

type Boolean_atomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoolean_atomContext() *Boolean_atomContext {
	var p = new(Boolean_atomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_boolean_atom
	return p
}

func (*Boolean_atomContext) IsBoolean_atomContext() {}

func NewBoolean_atomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Boolean_atomContext {
	var p = new(Boolean_atomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_boolean_atom

	return p
}

func (s *Boolean_atomContext) GetParser() antlr.Parser { return s.parser }

func (s *Boolean_atomContext) BOOLEAN_ATOM() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserBOOLEAN_ATOM, 0)
}

func (s *Boolean_atomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Boolean_atomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Boolean_atomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterBoolean_atom(s)
	}
}

func (s *Boolean_atomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitBoolean_atom(s)
	}
}

func (p *powerbuilderParser) Boolean_atom() (localctx IBoolean_atomContext) {
	localctx = NewBoolean_atomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, powerbuilderParserRULE_boolean_atom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1227)
		p.Match(powerbuilderParserBOOLEAN_ATOM)
	}

	return localctx
}

// ICast_expressionContext is an interface to support dynamic dispatch.
type ICast_expressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCast_expressionContext differentiates from other interfaces.
	IsCast_expressionContext()
}

type Cast_expressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCast_expressionContext() *Cast_expressionContext {
	var p = new(Cast_expressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_cast_expression
	return p
}

func (*Cast_expressionContext) IsCast_expressionContext() {}

func NewCast_expressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Cast_expressionContext {
	var p = new(Cast_expressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_cast_expression

	return p
}

func (s *Cast_expressionContext) GetParser() antlr.Parser { return s.parser }

func (s *Cast_expressionContext) Data_type_sub() IData_type_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_subContext)
}

func (s *Cast_expressionContext) LPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserLPAREN, 0)
}

func (s *Cast_expressionContext) AllExpression() []IExpressionContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IExpressionContext)(nil)).Elem())
	var tst = make([]IExpressionContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IExpressionContext)
		}
	}

	return tst
}

func (s *Cast_expressionContext) Expression(i int) IExpressionContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IExpressionContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *Cast_expressionContext) RPAREN() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserRPAREN, 0)
}

func (s *Cast_expressionContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(powerbuilderParserCOMMA)
}

func (s *Cast_expressionContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(powerbuilderParserCOMMA, i)
}

func (s *Cast_expressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Cast_expressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Cast_expressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterCast_expression(s)
	}
}

func (s *Cast_expressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitCast_expression(s)
	}
}

func (p *powerbuilderParser) Cast_expression() (localctx ICast_expressionContext) {
	localctx = NewCast_expressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, powerbuilderParserRULE_cast_expression)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1229)
		p.Data_type_sub()
	}
	{
		p.SetState(1230)
		p.Match(powerbuilderParserLPAREN)
	}
	{
		p.SetState(1231)
		p.Expression()
	}
	p.SetState(1236)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == powerbuilderParserCOMMA {
		{
			p.SetState(1232)
			p.Match(powerbuilderParserCOMMA)
		}
		{
			p.SetState(1233)
			p.Expression()
		}

		p.SetState(1238)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1239)
		p.Match(powerbuilderParserRPAREN)
	}

	return localctx
}

// IData_type_subContext is an interface to support dynamic dispatch.
type IData_type_subContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsData_type_subContext differentiates from other interfaces.
	IsData_type_subContext()
}

type Data_type_subContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyData_type_subContext() *Data_type_subContext {
	var p = new(Data_type_subContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_data_type_sub
	return p
}

func (*Data_type_subContext) IsData_type_subContext() {}

func NewData_type_subContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Data_type_subContext {
	var p = new(Data_type_subContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_data_type_sub

	return p
}

func (s *Data_type_subContext) GetParser() antlr.Parser { return s.parser }

func (s *Data_type_subContext) DATA_TYPE_SUB() antlr.TerminalNode {
	return s.GetToken(powerbuilderParserDATA_TYPE_SUB, 0)
}

func (s *Data_type_subContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Data_type_subContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Data_type_subContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterData_type_sub(s)
	}
}

func (s *Data_type_subContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitData_type_sub(s)
	}
}

func (p *powerbuilderParser) Data_type_sub() (localctx IData_type_subContext) {
	localctx = NewData_type_subContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, powerbuilderParserRULE_data_type_sub)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1241)
		p.Match(powerbuilderParserDATA_TYPE_SUB)
	}

	return localctx
}

// IData_type_nameContext is an interface to support dynamic dispatch.
type IData_type_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsData_type_nameContext differentiates from other interfaces.
	IsData_type_nameContext()
}

type Data_type_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyData_type_nameContext() *Data_type_nameContext {
	var p = new(Data_type_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = powerbuilderParserRULE_data_type_name
	return p
}

func (*Data_type_nameContext) IsData_type_nameContext() {}

func NewData_type_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Data_type_nameContext {
	var p = new(Data_type_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = powerbuilderParserRULE_data_type_name

	return p
}

func (s *Data_type_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Data_type_nameContext) Data_type_sub() IData_type_subContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IData_type_subContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IData_type_subContext)
}

func (s *Data_type_nameContext) Identifier_name() IIdentifier_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IIdentifier_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IIdentifier_nameContext)
}

func (s *Data_type_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Data_type_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Data_type_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.EnterData_type_name(s)
	}
}

func (s *Data_type_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(powerbuilderParserListener); ok {
		listenerT.ExitData_type_name(s)
	}
}

func (p *powerbuilderParser) Data_type_name() (localctx IData_type_nameContext) {
	localctx = NewData_type_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, powerbuilderParserRULE_data_type_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1245)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case powerbuilderParserDATA_TYPE_SUB:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1243)
			p.Data_type_sub()
		}

	case powerbuilderParserID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1244)
			p.Identifier_name()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}
